"""
Account
"""
type Account {
  """
  Account ID
  """
  id: String!

  """
  Account number, the equivalent of a human-friendly public key
  """
  num: Int!

  """
  Realm number
  """
  realmId: Int!

  """
  Shard number
  """
  shardId: Int!
}

"""
Solana Action
"""
type Action {
  name: String!
  type: String!
}

enum ActionEnum {
  """
  Transfer
  """
  transfer

  """
  Burn
  """
  burn

  """
  Mint
  """
  create

  """
  Mint
  """
  localMint

  """
  Add Quantity
  """
  addQuantity

  """
  Transaction
  """
  transaction

  """
  Fee
  """
  fee
}

"""
Select by action
"""
input ActionSelector {
  """
  Action is
  """
  is: ActionEnum

  """
  Action not
  """
  not: ActionEnum

  """
  Action in the list
  """
  in: [ActionEnum!]

  """
  Action not in the list
  """
  notIn: [ActionEnum!]
}

enum ActiveAddress {
  """
  Address
  """
  address
}

"""
ActivePeriod
"""
type ActivePeriod {
  """
  Billing day
  """
  billingDay: Int!

  """
  Period ends at
  """
  ends: UtilitiesDate!

  """
  Is blocked
  """
  isBlocked: Boolean!

  """
  Is paid
  """
  isPaid: Boolean!

  """
  Is points consumed
  """
  isPointsConsumed: Boolean!

  """
  Is spent
  """
  isSpent: Boolean!

  """
  Total available points
  """
  points: BigInt!

  """
  Remaining points
  """
  pointsRemaining: BigInt!

  """
  Period starts at
  """
  starts: UtilitiesDate!
}

"""
Blockchain address
"""
type Address {
  """
  Address
  """
  address: String

  """
  Annotations ( tags ), if exists
  """
  annotation: String
}

"""
Address selector
"""
input AddressSelector {
  """
  Equal to Address
  """
  is: String

  """
  Not Equal to Address
  """
  not: String

  """
  In the list of Addresses
  """
  in: [String!]

  """
  Not in the list of Addresses
  """
  notIn: [String!]
}

"""
Address selector
"""
input AddressSelectorIn {
  """
  Equal to Address
  """
  is: String

  """
  In the list of Addresses
  """
  in: [String!]
}

"""
Address with statistics
"""
type AddressStatDimension {
  """
  Address
  """
  address: String

  """
  Annotations ( tags ), if exists
  """
  annotation: String

  """
  Balance
  """
  balance(in: BaseCurrencyEnum): Float

  """
  First active
  """
  firstActive: DateTime

  """
  Inbound transactions
  """
  inboundTransactions: Int

  """
  Inflows
  """
  inflows: Float

  """
  Last active
  """
  lastActive: DateTime

  """
  Outbound transactions
  """
  outboundTransactions: Int

  """
  Outflows
  """
  outflows: Float

  """
  Unique days with transfers
  """
  uniqueDaysWithTransfers: Int

  """
  Unique receivers
  """
  uniqueReceivers: Int

  """
  Unique senders
  """
  uniqueSenders: Int
}

"""
Blockchain account with address and type
"""
type AddressWithAccount {
  """
  Account ID
  """
  account: String!

  """
  Address
  """
  address: String

  """
  Annotations ( tags ), if exists
  """
  annotation: String

  """
  Account type
  """
  type: String!
}

"""
Algorand Blockchain
"""
type Algorand {
  """
  Basic information about address ( or smart contract )
  """
  address(address: [AddressSelectorIn!]!): [AlgorandAddressInfo!]!

  """
  Arguments of Smart Contract Calls and Events
  """
  arguments(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
    txType: TxTypeSelector
    txFrom: [AddressSelector!]
    caller: [AddressSelector!]
    reference: [AddressSelector!]
    value: [ArgumentValueSelector!]
    argument: [ArgumentSelector!]
    smartContractAddress: [AddressSelector!]
    argindex: ArgumentIndexSelector
    any: [AlgorandArgumentFilter!]
    options: QueryOptions
  ): [AlgorandArguments!]

  """
  Blockchain Blocks
  """
  blocks(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    proposer: [AddressSelector!]
    blockReward: [AmountSelector!]
    nextProtocol: StringIdSelector
    currentProtocol: StringIdSelector
    any: [AlgorandBlockFilter!]
    options: QueryOptions
  ): [AlgorandBlocks!]

  """
  Money flow using Coinpath technology
  """
  coinpath(
    sender: AddressSelector
    receiver: AddressSelector
    currency: [AlgorandCurrencySelector!]
    initialAddress: AddressSelector
    initialDate: DateSelector
    initialTime: DateTimeSelector
    date: DateSelector
    time: DateTimeSelector
    depth: IntegerLimitedSelector
    options: CoinpathOptions
  ): [AlgorandCoinpath!]

  """
  Smart Contract Calls
  """
  smartContractCalls(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
    txSender: [AddressSelector!]
    smartContractAddress: [AddressSelector!]
    txType: TxTypeSelector
    any: [AlgorandSmartContractCallFilter!]
    options: QueryOptions
  ): [AlgorandSmartContractCalls!]

  """
  Blockchain Transactions
  """
  transactions(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txSender: [AddressSelector!]
    txIndex: TxIndexSelector
    txCurrency: [AlgorandCurrencySelector!]
    txType: TxTypeSelector
    txSubtype: TxSubtypeSelector
    group: GroupSelector
    any: [AlgorandTransactionFilter!]
    options: QueryOptions
  ): [AlgorandTransactions!]

  """
  Currency Transfers
  """
  transfers(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txSender: [AddressSelector!]
    txIndex: TxIndexSelector
    sender: [AddressSelector!]
    receiver: [AddressSelector!]
    currency: [AlgorandCurrencySelector!]
    amount: [AmountSelector!]
    txType: TxTypeSelector
    transferType: AlgorandTransferTypeSelector
    any: [AlgorandTransferFilter!]
    options: QueryOptions
  ): [AlgorandTransfers!]
}

"""
Address detailed information for Algorand network
"""
type AlgorandAddressInfo {
  """
  Address
  """
  address: Address

  """
  Current address balance
  """
  balance(in: BaseCurrencyEnum): Float

  """
  Current pending rewards
  """
  pendingRewards(in: BaseCurrencyEnum): Float

  """
  Current rewards
  """
  rewards(in: BaseCurrencyEnum): Float

  """
  Current round
  """
  round: String

  """
  Smart Contract if exists on the address
  """
  smartContract: AlgorandSmartContract

  """
  Current status
  """
  status: String
}

input AlgorandArgumentFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: TxIndexSelector
  txType: TxTypeSelector
  txFrom: [AddressSelector!]
  caller: [AddressSelector!]
  reference: [AddressSelector!]
  value: [ArgumentValueSelector!]
  argument: [ArgumentSelector!]
  smartContractAddress: [AddressSelector!]
  argindex: ArgumentIndexSelector
}

"""
Arguments of Smart Contract Calls
"""
type AlgorandArguments {
  any(of: AlgorandArgumentsMeasureable!): String

  """
  Sequential index of value in array ( multi-dimensional)
  """
  argindex: Int!

  """
  Block in the blockchain
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Counts and other metrics
  """
  count(
    uniq: SmartContractCallsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
    txType: TxTypeSelector
    txFrom: [AddressSelector!]
    caller: [AddressSelector!]
    reference: [AddressSelector!]
    value: [ArgumentValueSelector!]
    argument: [ArgumentSelector!]
    smartContractAddress: [AddressSelector!]
    argindex: ArgumentIndexSelector
  ): Int

  """
  Counts and other metrics
  """
  countBigInt(
    uniq: SmartContractCallsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
    txType: TxTypeSelector
    txFrom: [AddressSelector!]
    caller: [AddressSelector!]
    reference: [AddressSelector!]
    value: [ArgumentValueSelector!]
    argument: [ArgumentSelector!]
    smartContractAddress: [AddressSelector!]
    argindex: ArgumentIndexSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber
  firstRound: Int
  genesisHash64: String
  genesisId: String
  lastRound: Int
  maximum(
    of: AlgorandArgumentsMeasureable!
    get: AlgorandArgumentsMeasureable
  ): String
  minimum(
    of: AlgorandArgumentsMeasureable!
    get: AlgorandArgumentsMeasureable
  ): String
  note: String
  poolerror: String

  """
  Smart contract being called
  """
  smartContract(smartContractAddress: [AddressSelector!]): AlgorandSmartContract

  """
  Transaction where call happened
  """
  transaction(
    txHash: [HashSelector!]
    txFrom: [AddressSelector!]
  ): TransactionHashIndex

  """
  Transaction sender
  """
  txSender(txSender: [AddressSelector!]): Address

  """
  Transaction type in which the transfer happened
  """
  txType(txType: [AlgorandTxType!]): AlgorandTxType

  """
  The Value of argument
  """
  value(value: [ArgumentValueSelector!]): String
}

enum AlgorandArgumentsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Transaction type
  """
  tx_type

  """
  Transaction Sender
  """
  tx_sender

  """
  Smart Contract
  """
  smart_contract

  """
  Argument value
  """
  argument_value

  """
  Argument index
  """
  argument_index
}

input AlgorandBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  proposer: [AddressSelector!]
  blockReward: [AmountSelector!]
  nextProtocol: StringIdSelector
  currentProtocol: StringIdSelector
}

"""
Blocks in Algorand blockchain
"""
type AlgorandBlocks {
  any(of: AlgorandBlocksMeasureable!): String
  count(
    uniq: AlgorandBlocksUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    proposer: [AddressSelector!]
    blockReward: [AmountSelector!]
    nextProtocol: StringIdSelector
    currentProtocol: StringIdSelector
  ): Int
  countBigInt(
    uniq: AlgorandBlocksUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    proposer: [AddressSelector!]
    blockReward: [AmountSelector!]
    nextProtocol: StringIdSelector
    currentProtocol: StringIdSelector
  ): BigInt
  currentProtocol: String

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber
  frac: BigInt!

  """
  Block hash
  """
  hash(blockHash: [HashSelector!]): String!

  """
  Block number (height) in blockchain
  """
  height(height: BlockSelector): Int!
  maximum(
    of: AlgorandBlocksMeasureable!
    get: AlgorandBlocksMeasureable
  ): String
  minimum(
    of: AlgorandBlocksMeasureable!
    get: AlgorandBlocksMeasureable
  ): String
  nextProtocol: String
  nextProtocolApprovals: BigInt
  nextProtocolSwitchOn: BigInt
  nextProtocolVoteBefore: BigInt

  """
  Previous block hash
  """
  previousBlockHash: String!

  """
  Block proposer
  """
  proposer(proposer: [AddressSelector!]): Address
  rate(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    proposer: [AddressSelector!]
    blockReward: [AmountSelector!]
    nextProtocol: StringIdSelector
    currentProtocol: StringIdSelector
  ): Float
  reward(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    proposer: [AddressSelector!]
    blockReward: [AmountSelector!]
    nextProtocol: StringIdSelector
    currentProtocol: StringIdSelector
  ): Float
  seed: String

  """
  Block timestamp
  """
  timestamp(time: DateTimeSelector): DateTime
  txnRoot: String!
  upgradeApprove: Int
  upgradePropose: String
}

enum AlgorandBlocksMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Block hash
  """
  block_hash

  """
  Block Reward
  """
  block_reward

  """
  Block Proposer
  """
  proposer

  """
  Next protocol approvals
  """
  next_protocol_approvals
}

enum AlgorandBlocksUniq {
  """
  Unique proposer count
  """
  proposers

  """
  Unique date count
  """
  dates
}

enum AlgorandCallsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Transaction type
  """
  tx_type

  """
  Transaction Sender
  """
  tx_sender

  """
  Smart Contract
  """
  smart_contract
}

"""
Coinpath
"""
type AlgorandCoinpath {
  """
  Summary of transfered value
  """
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """
  Block where transaction is included
  """
  block: Block

  """
  Count of transfers
  """
  count: Int

  """
  Count of transfers
  """
  countBigInt: BigInt

  """
  Currency of transfer
  """
  currency: Currency

  """
  1-based hop depth of the graph
  """
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """
  Receiver address
  """
  receiver: Address

  """
  Sender address
  """
  sender: Address

  """
  Transaction of transfer happened
  """
  transaction: TransactionHashValue
}

"""
Currency selector in Algorand blockchain.
  Currency is selected by asset ID. To select ALGO use ID=0
"""
input AlgorandCurrencySelector {
  """
  Currency is
  """
  is: Int

  """
  Currency not
  """
  not: Int

  """
  Currency in the list
  """
  in: [Int!]

  """
  Currency not in the list
  """
  notIn: [Int!]
}

enum AlgorandNetwork {
  """
  Algorand Mainnet (ALGO)
  """
  algorand

  """
  Algorand Testnet
  """
  algorand_testnet

  """
  Algorand Betanet
  """
  algorand_betanet
}

"""
Algorand smart contract
"""
type AlgorandSmartContract {
  """
  Smart Contract Address
  """
  address: Address!

  """
  Smart Contract byte code
  """
  bytecode: String

  """
  Smart Contract Deassembled source code
  """
  source: String
}

input AlgorandSmartContractCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: TxIndexSelector
  txSender: [AddressSelector!]
  smartContractAddress: [AddressSelector!]
  txType: TxTypeSelector
}

"""
Smart Contract Calls
"""
type AlgorandSmartContractCalls {
  any(of: AlgorandCallsMeasureable!): String

  """
  Block in the blockchain
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Counts and other metrics
  """
  count(
    uniq: SmartContractCallsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
    txSender: [AddressSelector!]
    smartContractAddress: [AddressSelector!]
    txType: TxTypeSelector
  ): Int

  """
  Counts and other metrics
  """
  countBigInt(
    uniq: SmartContractCallsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
    txSender: [AddressSelector!]
    smartContractAddress: [AddressSelector!]
    txType: TxTypeSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Fee used in transaction call
  """
  fee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
    txSender: [AddressSelector!]
    smartContractAddress: [AddressSelector!]
    txType: TxTypeSelector
  ): Float
  firstRound: Int
  genesisHash64: String
  genesisId: String
  lastRound: Int
  maximum(of: AlgorandCallsMeasureable!, get: AlgorandCallsMeasureable): String
  minimum(of: AlgorandCallsMeasureable!, get: AlgorandCallsMeasureable): String
  note: String
  poolerror: String

  """
  Smart contract being called
  """
  smartContract(smartContractAddress: [AddressSelector!]): AlgorandSmartContract

  """
  Transaction where call happened
  """
  transaction(
    txHash: [HashSelector!]
    txFrom: [AddressSelector!]
  ): TransactionHashIndex

  """
  Transaction sender
  """
  txSender(txSender: [AddressSelector!]): Address

  """
  Transaction type in which the transfer happened
  """
  txType(txType: [AlgorandTxType!]): AlgorandTxType
}

input AlgorandTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txSender: [AddressSelector!]
  txIndex: TxIndexSelector
  txCurrency: [AlgorandCurrencySelector!]
  txType: TxTypeSelector
  txSubtype: TxSubtypeSelector
  group: GroupSelector
}

"""
Transactions in Algorand blockchain
"""
type AlgorandTransactions {
  any(of: AlgorandTransactionsMeasureable!): String

  """
  Block where transfer transaction is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(
    uniq: AlgorandTransactionsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txSender: [AddressSelector!]
    txIndex: TxIndexSelector
    txCurrency: [AlgorandCurrencySelector!]
    txType: TxTypeSelector
    txSubtype: TxSubtypeSelector
    group: GroupSelector
  ): Int
  countBigInt(
    uniq: AlgorandTransactionsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txSender: [AddressSelector!]
    txIndex: TxIndexSelector
    txCurrency: [AlgorandCurrencySelector!]
    txType: TxTypeSelector
    txSubtype: TxSubtypeSelector
    group: GroupSelector
  ): BigInt

  """
  Asset related to transaction
  """
  currency(txCurrency: [AlgorandCurrencySelector!]): Currency

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber
  fee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txSender: [AddressSelector!]
    txIndex: TxIndexSelector
    txCurrency: [AlgorandCurrencySelector!]
    txType: TxTypeSelector
    txSubtype: TxSubtypeSelector
    group: GroupSelector
  ): Float
  firstRound: Int
  genesisHash: String
  genesisId: String
  group: String

  """
  Hash hex representation
  """
  hash(txHash: [HashSelector!]): String!

  """
  Transaction index in block, 0 based
  """
  index(txIndex: [TxIndexSelector!]): Int
  lastRound: Int
  maximum(
    of: AlgorandTransactionsMeasureable!
    get: AlgorandTransactionsMeasureable
  ): String
  minimum(
    of: AlgorandTransactionsMeasureable!
    get: AlgorandTransactionsMeasureable
  ): String
  note: String
  poolerror: String

  """
  Transaction sender
  """
  sender(txSender: [AddressSelector!]): Address

  """
  Transaction sub type
  """
  subtype(txType: TxSubtypeSelector): AlgorandTxSubType

  """
  Transaction type
  """
  type(txType: TxTypeSelector): AlgorandTxType
}

enum AlgorandTransactionsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Fee value
  """
  fee

  """
  Transaction hash
  """
  tx_hash

  """
  Transaction Sender
  """
  tx_sender
}

enum AlgorandTransactionsUniq {
  """
  Unique TX senders count
  """
  senders

  """
  Unique blocks
  """
  blocks

  """
  Unique date count
  """
  dates

  """
  Unique currencies
  """
  currencies
}

"""
Algorand transaction with attributes
"""
type AlgorandTransactionWithAttributes {
  """
  Block of the Output Transaction for this input
  """
  block: Int

  """
  Transaction fee
  """
  fee: Float
  firstRound: Int

  """
  Transaction rewards ( from )
  """
  fromrewards: Float
  group: String

  """
  Hash hex representation
  """
  hash: String!

  """
  Transaction index in block, 0-based
  """
  index: String!
  lastRound: Int
  lease: String
  note: String
  poolerror: String

  """
  Transfer transaction sender
  """
  sender: Address

  """
  Transaction sub type
  """
  subtype: AlgorandTxSubType

  """
  Transaction type in which the transfer happened
  """
  type: AlgorandTxType
}

input AlgorandTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txSender: [AddressSelector!]
  txIndex: TxIndexSelector
  sender: [AddressSelector!]
  receiver: [AddressSelector!]
  currency: [AlgorandCurrencySelector!]
  amount: [AmountSelector!]
  txType: TxTypeSelector
  transferType: AlgorandTransferTypeSelector
}

"""
Currency transfers from/to addresses in crypto currencies
"""
type AlgorandTransfers {
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txSender: [AddressSelector!]
    txIndex: TxIndexSelector
    sender: [AddressSelector!]
    receiver: [AddressSelector!]
    currency: [AlgorandCurrencySelector!]
    amount: [AmountSelector!]
    txType: TxTypeSelector
    transferType: AlgorandTransferTypeSelector
  ): Float
  any(of: AlgorandTransfersMeasureable!): String

  """
  Block where transfer transaction is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(
    uniq: TransfersUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txSender: [AddressSelector!]
    txIndex: TxIndexSelector
    sender: [AddressSelector!]
    receiver: [AddressSelector!]
    currency: [AlgorandCurrencySelector!]
    amount: [AmountSelector!]
    txType: TxTypeSelector
    transferType: AlgorandTransferTypeSelector
  ): Int
  countBigInt(
    uniq: TransfersUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txSender: [AddressSelector!]
    txIndex: TxIndexSelector
    sender: [AddressSelector!]
    receiver: [AddressSelector!]
    currency: [AlgorandCurrencySelector!]
    amount: [AmountSelector!]
    txType: TxTypeSelector
    transferType: AlgorandTransferTypeSelector
  ): BigInt

  """
  Currency of transfer
  """
  currency(currency: [AlgorandCurrencySelector!]): Currency

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber
  firstRound: Int
  lastRound: Int
  maximum(
    of: AlgorandTransfersMeasureable!
    get: AlgorandTransfersMeasureable
  ): String
  memo: String
  minimum(
    of: AlgorandTransfersMeasureable!
    get: AlgorandTransfersMeasureable
  ): String

  """
  Transfer receiver
  """
  receiver(receiver: [AddressSelector!]): Address

  """
  Transfer sender
  """
  sender(sender: [AddressSelector!]): Address

  """
  Transaction where transfer happened
  """
  transaction(txHash: [HashSelector!]): AlgorandTransactionWithAttributes

  """
  Transfer Type
  """
  transferType(transferType: [AlgorandTransferType!]): AlgorandTransferType
}

enum AlgorandTransfersMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Amount
  """
  amount

  """
  TX Sender
  """
  tx_sender

  """
  Sender
  """
  sender

  """
  Receiver
  """
  receiver

  """
  Currency symbol
  """
  currency_symbol

  """
  Currency Asset ID
  """
  asset_id

  """
  Transaction type
  """
  tx_type

  """
  Transfer type
  """
  transfer_type
}

enum AlgorandTransferType {
  """
  Genesis Block
  """
  genesis

  """
  Create Asset
  """
  create

  """
  Send
  """
  send

  """
  Close
  """
  close

  """
  Reward
  """
  reward

  """
  Asset Freeze
  """
  freeze

  """
  Asset Unfreeze
  """
  unfreeze
}

"""
Select transfers by type
"""
input AlgorandTransferTypeSelector {
  """
  Transfer Type is
  """
  is: AlgorandTransferType

  """
  Transfer Type not
  """
  not: AlgorandTransferType

  """
  Transfer Type in the list
  """
  in: [AlgorandTransferType!]

  """
  Transfer Type not in the list
  """
  notIn: [AlgorandTransferType!]
}

enum AlgorandTxSubType {
  """
  Send
  """
  send

  """
  Close
  """
  close

  """
  Create
  """
  create

  """
  Asset Configuration
  """
  configure

  """
  Asset Freeze
  """
  freeze

  """
  Asset Unfreeze
  """
  unfreeze

  """
  Key Reg
  """
  keyreg

  """
  None
  """
  none
}

enum AlgorandTxType {
  """
  Genesis Block
  """
  genesis

  """
  Pay
  """
  pay

  """
  Key Reg
  """
  keyreg

  """
  Asset Configuration
  """
  acfg

  """
  Asset Transfer
  """
  axfer

  """
  Asset Freeze or Unfreeze
  """
  afrz

  """
  Application Call
  """
  appl
}

enum AmountAggregateFunction {
  """
  Maximum
  """
  maximum

  """
  Minimum
  """
  minimum

  """
  Sum (total)
  """
  sum

  """
  Average
  """
  average

  """
  Median
  """
  median

  """
  Unique estimate fast
  """
  unique

  """
  Unique exact
  """
  uniqueExact

  """
  Any value
  """
  any

  """
  Last value
  """
  anyLast
}

"""
Select by amount
"""
input AmountSelector {
  """
  Amount is
  """
  is: Float

  """
  Amount not
  """
  not: Float

  """
  Amount in the list
  """
  in: [Float!]

  """
  Amount not in the list
  """
  notIn: [Float!]

  """
  Amount greater than
  """
  gt: Float

  """
  Amount less than
  """
  lt: Float

  """
  Amount less or equal than
  """
  lteq: Float

  """
  Amount greater or equal than
  """
  gteq: Float

  """
  Amount in range
  """
  between: [Float!]
}

"""
Selector of index of argument in call
"""
input ArgumentIndexSelector {
  """
  Tx index is
  """
  is: Int

  """
  Tx index not
  """
  not: Int

  """
  Tx index in the list
  """
  in: [Int!]

  """
  Tx index not in the list
  """
  notIn: [Int!]
}

"""
Argument of Smart contract method or event
"""
type ArgumentName {
  """
  Name
  """
  name: String!

  """
  Type
  """
  type: String!
}

"""
Argument name and value of smart contract call or event
"""
type ArgumentNameValue {
  """
  Argument name
  """
  argument: String!

  """
  Argument data type
  """
  argumentType: String!

  """
  Sequential index of value in array ( multi-dimensional)
  """
  index: String!

  """
  Value as String
  """
  value: String!
}

"""
Selector of argument for smart contract method or event
"""
input ArgumentSelector {
  """
  Argument is
  """
  is: String

  """
  Argument not
  """
  not: String

  """
  Argument in the list
  """
  in: [String!]

  """
  Argument not in the list
  """
  notIn: [String!]
}

"""
Selector of argument type for smart contract method or event
"""
input ArgumentTypeSelector {
  """
  Argument type is
  """
  is: String

  """
  Argument type not
  """
  not: String

  """
  Argument type in the list
  """
  in: [String!]

  """
  Argument type not in the list
  """
  notIn: [String!]
}

"""
Argument value of smart contract call or event
"""
type ArgumentValue {
  """
  Value as Address
  """
  address: EthereumAddressInfo

  """
  Value as String
  """
  value: String!
}

"""
Selector of value of argument for smart contract method or event
"""
input ArgumentValueSelector {
  """
  Value is
  """
  is: String

  """
  Value not
  """
  not: String

  """
  Value in the list
  """
  in: [String!]

  """
  Value not in the list
  """
  notIn: [String!]
}

enum BaseCurrencyEnum {
  """
  Dollar
  """
  USD

  """
  Binance Smart Chain
  """
  BNB

  """
  Ethereum
  """
  ETH

  """
  Tether USDT
  """
  USDT

  """
  Bitcoin
  """
  BTC
}

"""
Represents non-fractional signed whole numeric values. Since the value may
exceed the size of a 32-bit integer, it's encoded as a string.
"""
scalar BigInt

"""
Select by big number
"""
input BigIntegerSelector {
  """
  is
  """
  is: BigInt

  """
  not
  """
  not: BigInt

  """
  in the list
  """
  in: [BigInt!]

  """
  not in the list
  """
  notIn: [BigInt!]

  """
  greater than
  """
  gt: BigInt

  """
  less than
  """
  lt: BigInt

  """
  less or equal than
  """
  lteq: BigInt

  """
  greater or equal than
  """
  gteq: BigInt

  """
  in range
  """
  between: [BigInt!]
}

"""
Select by ID with BigInt datatype
"""
input BigIntIdSelector {
  """
  ID is
  """
  is: BigInt

  """
  ID not
  """
  not: BigInt

  """
  ID in the list
  """
  in: [BigInt!]

  """
  ID not in the list
  """
  notIn: [BigInt!]

  """
  ID greater than
  """
  gt: BigInt

  """
  ID less than
  """
  lt: BigInt

  """
  ID less or equal than
  """
  lteq: BigInt

  """
  ID greater or equal than
  """
  gteq: BigInt

  """
  ID in range
  """
  between: [BigInt!]
}

"""
Binance DEX
"""
type Binance {
  """
  Binance DEX Network Blocks
  """
  blocks(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockId: StringIdSelector
    validatorMoniker: StringIdSelector
    validatorFeeAddr: BinanceAddressSelector
    validatorOperatorAddress: BinanceAddressSelector
    validatorOperahraddress: BinanceAddressSelector
    any: [BinanceBlockFilter!]
    options: QueryOptions
  ): [BinanceBlock!]

  """
  Money flow using Coinpath technology
  """
  coinpath(
    sender: BinanceAddressSelector
    receiver: BinanceAddressSelector
    currency: [BinanceCurrencySelector!]
    initialAddress: BinanceAddressSelector
    initialDate: DateSelector
    initialTime: DateTimeSelector
    date: DateSelector
    time: DateTimeSelector
    depth: IntegerLimitedSelector
    options: CoinpathOptions
  ): [BinanceCoinpath!]

  """
  Binance DEX Network Exchange Orders
  """
  orders(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    orderOwner: [BinanceAddressSelector!]
    orderId: [OrderIdSelector!]
    baseCurrency: [BinanceCurrencySelector!]
    quoteCurrency: [BinanceCurrencySelector!]
    quoteAmount: [AmountSelector!]
    baseAmount: [AmountSelector!]
    price: [AmountSelector!]
    orderStatus: [OrderStatusSelector!]
    orderType: [OrderTypeSelector!]
    orderSide: [OrderSideSelector!]
    orderTimeInForce: [OrderTimeInForceSelector!]
    any: [BinanceOrderFilter!]
    options: QueryOptions
  ): [BinanceOrders!]

  """
  Binance DEX Network Trades between currencies
  """
  trades(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    buyer: [BinanceAddressSelector!]
    seller: [BinanceAddressSelector!]
    sellOrderId: [OrderIdSelector!]
    buyOrderId: [OrderIdSelector!]
    tradeId: [TradeIdSelector!]
    baseCurrency: [BinanceCurrencySelector!]
    quoteCurrency: [BinanceCurrencySelector!]
    quoteAmount: [AmountSelector!]
    baseAmount: [AmountSelector!]
    price: [AmountSelector!]
    any: [BinanceTradeFilter!]
    options: QueryOptions
  ): [BinanceTrades!]

  """
  Binance DEX Network Transactions
  """
  transactions(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    transactionType: BinanceTransactionTypeSelector
    proposalId: StringIdSelector
    currency: [BinanceCurrencySelector!]
    transactionCode: IntIdSelector
    transactionSource: IntIdSelector
    deposit: [AmountSelector!]
    any: [BinanceTransactionFilter!]
    options: QueryOptions
  ): [BinanceTransactions!]

  """
  Binance DEX Network Currency Transfers
  """
  transfers(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    sender: [BinanceAddressSelector!]
    receiver: [BinanceAddressSelector!]
    currency: [BinanceCurrencySelector!]
    transferType: [BinanceTransferTypeSelector!]
    orderId: [OrderIdSelector!]
    tradeId: [TradeIdSelector!]
    amount: [AmountSelector!]
    outputIndex: [OutputIndexSelector!]
    any: [BinanceTransferFilter!]
    options: QueryOptions
  ): [BinanceTransfers!]
}

"""
Binance Address should start with bnb and contain 42 chars.
"""
input BinanceAddressSelector {
  """
  Equal to Address
  """
  is: String

  """
  Not Equal to Address
  """
  not: String

  """
  In the list of Addresses
  """
  in: String

  """
  Not in the list of Addresses
  """
  notIn: String
}

"""
Block
"""
type BinanceBlock {
  any(of: BinanceBlocksMeasureable!): String

  """
  Block ID
  """
  blockId(blockId: StringIdSelector): String
  count(
    uniq: BinanceBlockUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockId: StringIdSelector
    validatorMoniker: StringIdSelector
    validatorFeeAddr: BinanceAddressSelector
    validatorOperatorAddress: BinanceAddressSelector
    validatorOperahraddress: BinanceAddressSelector
  ): Int
  countBigInt(
    uniq: BinanceBlockUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockId: StringIdSelector
    validatorMoniker: StringIdSelector
    validatorFeeAddr: BinanceAddressSelector
    validatorOperatorAddress: BinanceAddressSelector
    validatorOperahraddress: BinanceAddressSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Block number (height) in blockchain
  """
  height(height: BlockSelector): Int!
  maximum(of: BinanceBlocksMeasureable!, get: BinanceBlocksMeasureable): String
  minimum(of: BinanceBlocksMeasureable!, get: BinanceBlocksMeasureable): String

  """
  Block timestamp
  """
  timestamp(time: DateTimeSelector): DateTime

  """
  Validator consensus pubkey
  """
  validatorConsensusPubkey(validatorConsensusPubkey: StringIdSelector): String

  """
  Validator fee address
  """
  validatorFeeAddr(validatorFeeAddr: BinanceAddressSelector): Address

  """
  Validator moniker
  """
  validatorMoniker(validatorMoniker: StringIdSelector): String

  """
  Validator operator HR address
  """
  validatorOperaHrAddress(
    validatorOperaHrAddress: BinanceAddressSelector
  ): Address

  """
  Validator operator address
  """
  validatorOperatorAddress(
    validatorOperatorAddress: BinanceAddressSelector
  ): Address
}

input BinanceBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: StringIdSelector
  validatorMoniker: StringIdSelector
  validatorFeeAddr: BinanceAddressSelector
  validatorOperatorAddress: BinanceAddressSelector
  validatorOperahraddress: BinanceAddressSelector
}

enum BinanceBlocksMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Block hash
  """
  block_hash

  """
  Validator moniker
  """
  validator_moniker
}

enum BinanceBlockUniq {
  """
  Validator operators
  """
  validator_operator_addresses

  """
  Validator fee addresses
  """
  validator_fee_addresses

  """
  Unique date count
  """
  dates
}

"""
Coinpath
"""
type BinanceCoinpath {
  """
  Summary of transfered value
  """
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """
  Block where transaction is included
  """
  block: Block

  """
  Count of transfers
  """
  count: Int

  """
  Count of transfers
  """
  countBigInt: BigInt

  """
  Currency of transfer
  """
  currency: Currency

  """
  1-based hop depth of the graph
  """
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """
  Receiver address
  """
  receiver: BinanceCoinpathAddress

  """
  Sender address
  """
  sender: BinanceCoinpathAddress

  """
  Transaction of transfer happened
  """
  transaction: TransactionHashValueTime
}

"""
Address detailed information for Binance network
"""
type BinanceCoinpathAddress {
  """
  Address
  """
  address: String
  amountIn: DecimalNumber
  amountOut: DecimalNumber

  """
  Annotations ( tags ), if exists
  """
  annotation: String
  balance: DecimalNumber

  """
  Smart Contract if exists on the address
  """
  firstTxAt: DateTime

  """
  Smart Contract if exists on the address
  """
  lastTxAt: DateTime
  receiversCount: Int
  sendersCount: Int

  """
  Address type
  """
  type: String
}

"""
Binance token selector by tokenId.
    Native binance token has BNB symbol.
    Note that most Binance symbols has two dash separated parts, for example: 'TROY-9B8_BNB'
"""
input BinanceCurrencySelector {
  """
  Currency is
  """
  is: String

  """
  Currency not
  """
  not: String

  """
  Currency in the list
  """
  in: [String!]

  """
  Currency not in the list
  """
  notIn: [String!]
}

input BinanceOrderFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  orderOwner: [BinanceAddressSelector!]
  orderId: [OrderIdSelector!]
  baseCurrency: [BinanceCurrencySelector!]
  quoteCurrency: [BinanceCurrencySelector!]
  quoteAmount: [AmountSelector!]
  baseAmount: [AmountSelector!]
  price: [AmountSelector!]
  orderStatus: [OrderStatusSelector!]
  orderType: [OrderTypeSelector!]
  orderSide: [OrderSideSelector!]
  orderTimeInForce: [OrderTimeInForceSelector!]
}

"""
Binance DEX Order
"""
type BinanceOrders {
  any(of: BinanceOrdersMeasureable!): String
  baseAmount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    orderOwner: [BinanceAddressSelector!]
    orderId: [OrderIdSelector!]
    baseCurrency: [BinanceCurrencySelector!]
    quoteCurrency: [BinanceCurrencySelector!]
    quoteAmount: [AmountSelector!]
    baseAmount: [AmountSelector!]
    price: [AmountSelector!]
    orderStatus: [OrderStatusSelector!]
    orderType: [OrderTypeSelector!]
    orderSide: [OrderSideSelector!]
    orderTimeInForce: [OrderTimeInForceSelector!]
  ): Float
  baseCurrency(baseCurrency: [BinanceCurrencySelector!]): Currency

  """
  Block where order transaction is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(
    uniq: BinanceOrdersUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    orderOwner: [BinanceAddressSelector!]
    orderId: [OrderIdSelector!]
    baseCurrency: [BinanceCurrencySelector!]
    quoteCurrency: [BinanceCurrencySelector!]
    quoteAmount: [AmountSelector!]
    baseAmount: [AmountSelector!]
    price: [AmountSelector!]
    orderStatus: [OrderStatusSelector!]
    orderType: [OrderTypeSelector!]
    orderSide: [OrderSideSelector!]
    orderTimeInForce: [OrderTimeInForceSelector!]
  ): Int
  countBigInt(
    uniq: BinanceOrdersUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    orderOwner: [BinanceAddressSelector!]
    orderId: [OrderIdSelector!]
    baseCurrency: [BinanceCurrencySelector!]
    quoteCurrency: [BinanceCurrencySelector!]
    quoteAmount: [AmountSelector!]
    baseAmount: [AmountSelector!]
    price: [AmountSelector!]
    orderStatus: [OrderStatusSelector!]
    orderType: [OrderTypeSelector!]
    orderSide: [OrderSideSelector!]
    orderTimeInForce: [OrderTimeInForceSelector!]
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber
  maximum(of: BinanceOrdersMeasureable!, get: BinanceOrdersMeasureable): String
  minimum(of: BinanceOrdersMeasureable!, get: BinanceOrdersMeasureable): String

  """
  Order ID
  """
  orderId(orderId: [OrderIdSelector!]): String

  """
  Order owner address
  """
  orderOwner(owner: [BinanceAddressSelector!]): Address

  """
  Order Side
  """
  orderSide(orderSide: [OrderSideSelector!]): BinanceOrderSide

  """
  Order Status
  """
  orderStatus(orderStatus: [OrderStatusSelector!]): BinanceOrderStatus

  """
  Order Time In Force
  """
  orderTimeInForce(
    orderTimeInForce: [OrderTimeInForceSelector!]
  ): BinanceOrderTimeInForce

  """
  Order Type
  """
  orderType(orderType: [OrderTypeSelector!]): BinanceOrderType
  price: Float
  quoteAmount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    orderOwner: [BinanceAddressSelector!]
    orderId: [OrderIdSelector!]
    baseCurrency: [BinanceCurrencySelector!]
    quoteCurrency: [BinanceCurrencySelector!]
    quoteAmount: [AmountSelector!]
    baseAmount: [AmountSelector!]
    price: [AmountSelector!]
    orderStatus: [OrderStatusSelector!]
    orderType: [OrderTypeSelector!]
    orderSide: [OrderSideSelector!]
    orderTimeInForce: [OrderTimeInForceSelector!]
  ): Float
  quoteCurrency(quoteCurrency: [BinanceCurrencySelector!]): Currency

  """
  Transaction where order created
  """
  transaction(txHash: [HashSelector!]): TransactionHash
}

enum BinanceOrderSide {
  """
  Sell Side
  """
  sell

  """
  Buy Side
  """
  buy
}

enum BinanceOrdersMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Order owner
  """
  order_owner

  """
  Order status
  """
  order_status

  """
  Order ID
  """
  order_id

  """
  Order side
  """
  order_side

  """
  Base currency
  """
  base_currency

  """
  Quote currency
  """
  quote_currency

  """
  Quote Amount
  """
  quote_amount

  """
  Base Amount
  """
  base_amount

  """
  Price
  """
  price
}

enum BinanceOrderStatus {
  """
  Ack
  """
  Ack

  """
  Canceled
  """
  Canceled

  """
  Fully Fill
  """
  FullyFill

  """
  Partial Fill
  """
  PartialFill

  """
  Expired
  """
  Expired

  """
  Failed Blocking
  """
  FailedBlocking

  """
  Ioc No Fill
  """
  IocNoFill

  """
  Ioc Expire
  """
  IocExpire
}

enum BinanceOrdersUniq {
  """
  Unique Transactions
  """
  txs

  """
  Unique order owners
  """
  owners

  """
  Unique base currencies
  """
  base_currencies

  """
  Unique quote currencies
  """
  quote_currencies

  """
  Unique blocks
  """
  blocks

  """
  Unique date count
  """
  dates

  """
  Unique order ID count
  """
  orders
}

enum BinanceOrderTimeInForce {
  """
  Good Till Expiry
  """
  GTE

  """
  Immediate Or Cancel
  """
  IOC
}

enum BinanceOrderType {
  """
  Limit Order
  """
  LimitOrder
}

input BinanceTradeFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  buyer: [BinanceAddressSelector!]
  seller: [BinanceAddressSelector!]
  sellOrderId: [OrderIdSelector!]
  buyOrderId: [OrderIdSelector!]
  tradeId: [TradeIdSelector!]
  baseCurrency: [BinanceCurrencySelector!]
  quoteCurrency: [BinanceCurrencySelector!]
  quoteAmount: [AmountSelector!]
  baseAmount: [AmountSelector!]
  price: [AmountSelector!]
}

"""
Binance DEX Trades
"""
type BinanceTrades {
  any(of: BinanceTradesMeasureable!): String
  baseAmount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    buyer: [BinanceAddressSelector!]
    seller: [BinanceAddressSelector!]
    sellOrderId: [OrderIdSelector!]
    buyOrderId: [OrderIdSelector!]
    tradeId: [TradeIdSelector!]
    baseCurrency: [BinanceCurrencySelector!]
    quoteCurrency: [BinanceCurrencySelector!]
    quoteAmount: [AmountSelector!]
    baseAmount: [AmountSelector!]
    price: [AmountSelector!]
  ): Float
  baseCurrency(baseCurrency: [BinanceCurrencySelector!]): Currency

  """
  Block where trade transaction is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Buy Order ID
  """
  buyOrderId(buyOrderId: [OrderIdSelector!]): String

  """
  Trade buyer address
  """
  buyer(buyer: [BinanceAddressSelector!]): Address
  count(
    uniq: BinanceTradesUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    buyer: [BinanceAddressSelector!]
    seller: [BinanceAddressSelector!]
    sellOrderId: [OrderIdSelector!]
    buyOrderId: [OrderIdSelector!]
    tradeId: [TradeIdSelector!]
    baseCurrency: [BinanceCurrencySelector!]
    quoteCurrency: [BinanceCurrencySelector!]
    quoteAmount: [AmountSelector!]
    baseAmount: [AmountSelector!]
    price: [AmountSelector!]
  ): Int
  countBigInt(
    uniq: BinanceTradesUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    buyer: [BinanceAddressSelector!]
    seller: [BinanceAddressSelector!]
    sellOrderId: [OrderIdSelector!]
    buyOrderId: [OrderIdSelector!]
    tradeId: [TradeIdSelector!]
    baseCurrency: [BinanceCurrencySelector!]
    quoteCurrency: [BinanceCurrencySelector!]
    quoteAmount: [AmountSelector!]
    baseAmount: [AmountSelector!]
    price: [AmountSelector!]
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber
  maximum(of: BinanceTradesMeasureable!, get: BinanceTradesMeasureable): String
  minimum(of: BinanceTradesMeasureable!, get: BinanceTradesMeasureable): String
  price: Float
  quoteAmount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    buyer: [BinanceAddressSelector!]
    seller: [BinanceAddressSelector!]
    sellOrderId: [OrderIdSelector!]
    buyOrderId: [OrderIdSelector!]
    tradeId: [TradeIdSelector!]
    baseCurrency: [BinanceCurrencySelector!]
    quoteCurrency: [BinanceCurrencySelector!]
    quoteAmount: [AmountSelector!]
    baseAmount: [AmountSelector!]
    price: [AmountSelector!]
  ): Float
  quoteCurrency(quoteCurrency: [BinanceCurrencySelector!]): Currency

  """
  Sell Order ID
  """
  sellOrderId(sellOrderId: [OrderIdSelector!]): String

  """
  Trade seller address
  """
  seller(seller: [BinanceAddressSelector!]): Address

  """
  Trade ID
  """
  tradeId(tradeId: [TradeIdSelector!]): String

  """
  Transaction where trade happened
  """
  transaction(txHash: [HashSelector!]): TransactionHashIndex
}

enum BinanceTradesMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Buyer
  """
  buyer

  """
  Seller
  """
  seller

  """
  Trade ID
  """
  trade_id

  """
  Buy Order ID
  """
  buy_order_id

  """
  Sell Order ID
  """
  sell_order_id

  """
  Base currency
  """
  base_currency

  """
  Quote currency
  """
  quote_currency

  """
  Quote Amount
  """
  quote_amount

  """
  Base Amount
  """
  base_amount

  """
  Price
  """
  price
}

enum BinanceTradesUniq {
  """
  Trades
  """
  trades

  """
  Sell Orders
  """
  sell_orders

  """
  Buy Orders
  """
  buy_orders

  """
  Unique Transactions
  """
  txs

  """
  Unique buyers count
  """
  buyers

  """
  Unique sellers count
  """
  sellers

  """
  Unique base currencies
  """
  base_currencies

  """
  Unique quote currencies
  """
  quote_currencies

  """
  Unique blocks
  """
  blocks

  """
  Unique date count
  """
  dates
}

input BinanceTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  transactionType: BinanceTransactionTypeSelector
  proposalId: StringIdSelector
  currency: [BinanceCurrencySelector!]
  transactionCode: IntIdSelector
  transactionSource: IntIdSelector
  deposit: [AmountSelector!]
}

"""
Transaction
"""
type BinanceTransactions {
  any(of: BinanceTransactionsMeasureable!): String

  """
  Block where transaction is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(
    uniq: BinanceTransactionsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    transactionType: BinanceTransactionTypeSelector
    proposalId: StringIdSelector
    currency: [BinanceCurrencySelector!]
    transactionCode: IntIdSelector
    transactionSource: IntIdSelector
    deposit: [AmountSelector!]
  ): Int
  countBigInt(
    uniq: BinanceTransactionsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    transactionType: BinanceTransactionTypeSelector
    proposalId: StringIdSelector
    currency: [BinanceCurrencySelector!]
    transactionCode: IntIdSelector
    transactionSource: IntIdSelector
    deposit: [AmountSelector!]
  ): BigInt

  """
  Currency issued in transaction
  """
  currency(currency: [BinanceCurrencySelector!]): Currency

  """
  Calendar date
  """
  date: Date

  """
  Deposit amount in transaction
  """
  deposit(deposit: [AmountSelector!]): Float

  """
  Transaction Description
  """
  description: String
  expression(get: String!): DecimalNumber

  """
  Hash hex representation
  """
  hash(txHash: [HashSelector!]): String!

  """
  TX index in block, 0 based
  """
  index: Int

  """
  Transaction Log
  """
  log: String
  maximum(
    of: BinanceTransactionsMeasureable!
    get: BinanceTransactionsMeasureable
  ): String

  """
  Transaction Memo
  """
  memo: String
  minimum(
    of: BinanceTransactionsMeasureable!
    get: BinanceTransactionsMeasureable
  ): String

  """
  Proposal ID
  """
  proposalId(proposalId: [IntIdSelector!]): Int

  """
  Transaction Type
  """
  transactionCode(transactionCode: IntIdSelector): Int

  """
  Transaction Source
  """
  transactionSource(transactionSource: IntIdSelector): TransactionSource

  """
  Transaction Type
  """
  transactionType(
    transactionType: [BinanceTransactionTypeSelector!]
  ): BinanceTransactionType
}

enum BinanceTransactionsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Transaction Source Name
  """
  transaction_source_name

  """
  Transaction Source Code
  """
  transaction_source_code

  """
  Transaction Code
  """
  transaction_code

  """
  Transaction Type
  """
  transaction_type

  """
  Transaction Memo
  """
  transaction_memo

  """
  Currency
  """
  currency_symbol
}

enum BinanceTransactionsUniq {
  """
  Unique blocks
  """
  blocks

  """
  Unique date count
  """
  dates

  """
  Unique transaction source count
  """
  transaction_sources
}

enum BinanceTransactionType {
  """
  New Order
  """
  NEW_ORDER

  """
  Cancel Order
  """
  CANCEL_ORDER

  """
  Transfer
  """
  TRANSFER

  """
  Vote
  """
  VOTE

  """
  Unfreeze Token
  """
  UNFREEZE_TOKEN

  """
  Burn
  """
  BURN

  """
  Freeze Token
  """
  FREEZE_TOKEN

  """
  Submit Proposal
  """
  SUBMIT_PROPOSAL

  """
  Listing
  """
  LISTING

  """
  Issue
  """
  ISSUE

  """
  Deposit
  """
  DEPOSIT

  """
  Mint
  """
  MINT

  """
  Time Lock
  """
  TimeLock

  """
  Time Unlock
  """
  TimeUnlock

  """
  Time Relock
  """
  TimeRelock

  """
  Set Account Flag
  """
  SetAccountFlag

  """
  Hash Timer Locked Transfer
  """
  HTL_TRANSFER

  """
  Hash Timer Locked Deposit
  """
  DEPOSIT_HTL

  """
  Hash Timer Locked Claim
  """
  CLAIM_HTL

  """
  Hash Timer Locked  Refund
  """
  REFUND_HTL

  """
  Tiny Token Issue
  """
  TINY_TOKEN_ISSUE

  """
  Mini Token Issue
  """
  MINI_TOKEN_ISSUE

  """
  Tiny Token Listing
  """
  TINY_TOKEN_LIST

  """
  Mini Token Listing
  """
  MINI_TOKEN_LIST

  """
  Tiny Token Set URI
  """
  TINY_TOKEN_SET_URI

  """
  Mini Token Set URI
  """
  MINI_TOKEN_SET_URI

  """
  Create sidechain validator
  """
  CREATE_SIDECHAIN_VALIDATOR

  """
  Edit sidechain validator
  """
  EDIT_SIDECHAIN_VALIDATOR

  """
  Delegate for sidechain
  """
  SIDECHAIN_DELEGATE

  """
  ReDelegate for sidechain
  """
  SIDECHAIN_REDELEGATE

  """
  Unbond from sidechain
  """
  SIDECHAIN_UNBOND

  """
  Unjail from sidechain
  """
  SIDECHAIN_UNJAIL

  """
  Side chain submit poroposal
  """
  SIDE_SUBMIT_PROPOSAL

  """
  Side chain deposit
  """
  SIDE_DEPOSIT

  """
  Side chain vote
  """
  SIDE_VOTE

  """
  Cross chain transfer
  """
  TRANSFER_OUT

  """
  Submit evidence
  """
  BSC_SUBMIT_EVIDENCE

  """
  Cross chain claim
  """
  CLAIM

  """
  Bind
  """
  BIND

  """
  UnBind
  """
  UNBIND
}

"""
Select by transaction type
"""
input BinanceTransactionTypeSelector {
  """
  Transaction Type is
  """
  is: BinanceTransactionType

  """
  Transaction Type not
  """
  not: BinanceTransactionType

  """
  Transaction Type in the list
  """
  in: [BinanceTransactionType!]

  """
  Transaction Type not in the list
  """
  notIn: [BinanceTransactionType!]
}

input BinanceTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  sender: [BinanceAddressSelector!]
  receiver: [BinanceAddressSelector!]
  currency: [BinanceCurrencySelector!]
  transferType: [BinanceTransferTypeSelector!]
  orderId: [OrderIdSelector!]
  tradeId: [TradeIdSelector!]
  amount: [AmountSelector!]
  outputIndex: [OutputIndexSelector!]
}

"""
Currency transfers from/to addresses in crypto currencies
"""
type BinanceTransfers {
  """
  Transfer amount
  """
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    sender: [BinanceAddressSelector!]
    receiver: [BinanceAddressSelector!]
    currency: [BinanceCurrencySelector!]
    transferType: [BinanceTransferTypeSelector!]
    orderId: [OrderIdSelector!]
    tradeId: [TradeIdSelector!]
    amount: [AmountSelector!]
    outputIndex: [OutputIndexSelector!]
  ): Float
  any(of: BinanceTransfersMeasureable!): String

  """
  Block where transfer transaction is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Transfer count
  """
  count(
    uniq: TransfersUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    sender: [BinanceAddressSelector!]
    receiver: [BinanceAddressSelector!]
    currency: [BinanceCurrencySelector!]
    transferType: [BinanceTransferTypeSelector!]
    orderId: [OrderIdSelector!]
    tradeId: [TradeIdSelector!]
    amount: [AmountSelector!]
    outputIndex: [OutputIndexSelector!]
  ): Int

  """
  Transfer count
  """
  countBigInt(
    uniq: TransfersUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    sender: [BinanceAddressSelector!]
    receiver: [BinanceAddressSelector!]
    currency: [BinanceCurrencySelector!]
    transferType: [BinanceTransferTypeSelector!]
    orderId: [OrderIdSelector!]
    tradeId: [TradeIdSelector!]
    amount: [AmountSelector!]
    outputIndex: [OutputIndexSelector!]
  ): BigInt

  """
  Currency of transfer
  """
  currency(currency: [BinanceCurrencySelector!]): Currency

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber
  maximum(
    of: BinanceTransfersMeasureable!
    get: BinanceTransfersMeasureable
  ): String
  minimum(
    of: BinanceTransfersMeasureable!
    get: BinanceTransfersMeasureable
  ): String

  """
  Order Id of trade where transfer happened
  """
  orderId(orderId: [OrderIdSelector!]): String

  """
  Index of the output for the transfer, 0-based
  """
  outputIndex(outputIndex: [OutputIndexSelector!]): Int

  """
  Transfer receiver
  """
  receiver(receiver: [BinanceAddressSelector!]): Address

  """
  Transfer sender
  """
  sender(sender: [BinanceAddressSelector!]): Address

  """
  Id of trade where transfer happened
  """
  tradeId(tradeId: [TradeIdSelector!]): String

  """
  Transaction where transfer happened
  """
  transaction(txHash: [HashSelector!]): TransactionHashIndex

  """
  Transfer type
  """
  transferType(
    transferType: [BinanceTransferTypeSelector!]
  ): BinanceTransferType
}

enum BinanceTransfersMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Amount
  """
  amount

  """
  Sender
  """
  sender

  """
  Receiver
  """
  receiver

  """
  Currency symbol
  """
  currency_symbol
}

enum BinanceTransferType {
  """
  Reward for block
  """
  BLOCK_REWARD

  """
  Burning amount
  """
  BURN

  """
  Claiming Hash Timer Locked Transfer
  """
  CLAIM_HTL

  """
  Deposit for Hash Timer Locked Transfer
  """
  DEPOSIT_HTL

  """
  Fee for DEX orders
  """
  DEX_FEE

  """
  Genesis declaration
  """
  GENESIS_DELEGATION

  """
  Genesis supply declaration
  """
  GENESIS_SUPPLY

  """
  Tiny Token Issue
  """
  TINY_TOKEN_ISSUE

  """
  Mini Token Issue
  """
  MINI_TOKEN_ISSUE

  """
  Hash Timer Locked Transfer
  """
  HTL_TRANSFER

  """
  Issue token
  """
  ISSUE

  """
  Mint token
  """
  MINT

  """
  Trade buy side
  """
  TRADE_BUY

  """
  Trade sell side
  """
  TRADE_SELL

  """
  Transfer
  """
  TRANSFER

  """
  Transaction fee
  """
  TX_FEE

  """
  Create sidechain validator
  """
  CREATE_SIDECHAIN_VALIDATOR

  """
  Edit sidechain validator
  """
  EDIT_SIDECHAIN_VALIDATOR

  """
  Delegate for sidechain
  """
  SIDECHAIN_DELEGATE

  """
  ReDelegate for sidechain
  """
  SIDECHAIN_REDELEGATE

  """
  Unbond from sidechain
  """
  SIDECHAIN_UNBOND

  """
  Side chain submit poroposal
  """
  SIDE_SUBMIT_PROPOSAL

  """
  Side chain deposit
  """
  SIDE_DEPOSIT

  """
  Side chain vote
  """
  SIDE_VOTE

  """
  Cross chain transfer
  """
  TRANSFER_OUT

  """
  Submit evidence
  """
  BSC_SUBMIT_EVIDENCE

  """
  Cross chain claim
  """
  CLAIM

  """
  Bind
  """
  BIND

  """
  UnBind
  """
  UNBIND
}

"""
Select transfer type(s)
"""
input BinanceTransferTypeSelector {
  """
  Transfer type is
  """
  is: BinanceTransferType

  """
  Transfer type not
  """
  not: BinanceTransferType

  """
  Transfer type in the list
  """
  in: [BinanceTransferType!]

  """
  Transfer type not in the list
  """
  notIn: [BinanceTransferType!]
}

"""
Bitcoin and other UTXO type blockchains
"""
type Bitcoin {
  """
  Blockchain Address Statistics
  """
  addressStats(
    address: AddressSelector!
    options: QueryOptions
  ): [BitcoinAddressStats!]

  """
  Blockchain Blocks
  """
  blocks(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: StringIdSelector
    blockSize: IntegerSelector
    blockWeight: IntegerSelector
    blockVersion: IntegerSelector
    transactionCount: IntegerSelector
    blockStrippedSize: IntegerSelector
    difficulty: FloatSelector
    any: [BitcoinBlockFilter!]
    options: QueryOptions
  ): [BitcoinBlock!]

  """
  Money flow using Coinpath technology
  """
  coinpath(
    sender: AddressSelector
    receiver: AddressSelector
    initialAddress: AddressSelector
    initialDate: DateSelector
    initialTime: DateTimeSelector
    date: DateSelector
    time: DateTimeSelector
    depth: IntegerLimitedSelector
    options: BitcoinCoinpathOptions
  ): [BitcoinCoinpath!]

  """
  Blockchain Transaction Inputs
  """
  inputs(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    inputIndex: IntegerSelector
    inputAddress: AddressSelector
    inOutputTxId: HashSelector
    inOutputIndex: IntegerSelector
    inputScriptType: BitcoinInputScriptTypeSelector
    inputValue: FloatSelector
    any: [BitcoinInputFilter!]
    options: QueryOptions
  ): [BitcoinTransactionInput!]

  """
  Blockchain Transaction OmniTransactions
  """
  omniTransactions(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    version: IntegerSelector
    valid: IntegerSelector
    invalidReason: StringSelector
    type: StringSelector
    typeId: IntegerSelector
    txSender: HashSelector
    feeValue: FloatSelector
    any: [BitcoinOmniTransactionsFilter!]
    options: QueryOptions
  ): [BitcoinOmniTransactiosn!]

  """
  Blockchain Transaction OmniTransfers
  """
  omniTransfers(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    version: IntegerSelector
    valid: IntegerSelector
    invalidReason: StringSelector
    type: StringSelector
    typeId: IntegerSelector
    txSender: HashSelector
    feeValue: FloatSelector
    any: [BitcoinOmniTransfersFilter!]
    options: QueryOptions
  ): [BitcoinOmniTransfers!]

  """
  Blockchain Transaction Outputs
  """
  outputs(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    outputIndex: IntegerSelector
    outputAddress: AddressSelector
    outputScriptType: BitcoinOutputScriptTypeSelector
    outputDirection: BitcoinOutputDirectionSelector
    outputValue: FloatSelector
    any: [BitcoinOutputFilter!]
    options: QueryOptions
  ): [BitcoinTransactionOutput!]

  """
  Blockchain Transactions
  """
  transactions(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    txVsize: IntegerSelector
    txWeight: IntegerSelector
    txVersion: IntegerSelector
    txCoinbase: Boolean
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    minedValue: FloatSelector
    txLocktime: IntegerSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
    any: [BitcoinTransactionFilter!]
    options: QueryOptions
  ): [BitcoinTransaction!]
}

"""
AddressStat
"""
type BitcoinAddressStats {
  """
  Address With Statistics
  """
  address: AddressStatDimension
}

"""
Block
"""
type BitcoinBlock {
  any(of: BitcoinBlocksMeasureable!): String

  """
  Block Hash
  """
  blockHash(blockHash: StringIdSelector): String

  """
  Block size
  """
  blockSize(blockSize: IntegerSelector): Int

  """
  Block size
  """
  blockSizeBigInt: BigInt

  """
  Block stripped size
  """
  blockStrippedSize(blockStrippedSize: IntegerSelector): Int

  """
  Block version
  """
  blockVersion(blockVersion: IntegerSelector): Int

  """
  Block weight
  """
  blockWeight(blockWeight: IntegerSelector): Int

  """
  Block chainwork
  """
  chainwork: String
  count(
    uniq: BitcoinBlockUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: StringIdSelector
    blockSize: IntegerSelector
    blockWeight: IntegerSelector
    blockVersion: IntegerSelector
    txCount: IntegerSelector
    blockStrippedSize: IntegerSelector
    difficulty: FloatSelector
  ): Int
  countBigInt(
    uniq: BitcoinBlockUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: StringIdSelector
    blockSize: IntegerSelector
    blockWeight: IntegerSelector
    blockVersion: IntegerSelector
    txCount: IntegerSelector
    blockStrippedSize: IntegerSelector
    difficulty: FloatSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date

  """
  Difficulty
  """
  difficulty(difficulty: FloatSelector): Float
  expression(get: String!): DecimalNumber

  """
  Block number (height) in blockchain
  """
  height(height: BlockSelector): Int!
  maximum(of: BitcoinBlocksMeasureable!, get: BitcoinBlocksMeasureable): String

  """
  Block median timestamp
  """
  medianTime: DateTime
  minimum(of: BitcoinBlocksMeasureable!, get: BitcoinBlocksMeasureable): String

  """
  Block timestamp
  """
  timestamp(time: DateTimeSelector): DateTime

  """
  Transaction count in block
  """
  transactionCount(transactionCount: IntegerSelector): Int
}

input BitcoinBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: StringIdSelector
  blockSize: IntegerSelector
  blockWeight: IntegerSelector
  blockVersion: IntegerSelector
  transactionCount: IntegerSelector
  blockStrippedSize: IntegerSelector
  difficulty: FloatSelector
}

enum BitcoinBlocksMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Block hash
  """
  block_hash

  """
  Tx Count
  """
  transaction_count
}

enum BitcoinBlockUniq {
  """
  Unique date count
  """
  dates
}

"""
Coinpath
"""
type BitcoinCoinpath {
  """
  Summary of transfered value
  """
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """
  Block where transaction is included
  """
  block: Block

  """
  Count of transfers
  """
  count: Int

  """
  Count of transfers
  """
  countBigInt: BigInt

  """
  Currency of transfer
  """
  currency: Currency

  """
  1-based hop depth of the graph
  """
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """
  Receiver address
  """
  receiver: BitcoinCoinpathAddress

  """
  Sender address
  """
  sender: BitcoinCoinpathAddress

  """
  Transaction of transfer happened
  """
  transaction: BitcoinTransactionHashIndexValues

  """
  Attributes of transaction included in Coinpath result
  """
  transactions: [CoinpathEntry!]
}

"""
Address detailed information for Bitcoin network
"""
type BitcoinCoinpathAddress {
  """
  Address
  """
  address: String

  """
  Annotations ( tags ), if exists
  """
  annotation: String

  """
  Smart Contract if exists on the address
  """
  firstTxAt: DateTime

  """
  Smart Contract if exists on the address
  """
  lastTxAt: DateTime
  receiversCount: Int
  sendersCount: Int

  """
  Address type
  """
  type: String
}

enum BitcoinCoinpathMethod {
  """
  Tracking money flow by amounts, ignoring coins (default)
  """
  moneyflow

  """
  Tracking coins by UTXO transactions
  """
  utxo
}

"""
Limits, Ordering, Constraints, Coinpath Options
"""
input BitcoinCoinpathOptions {
  """
  Limit number of results
  """
  limit: Int

  """
  Limit number of results by specific field
  """
  limitBy: LimitByOption

  """
  Offset of results, starting from 0
  """
  offset: Int

  """
  Ordering field(s) for ascending
  """
  asc: [String!]

  """
  Ordering field(s) for descending
  """
  desc: [String!]

  """
  Converting field(s) to integer datatype and then ordering field(s) for descending
  """
  descByInteger: [String!]

  """
  Converting field(s) to integer datatype and then ordering field(s) for ascending
  """
  ascByInteger: [String!]

  """
  Flow direction
  """
  direction: FlowDirection

  """
  Do not include transactions below this amount
  """
  minimumTxAmount: Float

  """
  Do not expand addresses having count transactions more than this
  """
  maximumAddressTxCount: Int

  """
  Maximum total transaction count returned
  """
  maximumTotalTxCount: Int

  """
  Raise error if complexity ( currently measured in transaction count ) is higher than this option
  """
  complexityLimit: Int

  """
  Invalidating cache seed
  """
  seed: Int

  """
  Method to use coinpath
  """
  coinpathMethod: BitcoinCoinpathMethod
}

input BitcoinInputFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  inputIndex: IntegerSelector
  inputAddress: AddressSelector
  inOutputTxId: HashSelector
  inOutputIndex: IntegerSelector
  inputScriptType: BitcoinInputScriptTypeSelector
  inputValue: FloatSelector
}

enum BitcoinInputScriptType {
  """
  Input Script Signature
  """
  scriptSig

  """
  Input Script TX Witness Script
  """
  txinwitness

  """
  Input Script Coinbase Script
  """
  coinbase
}

"""
Selector of input script type
"""
input BitcoinInputScriptTypeSelector {
  """
  Equal to Script Type
  """
  is: BitcoinInputScriptType

  """
  Not Equal to Script Type
  """
  not: BitcoinInputScriptType

  """
  In the list of Script Type
  """
  in: [BitcoinInputScriptType!]

  """
  Not in the list of Script Type
  """
  notIn: [BitcoinInputScriptType!]
}

enum BitcoinInputsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Transaction index
  """
  tx_index

  """
  Amount
  """
  amount

  """
  Address
  """
  address

  """
  Input index
  """
  input_index
}

enum BitcoinInputUniq {
  """
  Unique transactions count
  """
  transactions

  """
  Unique block count
  """
  blocks

  """
  Unique date count
  """
  dates

  """
  Unique addresses count
  """
  addresses
}

enum BitcoinNetwork {
  """
  Bitcoin ( BTC )
  """
  bitcoin

  """
  Bitcoin Cash ( BCH )
  """
  bitcash

  """
  Bitcoin SV ( BSV )
  """
  bitcoinsv

  """
  Litecoin ( LTC )
  """
  litecoin

  """
  Dash ( DASH )
  """
  dash

  """
  Dogecoin ( DOGE )
  """
  dogecoin

  """
  ZCash ( ZCASH )
  """
  zcash
}

input BitcoinOmniTransactionsFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  version: IntegerSelector
  valid: IntegerSelector
  invalidReason: StringSelector
  type: StringSelector
  typeId: IntegerSelector
  txSender: HashSelector
  feeValue: FloatSelector
}

enum BitcoinOmniTransactionsMeasureablse {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transactions hash
  """
  tx_hash

  """
  Transactions index
  """
  tx_index

  """
  Fee Value
  """
  fee_value
}

enum BitcoinOmniTransactionsUniq {
  """
  Unique block count
  """
  blocks

  """
  Unique date count
  """
  dates

  """
  Unique transaction sender
  """
  tx_sender
}

"""
OmniTransactions
"""
type BitcoinOmniTransactiosn {
  any(of: BitcoinOmniTransactionsMeasureablse!): String

  """
  Block where transaction is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Hash of the block
  """
  blockHash(blockHash: HashSelector): String!

  """
  OmniTransaction s count
  """
  count(
    uniq: BitcoinOmniTransactionsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    version: IntegerSelector
    valid: IntegerSelector
    invalidReason: StringSelector
    type: StringSelector
    typeId: IntegerSelector
    txSender: HashSelector
    feeValue: FloatSelector
  ): Int

  """
  OmniTransaction s count
  """
  countBigInt(
    uniq: BitcoinOmniTransactionsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    version: IntegerSelector
    valid: IntegerSelector
    invalidReason: StringSelector
    type: StringSelector
    typeId: IntegerSelector
    txSender: HashSelector
    feeValue: FloatSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Transactions total fee value
  """
  feeValue(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    version: IntegerSelector
    valid: IntegerSelector
    invalidReason: StringSelector
    type: StringSelector
    typeId: IntegerSelector
    txSender: HashSelector
    feeValue: FloatSelector
  ): Float

  """
  Hash hex representation
  """
  hash(txHash: StringIdSelector): String!

  """
  OmniTransactions index in block, 0-based
  """
  index(txIndex: IntegerSelector): String!

  """
  Invalid Reason
  """
  invalidReason(invalidReason: StringSelector): String!

  """
  Invalid Reason
  """
  json(json: StringSelector): String!
  maximum(
    of: BitcoinOmniTransactionsMeasureablse!
    get: BitcoinOmniTransactionsMeasureablse
  ): String
  minimum(
    of: BitcoinOmniTransactionsMeasureablse!
    get: BitcoinOmniTransactionsMeasureablse
  ): String

  """
  Transaction Sender
  """
  txSender(txSender: HashSelector): String!

  """
  Type
  """
  type(type: StringSelector): String!

  """
  Type Int
  """
  typeInt(typeInt: IntegerSelector): Int!

  """
  Version
  """
  valid(valid: IntegerSelector): Int!

  """
  Version
  """
  version(version: IntegerSelector): Int!
}

"""
OmniTransfers
"""
type BitcoinOmniTransfers {
  any(of: BitcoinOmniTransfersMeasureablse!): String

  """
  Block where transaction is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Hash of the block
  """
  blockHash(blockHash: HashSelector): String!

  """
  Transaction s count
  """
  count(
    uniq: BitcoinOmniTransfersUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    version: IntegerSelector
    valid: IntegerSelector
    invalidReason: StringSelector
    type: StringSelector
    typeId: IntegerSelector
    txSender: HashSelector
    feeValue: FloatSelector
  ): Int

  """
  Transaction s count
  """
  countBigInt(
    uniq: BitcoinOmniTransfersUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    version: IntegerSelector
    valid: IntegerSelector
    invalidReason: StringSelector
    type: StringSelector
    typeId: IntegerSelector
    txSender: HashSelector
    feeValue: FloatSelector
  ): BigInt

  """
  Currency of transfer
  """
  currency: Currency

  """
  Calendar date
  """
  date: Date

  """
  Direction
  """
  direction(direction: StringSelector): String

  """
  Divisible
  """
  divisible(divisible: IntegerSelector): Int
  expression(get: String!): DecimalNumber

  """
  Transactions total fee value
  """
  feeValue(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    version: IntegerSelector
    valid: IntegerSelector
    invalidReason: StringSelector
    type: StringSelector
    typeId: IntegerSelector
    txSender: HashSelector
    feeValue: FloatSelector
  ): Float

  """
  Hash hex representation
  """
  hash(txHash: StringIdSelector): String!

  """
  Transactions index in block, 0-based
  """
  index(txIndex: IntegerSelector): String!

  """
  Ismine
  """
  ismine(ismine: IntegerSelector): Int
  maximum(
    of: BitcoinOmniTransfersMeasureablse!
    get: BitcoinOmniTransfersMeasureablse
  ): String
  minimum(
    of: BitcoinOmniTransfersMeasureablse!
    get: BitcoinOmniTransfersMeasureablse
  ): String

  """
  Transfer From
  """
  transferFrom(transferFrom: HashSelector): String!

  """
  Transfer From
  """
  transferTo(transferTo: HashSelector): String!

  """
  Transaction Sender
  """
  txSender(txSender: HashSelector): String!

  """
  Type
  """
  type(type: StringSelector): String!

  """
  Type Int
  """
  typeInt(typeInt: IntegerSelector): Int!

  """
  value
  """
  value(value: FloatSelector): Float
}

input BitcoinOmniTransfersFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  version: IntegerSelector
  valid: IntegerSelector
  invalidReason: StringSelector
  type: StringSelector
  typeId: IntegerSelector
  txSender: HashSelector
  feeValue: FloatSelector
}

enum BitcoinOmniTransfersMeasureablse {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transactions hash
  """
  tx_hash

  """
  Transactions index
  """
  tx_index

  """
  Fee Value
  """
  fee_value
}

enum BitcoinOmniTransfersUniq {
  """
  Unique block count
  """
  blocks

  """
  Unique date count
  """
  dates

  """
  Unique transaction sender
  """
  tx_sender
}

enum BitcoinOutputDirection {
  """
  Not defined
  """
  unknown

  """
  Not a change return
  """
  not_change

  """
  Change return
  """
  change

  """
  Likely Not a change return
  """
  likely_not_change

  """
  Likely Change return
  """
  likely_change

  """
  Mining
  """
  mining

  """
  Fee
  """
  fee

  """
  Minting
  """
  minting

  """
  Genesis
  """
  genesis
}

"""
A guessed direction of output
"""
input BitcoinOutputDirectionSelector {
  """
  Equal to direction
  """
  is: BitcoinOutputDirection

  """
  Not Equal to direction
  """
  not: BitcoinOutputDirection

  """
  In the list of direction
  """
  in: [BitcoinOutputDirection!]

  """
  Not in the list of direction
  """
  notIn: [BitcoinOutputDirection!]
}

input BitcoinOutputFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  outputIndex: IntegerSelector
  outputAddress: AddressSelector
  outputScriptType: BitcoinOutputScriptTypeSelector
  outputDirection: BitcoinOutputDirectionSelector
  outputValue: FloatSelector
}

enum BitcoinOutputScriptType {
  """
  Output PubKey
  """
  pubkey

  """
  Output PubKey Hash
  """
  pubkeyhash

  """
  Output Script Hash
  """
  scripthash

  """
  Output Witness Key Hash
  """
  witness_v0_keyhash

  """
  Output nulldata
  """
  nulldata

  """
  Output Witness Script Hash
  """
  witness_v0_scripthash

  """
  Non standard output script
  """
  nonstandard

  """
  Output Multisignature Wallet
  """
  multisig

  """
  Output Witness Other
  """
  witness_unknown
}

"""
Selector of output script type
"""
input BitcoinOutputScriptTypeSelector {
  """
  Equal to Script Type
  """
  is: BitcoinOutputScriptType

  """
  Not Equal to Script Type
  """
  not: BitcoinOutputScriptType

  """
  In the list of Script Type
  """
  in: [BitcoinOutputScriptType!]

  """
  Not in the list of Script Type
  """
  notIn: [BitcoinOutputScriptType!]
}

enum BitcoinOutputsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Transaction index
  """
  tx_index

  """
  Amount
  """
  amount

  """
  Address
  """
  address

  """
  Output index
  """
  output_index
}

enum BitcoinOutputUniq {
  """
  Unique transactions count
  """
  transactions

  """
  Unique block count
  """
  blocks

  """
  Unique date count
  """
  dates

  """
  Unique input addresses count
  """
  addresses
}

"""
Transaction
"""
type BitcoinTransaction {
  any(of: BitcoinTransactionsMeasureable!): String

  """
  Block where transaction is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Transaction  count
  """
  count(
    uniq: BitcoinTransactionUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    txVsize: IntegerSelector
    txWeight: IntegerSelector
    txVersion: IntegerSelector
    txCoinbase: Boolean
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    minedValue: FloatSelector
    txLocktime: IntegerSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): Int

  """
  Transaction  count
  """
  countBigInt(
    uniq: BitcoinTransactionUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    txVsize: IntegerSelector
    txWeight: IntegerSelector
    txVersion: IntegerSelector
    txCoinbase: Boolean
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    minedValue: FloatSelector
    txLocktime: IntegerSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Transaction total fee value
  """
  feeValue(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    txVsize: IntegerSelector
    txWeight: IntegerSelector
    txVersion: IntegerSelector
    txCoinbase: Boolean
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    minedValue: FloatSelector
    txLocktime: IntegerSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): Float

  """
  Transaction total fee value
  """
  feeValueDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    txVsize: IntegerSelector
    txWeight: IntegerSelector
    txVersion: IntegerSelector
    txCoinbase: Boolean
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    minedValue: FloatSelector
    txLocktime: IntegerSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): DecimalNumber

  """
  Hash hex representation
  """
  hash(txHash: StringIdSelector): String!

  """
  Transaction index in block, 0-based
  """
  index(txIndex: IntegerSelector): String!

  """
  Transaction total input count
  """
  inputCount(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    txVsize: IntegerSelector
    txWeight: IntegerSelector
    txVersion: IntegerSelector
    txCoinbase: Boolean
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    minedValue: FloatSelector
    txLocktime: IntegerSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): Int

  """
  Transaction total input count
  """
  inputCountBigInt(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    txVsize: IntegerSelector
    txWeight: IntegerSelector
    txVersion: IntegerSelector
    txCoinbase: Boolean
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    minedValue: FloatSelector
    txLocktime: IntegerSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): BigInt

  """
  Transaction total input value
  """
  inputValue(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    txVsize: IntegerSelector
    txWeight: IntegerSelector
    txVersion: IntegerSelector
    txCoinbase: Boolean
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    minedValue: FloatSelector
    txLocktime: IntegerSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): Float

  """
  Transaction total input value as decimal
  """
  inputValueDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    txVsize: IntegerSelector
    txWeight: IntegerSelector
    txVersion: IntegerSelector
    txCoinbase: Boolean
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    minedValue: FloatSelector
    txLocktime: IntegerSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): DecimalNumber
  maximum(
    of: BitcoinTransactionsMeasureable!
    get: BitcoinTransactionsMeasureable
  ): String

  """
  Transaction total mined value
  """
  minedValue(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    txVsize: IntegerSelector
    txWeight: IntegerSelector
    txVersion: IntegerSelector
    txCoinbase: Boolean
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    minedValue: FloatSelector
    txLocktime: IntegerSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): Float

  """
  Transaction total mined value
  """
  minedValueDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    txVsize: IntegerSelector
    txWeight: IntegerSelector
    txVersion: IntegerSelector
    txCoinbase: Boolean
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    minedValue: FloatSelector
    txLocktime: IntegerSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): DecimalNumber
  minimum(
    of: BitcoinTransactionsMeasureable!
    get: BitcoinTransactionsMeasureable
  ): String

  """
  Transaction total output count
  """
  outputCount(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    txVsize: IntegerSelector
    txWeight: IntegerSelector
    txVersion: IntegerSelector
    txCoinbase: Boolean
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    minedValue: FloatSelector
    txLocktime: IntegerSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): Int

  """
  Transaction total output count
  """
  outputCountBigInt(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    txVsize: IntegerSelector
    txWeight: IntegerSelector
    txVersion: IntegerSelector
    txCoinbase: Boolean
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    minedValue: FloatSelector
    txLocktime: IntegerSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): BigInt

  """
  Transaction total output value
  """
  outputValue(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    txVsize: IntegerSelector
    txWeight: IntegerSelector
    txVersion: IntegerSelector
    txCoinbase: Boolean
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    minedValue: FloatSelector
    txLocktime: IntegerSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): Float

  """
  Transaction total output value
  """
  outputValueDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    txVsize: IntegerSelector
    txWeight: IntegerSelector
    txVersion: IntegerSelector
    txCoinbase: Boolean
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    minedValue: FloatSelector
    txLocktime: IntegerSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): DecimalNumber

  """
  Transaction is coinbase
  """
  txCoinbase(txCoinbase: Boolean): Boolean

  """
  Transaction locktime
  """
  txLocktime(txLocktime: IntegerSelector): BigInt

  """
  Transaction size
  """
  txSize(txSize: IntegerSelector): Int

  """
  Transaction version
  """
  txVersion(txVersion: IntegerSelector): Int

  """
  Transaction vsize
  """
  txVsize(txVsize: IntegerSelector): Int

  """
  Transaction weight
  """
  txWeight(txWeight: IntegerSelector): Int
}

input BitcoinTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  txSize: IntegerSelector
  txVsize: IntegerSelector
  txWeight: IntegerSelector
  txVersion: IntegerSelector
  txCoinbase: Boolean
  inputCount: IntegerSelector
  outputCount: IntegerSelector
  inputValue: FloatSelector
  outputValue: FloatSelector
  feeValue: FloatSelector
  minedValue: FloatSelector
  txLocktime: IntegerSelector
  outputAddress: AddressSelectorIn
  inputAddress: AddressSelectorIn
}

"""
Blockchain transaction
"""
type BitcoinTransactionHashIndexValues {
  """
  Hash hex representation
  """
  hash: String!

  """
  Transaction index in block, 0-based
  """
  index: String!

  """
  Transaction value in input
  """
  valueIn: Float!

  """
  Transaction value in input
  """
  valueInDecimal: DecimalNumber!

  """
  Transaction value in output
  """
  valueOut: Float!

  """
  Transaction value in output
  """
  valueOutDecimal: DecimalNumber!
}

"""
Transaction Input
"""
type BitcoinTransactionInput {
  any(of: BitcoinInputsMeasureable!): String

  """
  Block where transaction is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Input count
  """
  count(
    uniq: BitcoinInputUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    inputIndex: IntegerSelector
    inputAddress: AddressSelector
    inOutputTxId: HashSelector
    inOutputIndex: IntegerSelector
    inputScriptType: BitcoinInputScriptTypeSelector
    inputValue: FloatSelector
  ): Int

  """
  Input count
  """
  countBigInt(
    uniq: BitcoinInputUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    inputIndex: IntegerSelector
    inputAddress: AddressSelector
    inOutputTxId: HashSelector
    inOutputIndex: IntegerSelector
    inputScriptType: BitcoinInputScriptTypeSelector
    inputValue: FloatSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Input address
  """
  inputAddress(inputAddress: AddressSelector): Address

  """
  Input index
  """
  inputIndex(inputIndex: IntegerSelector): Int

  """
  Input script
  """
  inputScript: String

  """
  Input script type and attributes
  """
  inputScriptType(inputScriptType: BitcoinInputScriptTypeSelector): InputScript
  maximum(of: BitcoinInputsMeasureable!, get: BitcoinInputsMeasureable): String
  minimum(of: BitcoinInputsMeasureable!, get: BitcoinInputsMeasureable): String

  """
  Output Transaction for this input
  """
  outputTransaction(
    inOutputTxId: StringIdSelector
    inOutputIndex: IntegerSelector
  ): TransactionHashIndex

  """
  Transaction ID Hash
  """
  transaction(
    txId: StringIdSelector
    txIndex: IntegerSelector
  ): TransactionHashIndex

  """
  Input value
  """
  value(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    inputIndex: IntegerSelector
    inputAddress: AddressSelector
    inOutputTxId: HashSelector
    inOutputIndex: IntegerSelector
    inputScriptType: BitcoinInputScriptTypeSelector
    inputValue: FloatSelector
  ): Float

  """
  Input value as decimal
  """
  valueDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    inputIndex: IntegerSelector
    inputAddress: AddressSelector
    inOutputTxId: HashSelector
    inOutputIndex: IntegerSelector
    inputScriptType: BitcoinInputScriptTypeSelector
    inputValue: FloatSelector
  ): DecimalNumber
}

"""
Transaction Output
"""
type BitcoinTransactionOutput {
  any(of: BitcoinOutputsMeasureable!): String

  """
  Block where transaction is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Output count
  """
  count(
    uniq: BitcoinOutputUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    outputIndex: IntegerSelector
    outputAddress: AddressSelector
    outputScriptType: BitcoinOutputScriptTypeSelector
    outputDirection: BitcoinOutputDirectionSelector
    outputValue: FloatSelector
  ): Int

  """
  Output count
  """
  countBigInt(
    uniq: BitcoinOutputUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    outputIndex: IntegerSelector
    outputAddress: AddressSelector
    outputScriptType: BitcoinOutputScriptTypeSelector
    outputDirection: BitcoinOutputDirectionSelector
    outputValue: FloatSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber
  maximum(
    of: BitcoinOutputsMeasureable!
    get: BitcoinOutputsMeasureable
  ): String
  minimum(
    of: BitcoinOutputsMeasureable!
    get: BitcoinOutputsMeasureable
  ): String

  """
  Output address
  """
  outputAddress(outputAddress: AddressSelector): Address

  """
  Output guessed direction
  """
  outputDirection(
    outputDirection: BitcoinOutputDirectionSelector
  ): BitcoinOutputDirection

  """
  Output index
  """
  outputIndex(outputIndex: IntegerSelector): Int

  """
  Output script
  """
  outputScript: String

  """
  Output script type and attributes
  """
  outputScriptType(
    inputScriptType: BitcoinOutputScriptTypeSelector
  ): OutputScript
  reqSigs: Int

  """
  Transaction ID Hash
  """
  transaction(
    txId: StringIdSelector
    txIndex: IntegerSelector
  ): TransactionHashIndex

  """
  Output value
  """
  value(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    outputIndex: IntegerSelector
    outputAddress: AddressSelector
    outputScriptType: BitcoinOutputScriptTypeSelector
    outputDirection: BitcoinOutputDirectionSelector
    outputValue: FloatSelector
  ): Float

  """
  Output value as decimal
  """
  valueDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    inputIndex: IntegerSelector
    inputAddress: AddressSelector
    inOutputTxId: HashSelector
    inOutputIndex: IntegerSelector
    inputScriptType: BitcoinInputScriptTypeSelector
    inputValue: FloatSelector
  ): DecimalNumber
}

enum BitcoinTransactionsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Transaction index
  """
  tx_index

  """
  Input count
  """
  input_count

  """
  Output count
  """
  output_count

  """
  Transaction size
  """
  tx_size

  """
  Transaction input value
  """
  input_value

  """
  Transaction output value
  """
  output_value

  """
  Fee Value
  """
  fee_value
}

enum BitcoinTransactionUniq {
  """
  Unique block count
  """
  blocks

  """
  Unique date count
  """
  dates
}

"""
Block
"""
type Block {
  """
  Block number (height) in blockchain
  """
  height: Int!

  """
  Block timestamp
  """
  timestamp: DateTime
}

"""
Blockchain network
"""
type BlockchainNetwork {
  """
  Network name
  """
  network: Network!

  """
  Network protocol type
  """
  protocol: Protocol!
}

"""
BlockExtended
"""
type BlockExtended {
  """
  Hash hex representation
  """
  hash: String!

  """
  Block number (height) in blockchain
  """
  height: Int!

  """
  Block timestamp
  """
  timestamp: DateTime
}

"""
ConfluxBlock
"""
type BlockInfo {
  """
  Block hash
  """
  hash: String

  """
  Block number (height) in blockchain
  """
  height: Int!

  """
  Block timestamp
  """
  timestamp: DateTime
}

"""
Select block by height ( sequence number)
"""
input BlockSelector {
  """
  Block height is
  """
  is: Int

  """
  Block height not
  """
  not: Int

  """
  Block height in the list
  """
  in: [Int!]

  """
  Block height not in the list
  """
  notIn: [Int!]

  """
  Block height greater than
  """
  gt: Int

  """
  Block height less than
  """
  lt: Int

  """
  Block height less or equal than
  """
  lteq: Int

  """
  Block height greater or equal than
  """
  gteq: Int

  """
  Block height in range
  """
  between: [Int!]
}

"""
Select block by height ( sequence number)
"""
input BlockSelectorRange {
  """
  Block height eq
  """
  is: Int

  """
  Block height less than
  """
  lt: Int

  """
  Block height less or equal than
  """
  lteq: Int

  """
  Block height greater than
  """
  gt: Int

  """
  Block height greater or equal than
  """
  gteq: Int

  """
  Block height in range
  """
  between: [Int!]
}

"""
Select by boolean (sequence number)
"""
input BooleanSelector {
  """
  Is
  """
  is: Boolean

  """
  Is not
  """
  not: Boolean
}

"""
Cardano
"""
type Cardano {
  """
  Information about address
  """
  address(address: [AddressSelectorIn!]!): [CardanoAddressInfo!]!

  """
  Blockchain Address Statistics
  """
  addressStats(
    address: AddressSelector!
    options: QueryOptions
  ): [CardanoAddressStats!]

  """
  Blockchain Blocks
  """
  blocks(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: StringIdSelector
    blockSize: IntegerSelector
    blockVersion: IntegerSelector
    transactionCount: IntegerSelector
    epoch: IntegerSelector
    slot: IntegerSelector
    slotInEpoch: IntegerSelector
    opCert: StringSelector
    slotLeaderHash: StringSelector
    vrfKey: StringSelector
    version: StringSelector
    any: [CardanoBlockFilter!]
    options: QueryOptions
  ): [CardanoBlock!]

  """
  Money flow using Coinpath technology
  """
  coinpath(
    sender: AddressSelector
    receiver: AddressSelector
    initialAddress: AddressSelector
    initialDate: DateSelector
    initialTime: DateTimeSelector
    date: DateSelector
    time: DateTimeSelector
    depth: IntegerLimitedSelector
    currency: [CardanoCurrencySelector!]
    options: CardanoCoinpathOptions
  ): [CardanoCoinpath!]

  """
  Blockchain Transaction Inputs
  """
  inputs(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    inputIndex: IntegerSelector
    inputAddress: AddressSelector
    inOutputTxId: HashSelector
    inOutputIndex: IntegerSelector
    inputValue: FloatSelector
    currency: [CardanoCurrencySelector!]
    inputSource: CardanoInputSourcenSelector
    any: [CardanoInputFilter!]
    options: QueryOptions
  ): [CardanoTransactionInput!]

  """
  Blockchain Tokens Mints
  """
  mints(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    value: FloatSelector
    currency: [CardanoCurrencySelector!]
    any: [CardanoMintFilter!]
    options: QueryOptions
  ): [CardanoTransactionMint!]

  """
  Blockchain Transaction Outputs
  """
  outputs(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    outputIndex: IntegerSelector
    outputAddress: AddressSelector
    outputDirection: CardanoOutputDirectionSelector
    outputValue: FloatSelector
    currency: [CardanoCurrencySelector!]
    any: [CardanoOutputFilter!]
    options: QueryOptions
  ): [CardanoTransactionOutput!]

  """
  Blockchain Transactions
  """
  transactions(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    withdrawalCount: IntegerSelector
    mintCount: IntegerSelector
    withdrawalValue: FloatSelector
    depositValue: FloatSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
    any: [CardanoTransactionFilter!]
    options: QueryOptions
  ): [CardanoTransaction!]
}

"""
Address balance information for Cardano network
"""
type CardanoAddressBalance {
  """
  Currency
  """
  currency: Currency

  """
  Currency value
  """
  value: Float
}

"""
Address detailed information for Cardano network
"""
type CardanoAddressInfo {
  """
  Address
  """
  address: Address

  """
  Current address balances
  """
  balance: [CardanoAddressBalance!]

  """
  Current staking addressese info
  """
  staking: [CardanoStakingAddress!]
}

"""
AddressStat
"""
type CardanoAddressStats {
  """
  Address With Statistics
  """
  address: AddressStatDimension
}

"""
Block
"""
type CardanoBlock {
  any(of: CardanoBlocksMeasureable!): String

  """
  Block Hash
  """
  blockHash(blockHash: StringIdSelector): String

  """
  Block size
  """
  blockSize(blockSize: IntegerSelector): Int

  """
  Block version
  """
  blockVersion(blockVersion: IntegerSelector): Int
  count(
    uniq: CardanoBlockUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: StringIdSelector
    blockSize: IntegerSelector
    blockWeight: IntegerSelector
    blockVersion: IntegerSelector
    txCount: IntegerSelector
    blockStrippedSize: IntegerSelector
    difficulty: FloatSelector
  ): Int
  countBigInt(
    uniq: CardanoBlockUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: StringIdSelector
    blockSize: IntegerSelector
    blockWeight: IntegerSelector
    blockVersion: IntegerSelector
    txCount: IntegerSelector
    blockStrippedSize: IntegerSelector
    difficulty: FloatSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date

  """
  Epoch number
  """
  epoch: Int
  expression(get: String!): DecimalNumber

  """
  Block number (height) in blockchain
  """
  height(height: BlockSelector): Int!
  maximum(of: CardanoBlocksMeasureable!, get: CardanoBlocksMeasureable): String
  minimum(of: CardanoBlocksMeasureable!, get: CardanoBlocksMeasureable): String

  """
  Op cert
  """
  opCert: String

  """
  Slot number
  """
  slot: Int

  """
  Slot in epoch number
  """
  slotInEpoch: Int

  """
  Slot leader description
  """
  slotLeaderDescription: String

  """
  Slot leader hash
  """
  slotLeaderHash: String

  """
  Block timestamp
  """
  timestamp(time: DateTimeSelector): DateTime

  """
  Transaction count in block
  """
  transactionCount(transactionCount: IntegerSelector): Int

  """
  VRF Key
  """
  vrfKey: String
}

input CardanoBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: StringIdSelector
  blockSize: IntegerSelector
  blockVersion: IntegerSelector
  transactionCount: IntegerSelector
  epoch: IntegerSelector
  slot: IntegerSelector
  slotInEpoch: IntegerSelector
  opCert: StringSelector
  slotLeaderHash: StringSelector
  vrfKey: StringSelector
  version: StringSelector
}

enum CardanoBlocksMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Block hash
  """
  block_hash

  """
  Tx Count
  """
  transaction_count
}

enum CardanoBlockUniq {
  """
  Unique date count
  """
  dates

  """
  Unique epoch
  """
  epoch

  """
  Unique slot
  """
  slot

  """
  Unique slot leader
  """
  slot_leader

  """
  Unique version
  """
  version
}

"""
Coinpath
"""
type CardanoCoinpath {
  """
  Summary of transfered value
  """
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """
  Block where transaction is included
  """
  block: Block

  """
  Count of transfers
  """
  count: Int

  """
  Count of transfers
  """
  countBigInt: BigInt

  """
  Currency of transfer
  """
  currency: Currency

  """
  1-based hop depth of the graph
  """
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """
  Receiver address
  """
  receiver: CardanoCoinpathAddress

  """
  Sender address
  """
  sender: CardanoCoinpathAddress

  """
  Transaction of transfer happened
  """
  transaction: CardanoTransactionHashIndexValues

  """
  Attributes of transaction included in Coinpath result
  """
  transactions: [CoinpathEntry!]
}

"""
Address detailed information for Cardano network
"""
type CardanoCoinpathAddress {
  """
  Address
  """
  address: String

  """
  Annotations ( tags ), if exists
  """
  annotation: String

  """
  Smart Contract if exists on the address
  """
  firstTxAt: DateTime

  """
  Smart Contract if exists on the address
  """
  lastTxAt: DateTime
  receiversCount: Int
  sendersCount: Int

  """
  Address type
  """
  type: String
}

enum CardanoCoinpathMethod {
  """
  Tracking money flow by amounts, ignoring coins (default)
  """
  moneyflow

  """
  Tracking coins by UTXO transactions
  """
  utxo
}

"""
Limits, Ordering, Constraints, Coinpath Options
"""
input CardanoCoinpathOptions {
  """
  Limit number of results
  """
  limit: Int

  """
  Limit number of results by specific field
  """
  limitBy: LimitByOption

  """
  Offset of results, starting from 0
  """
  offset: Int

  """
  Ordering field(s) for ascending
  """
  asc: [String!]

  """
  Ordering field(s) for descending
  """
  desc: [String!]

  """
  Converting field(s) to integer datatype and then ordering field(s) for descending
  """
  descByInteger: [String!]

  """
  Converting field(s) to integer datatype and then ordering field(s) for ascending
  """
  ascByInteger: [String!]

  """
  Flow direction
  """
  direction: FlowDirection

  """
  Do not include transactions below this amount
  """
  minimumTxAmount: Float

  """
  Do not expand addresses having count transactions more than this
  """
  maximumAddressTxCount: Int

  """
  Maximum total transaction count returned
  """
  maximumTotalTxCount: Int

  """
  Raise error if complexity ( currently measured in transaction count ) is higher than this option
  """
  complexityLimit: Int

  """
  Invalidating cache seed
  """
  seed: Int

  """
  Method to use coinpath
  """
  coinpathMethod: CardanoCoinpathMethod

  """
  Option to get info for staking addresses
  """
  stakingAddress: Boolean
}

"""
Cardano token selector by tokenId.
    Native binance token has ADA symbol, pass it as argument.
    Otherwise pass asset fingerprint, starting from asset...
"""
input CardanoCurrencySelector {
  """
  Currency is
  """
  is: String

  """
  Currency not
  """
  not: String

  """
  Currency in the list
  """
  in: [String!]

  """
  Currency not in the list
  """
  notIn: [String!]
}

input CardanoInputFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  inputIndex: IntegerSelector
  inputAddress: AddressSelector
  inOutputTxId: HashSelector
  inOutputIndex: IntegerSelector
  inputValue: FloatSelector
  currency: [CardanoCurrencySelector!]
  inputSource: CardanoInputSourcenSelector
}

enum CardanoInputsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Transaction index
  """
  tx_index

  """
  Amount
  """
  amount

  """
  Address
  """
  address

  """
  Input index
  """
  input_index

  """
  Input source
  """
  source
}

enum CardanoInputSource {
  """
  Input
  """
  input

  """
  Withdrawal
  """
  withdrawal

  """
  Stake Deregistration
  """
  stake_deregistration
}

"""
A source input
"""
input CardanoInputSourcenSelector {
  """
  Equal to source
  """
  is: CardanoInputSource

  """
  Not Equal to source
  """
  not: CardanoInputSource

  """
  In the list of source
  """
  in: [CardanoInputSource!]

  """
  Not in the list of source
  """
  notIn: [CardanoInputSource!]
}

enum CardanoInputUniq {
  """
  Unique transactions count
  """
  transactions

  """
  Unique block count
  """
  blocks

  """
  Unique date count
  """
  dates

  """
  Unique addresses count
  """
  addresses

  """
  Unique currencies count
  """
  currencies

  """
  Unique source count
  """
  sources
}

input CardanoMintFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  value: FloatSelector
  currency: [CardanoCurrencySelector!]
}

enum CardanoMintsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Transaction index
  """
  tx_index

  """
  Amount
  """
  amount
}

enum CardanoMintUniq {
  """
  Unique transactions count
  """
  transactions

  """
  Unique block count
  """
  blocks

  """
  Unique date count
  """
  dates

  """
  Unique currencies count
  """
  currencies
}

enum CardanoNetwork {
  """
  Cardano ( ADA )
  """
  cardano
}

enum CardanoOutputDirection {
  """
  Not defined
  """
  unknown

  """
  Not a change return
  """
  not_change

  """
  Change return
  """
  change

  """
  Genesis
  """
  genesis

  """
  Stake Registration
  """
  stake_registration

  """
  Stake Registration
  """
  deposit
}

"""
A guessed direction of output
"""
input CardanoOutputDirectionSelector {
  """
  Equal to direction
  """
  is: CardanoOutputDirection

  """
  Not Equal to direction
  """
  not: CardanoOutputDirection

  """
  In the list of direction
  """
  in: [CardanoOutputDirection!]

  """
  Not in the list of direction
  """
  notIn: [CardanoOutputDirection!]
}

input CardanoOutputFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  outputIndex: IntegerSelector
  outputAddress: AddressSelector
  outputDirection: CardanoOutputDirectionSelector
  outputValue: FloatSelector
  currency: [CardanoCurrencySelector!]
}

enum CardanoOutputsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Transaction index
  """
  tx_index

  """
  Amount
  """
  amount

  """
  Address
  """
  address

  """
  Output index
  """
  output_index

  """
  Output direction
  """
  direction
}

enum CardanoOutputUniq {
  """
  Unique transactions count
  """
  transactions

  """
  Unique block count
  """
  blocks

  """
  Unique date count
  """
  dates

  """
  Unique input addresses count
  """
  addresses

  """
  Unique currencies count
  """
  currencies

  """
  Unique direction count
  """
  directions
}

"""
Address staking information for Cardano network
"""
type CardanoStakingAddress {
  """
  Staking Address
  """
  address: Address

  """
  Controlled total stake
  """
  controlledTotalStake: Float

  """
  Rewards value
  """
  rewardsAmount: Float

  """
  Rewards available
  """
  rewardsAvailable: Float

  """
  Staked value
  """
  stakedAmount: Float

  """
  Staked value including rewards
  """
  stakedAmountWithRewards: Float

  """
  Withdrawn value
  """
  withdrawnAmount: Float
}

"""
Transaction
"""
type CardanoTransaction {
  any(of: CardanoTransactionsMeasureable!): String

  """
  Block where transaction is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Transaction  count
  """
  count(
    uniq: CardanoTransactionUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    withdrawalCount: IntegerSelector
    mintCount: IntegerSelector
    withdrawalValue: FloatSelector
    depositValue: FloatSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): Int

  """
  Transaction  count
  """
  countBigInt(
    uniq: CardanoTransactionUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    withdrawalCount: IntegerSelector
    mintCount: IntegerSelector
    withdrawalValue: FloatSelector
    depositValue: FloatSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): BigInt

  """
  Calendar date
  """
  date: Date

  """
  Transaction total deposit value
  """
  depositValue(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    withdrawalCount: IntegerSelector
    mintCount: IntegerSelector
    withdrawalValue: FloatSelector
    depositValue: FloatSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): Float

  """
  Transaction total fee value
  """
  depositValueDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    withdrawalCount: IntegerSelector
    mintCount: IntegerSelector
    withdrawalValue: FloatSelector
    depositValue: FloatSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): DecimalNumberAsDiv
  expression(get: String!): DecimalNumber

  """
  Transaction total fee value
  """
  feeValue(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    withdrawalCount: IntegerSelector
    mintCount: IntegerSelector
    withdrawalValue: FloatSelector
    depositValue: FloatSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): Float

  """
  Transaction total fee value
  """
  feeValueDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    withdrawalCount: IntegerSelector
    mintCount: IntegerSelector
    withdrawalValue: FloatSelector
    depositValue: FloatSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): DecimalNumberAsDiv

  """
  Hash hex representation
  """
  hash(txHash: StringIdSelector): String!

  """
  Included at timestamp
  """
  includedAt: DateTime

  """
  Transaction index in block, 0-based
  """
  index(txIndex: IntegerSelector): String!

  """
  Transaction total input count
  """
  inputCount(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    withdrawalCount: IntegerSelector
    mintCount: IntegerSelector
    withdrawalValue: FloatSelector
    depositValue: FloatSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): Int

  """
  Transaction total input count
  """
  inputCountBigInt(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    withdrawalCount: IntegerSelector
    mintCount: IntegerSelector
    withdrawalValue: FloatSelector
    depositValue: FloatSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): BigInt

  """
  Transaction total input value
  """
  inputValue(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    withdrawalCount: IntegerSelector
    mintCount: IntegerSelector
    withdrawalValue: FloatSelector
    depositValue: FloatSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): Float

  """
  Transaction total input value as decimal
  """
  inputValueDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    withdrawalCount: IntegerSelector
    mintCount: IntegerSelector
    withdrawalValue: FloatSelector
    depositValue: FloatSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): DecimalNumberAsDiv

  """
  Invalid before
  """
  invalidBefore: String

  """
  Invalid hereafter
  """
  invalidHereafter: String
  maximum(
    of: CardanoTransactionsMeasureable!
    get: CardanoTransactionsMeasureable
  ): String

  """
  Metadata
  """
  metadata: String
  minimum(
    of: CardanoTransactionsMeasureable!
    get: CardanoTransactionsMeasureable
  ): String

  """
  Transaction total mint count
  """
  mintCount(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    withdrawalCount: IntegerSelector
    mintCount: IntegerSelector
    withdrawalValue: FloatSelector
    depositValue: FloatSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): Int

  """
  Transaction total mint count
  """
  mintCountBigInt(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    withdrawalCount: IntegerSelector
    mintCount: IntegerSelector
    withdrawalValue: FloatSelector
    depositValue: FloatSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): BigInt

  """
  Transaction total output count
  """
  outputCount(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    withdrawalCount: IntegerSelector
    mintCount: IntegerSelector
    withdrawalValue: FloatSelector
    depositValue: FloatSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): Int

  """
  Transaction total output count
  """
  outputCountBigInt(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    withdrawalCount: IntegerSelector
    mintCount: IntegerSelector
    withdrawalValue: FloatSelector
    depositValue: FloatSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): BigInt

  """
  Transaction total output value
  """
  outputValue(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    withdrawalCount: IntegerSelector
    mintCount: IntegerSelector
    withdrawalValue: FloatSelector
    depositValue: FloatSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): Float

  """
  Transaction total output value
  """
  outputValueDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    withdrawalCount: IntegerSelector
    mintCount: IntegerSelector
    withdrawalValue: FloatSelector
    depositValue: FloatSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): DecimalNumberAsDiv

  """
  Transaction size
  """
  txSize(txSize: IntegerSelector): Int

  """
  Transaction total withdrawal count
  """
  withdrawalCount(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    withdrawalCount: IntegerSelector
    mintCount: IntegerSelector
    withdrawalValue: FloatSelector
    depositValue: FloatSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): Int

  """
  Transaction total withdrawal count
  """
  withdrawalCountBigInt(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    withdrawalCount: IntegerSelector
    mintCount: IntegerSelector
    withdrawalValue: FloatSelector
    depositValue: FloatSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): BigInt

  """
  Transaction total withdrawal value
  """
  withdrawalValue(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    withdrawalCount: IntegerSelector
    mintCount: IntegerSelector
    withdrawalValue: FloatSelector
    depositValue: FloatSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): Float

  """
  Transaction total fee value
  """
  withdrawalValueDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    inputCount: IntegerSelector
    outputCount: IntegerSelector
    inputValue: FloatSelector
    outputValue: FloatSelector
    feeValue: FloatSelector
    withdrawalCount: IntegerSelector
    mintCount: IntegerSelector
    withdrawalValue: FloatSelector
    depositValue: FloatSelector
    outputAddress: AddressSelectorIn
    inputAddress: AddressSelectorIn
  ): DecimalNumberAsDiv
}

input CardanoTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  txSize: IntegerSelector
  inputCount: IntegerSelector
  outputCount: IntegerSelector
  inputValue: FloatSelector
  outputValue: FloatSelector
  feeValue: FloatSelector
  withdrawalCount: IntegerSelector
  mintCount: IntegerSelector
  withdrawalValue: FloatSelector
  depositValue: FloatSelector
  outputAddress: AddressSelectorIn
  inputAddress: AddressSelectorIn
}

"""
Blockchain transaction
"""
type CardanoTransactionHashIndexValues {
  depositValue: Float!

  """
  Transaction deposit value as decimal
  """
  depositValueDecimal: DecimalNumberAsDiv!
  feeValue: Float!

  """
  Transaction fee value as decimal
  """
  feeValueDecimal: DecimalNumberAsDiv!

  """
  Hash hex representation
  """
  hash: String!
  includedAt: DateTime!

  """
  Transaction index in block, 0-based
  """
  index: String!
  invalidBefore: String!
  invalidHereafter: String!
  metadata: String!
  txSize: Int!

  """
  Transaction value in input
  """
  valueIn: Float!

  """
  Transaction value in input as decimal
  """
  valueInDecimal: DecimalNumberAsDiv!

  """
  Transaction value in output
  """
  valueOut: Float!

  """
  Transaction value in output as decimal
  """
  valueOutDecimal: DecimalNumberAsDiv!
  withdrawalValue: Float!

  """
  Transaction withdraw value as decimal
  """
  withdrawalValueDecimal: DecimalNumberAsDiv!
}

"""
Transaction Input
"""
type CardanoTransactionInput {
  any(of: CardanoInputsMeasureable!): String

  """
  Block where transaction is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Input count
  """
  count(
    uniq: CardanoInputUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    inputIndex: IntegerSelector
    inputAddress: AddressSelector
    inOutputTxId: HashSelector
    inOutputIndex: IntegerSelector
    inputValue: FloatSelector
    currency: [CardanoCurrencySelector!]
    inputSource: CardanoInputSourcenSelector
  ): Int

  """
  Input count
  """
  countBigInt(
    uniq: CardanoInputUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    inputIndex: IntegerSelector
    inputAddress: AddressSelector
    inOutputTxId: HashSelector
    inOutputIndex: IntegerSelector
    inputValue: FloatSelector
    currency: [CardanoCurrencySelector!]
    inputSource: CardanoInputSourcenSelector
  ): BigInt

  """
  Currency of the input
  """
  currency: Currency

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Input address
  """
  inputAddress(inputAddress: AddressSelector): Address

  """
  Input index
  """
  inputIndex(inputIndex: IntegerSelector): Int
  maximum(of: CardanoInputsMeasureable!, get: CardanoInputsMeasureable): String
  minimum(of: CardanoInputsMeasureable!, get: CardanoInputsMeasureable): String

  """
  Output Transaction for this input
  """
  outputTransaction(
    inOutputTxId: StringIdSelector
    inOutputIndex: IntegerSelector
  ): TransactionHashIndex

  """
  Source of the input
  """
  source: CardanoInputSource

  """
  Transaction ID Hash
  """
  transaction(
    txId: StringIdSelector
    txIndex: IntegerSelector
  ): TransactionHashIndex

  """
  Input value
  """
  value(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    inputIndex: IntegerSelector
    inputAddress: AddressSelector
    inOutputTxId: HashSelector
    inOutputIndex: IntegerSelector
    inputValue: FloatSelector
    currency: [CardanoCurrencySelector!]
    inputSource: CardanoInputSourcenSelector
  ): Float

  """
  Input value as decimal
  """
  valueDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    inputIndex: IntegerSelector
    inputAddress: AddressSelector
    inOutputTxId: HashSelector
    inOutputIndex: IntegerSelector
    inputValue: FloatSelector
    currency: [CardanoCurrencySelector!]
    inputSource: CardanoInputSourcenSelector
  ): DecimalNumberAsDiv
}

"""
Transaction Mint
"""
type CardanoTransactionMint {
  any(of: CardanoMintsMeasureable!): String

  """
  Block where transaction is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Mint count
  """
  count(
    uniq: CardanoMintUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    value: FloatSelector
    currency: [CardanoCurrencySelector!]
  ): Int

  """
  Mint count
  """
  countBigInt(
    uniq: CardanoMintUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    value: FloatSelector
    currency: [CardanoCurrencySelector!]
  ): BigInt

  """
  Currency of the mint
  """
  currency: Currency

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber
  maximum(of: CardanoMintsMeasureable!, get: CardanoMintsMeasureable): String
  minimum(of: CardanoMintsMeasureable!, get: CardanoMintsMeasureable): String

  """
  Transaction ID Hash
  """
  transaction(
    txId: StringIdSelector
    txIndex: IntegerSelector
  ): TransactionHashIndex

  """
  Mint value
  """
  value(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    value: FloatSelector
    currency: [CardanoCurrencySelector!]
  ): Float
}

"""
Transaction Output
"""
type CardanoTransactionOutput {
  any(of: CardanoOutputsMeasureable!): String

  """
  Block where transaction is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Output count
  """
  count(
    uniq: CardanoOutputUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    outputIndex: IntegerSelector
    outputAddress: AddressSelector
    outputDirection: CardanoOutputDirectionSelector
    outputValue: FloatSelector
    currency: [CardanoCurrencySelector!]
  ): Int

  """
  Output count
  """
  countBigInt(
    uniq: CardanoOutputUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    outputIndex: IntegerSelector
    outputAddress: AddressSelector
    outputDirection: CardanoOutputDirectionSelector
    outputValue: FloatSelector
    currency: [CardanoCurrencySelector!]
  ): BigInt

  """
  Currency of the output
  """
  currency: Currency

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber
  maximum(
    of: CardanoOutputsMeasureable!
    get: CardanoOutputsMeasureable
  ): String
  minimum(
    of: CardanoOutputsMeasureable!
    get: CardanoOutputsMeasureable
  ): String

  """
  Output address
  """
  outputAddress(outputAddress: AddressSelector): Address

  """
  Output guessed direction
  """
  outputDirection(
    outputDirection: CardanoOutputDirectionSelector
  ): CardanoOutputDirection

  """
  Output index
  """
  outputIndex(outputIndex: IntegerSelector): Int

  """
  Transaction ID Hash
  """
  transaction(
    txId: StringIdSelector
    txIndex: IntegerSelector
  ): TransactionHashIndex

  """
  Output value
  """
  value(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    outputIndex: IntegerSelector
    outputAddress: AddressSelector
    outputDirection: CardanoOutputDirectionSelector
    outputValue: FloatSelector
    currency: [CardanoCurrencySelector!]
  ): Float

  """
  Input value as decimal
  """
  valueDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    inputIndex: IntegerSelector
    inputAddress: AddressSelector
    inOutputTxId: HashSelector
    inOutputIndex: IntegerSelector
    inputValue: FloatSelector
    currency: [CardanoCurrencySelector!]
    inputSource: CardanoInputSourcenSelector
  ): DecimalNumberAsDiv
}

enum CardanoTransactionsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Transaction index
  """
  tx_index

  """
  Input count
  """
  input_count

  """
  Output count
  """
  output_count

  """
  Transaction size
  """
  tx_size

  """
  Transaction input value
  """
  input_value

  """
  Transaction output value
  """
  output_value

  """
  Transaction withdrawal value
  """
  withdrawal_value

  """
  Transaction deposit value
  """
  deposit_value

  """
  Transaction withdrawal count
  """
  withdrawal_count

  """
  Transaction mint count
  """
  mint_count
}

enum CardanoTransactionUniq {
  """
  Unique block count
  """
  blocks

  """
  Unique date count
  """
  dates
}

"""
Transaction attributes in coinpath
"""
type CoinpathEntry {
  """
  Amount involved in the flow
  """
  amount: Float!

  """
  Block of transaction
  """
  height: Int!

  """
  Time of transaction in ISO 8601 format
  """
  timestamp: ISO8601DateTime!

  """
  Hash of transaction
  """
  txHash: String!

  """
  Amount transfered in transaction
  """
  txValue: Float!
}

enum CoinpathMeasureable {
  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Sender
  """
  sender

  """
  Receiver
  """
  receiver

  """
  Depth
  """
  depth
}

"""
Limits, Ordering, Constraints, Coinpath Options
"""
input CoinpathOptions {
  """
  Limit number of results
  """
  limit: Int

  """
  Limit number of results by specific field
  """
  limitBy: LimitByOption

  """
  Offset of results, starting from 0
  """
  offset: Int

  """
  Ordering field(s) for ascending
  """
  asc: [String!]

  """
  Ordering field(s) for descending
  """
  desc: [String!]

  """
  Converting field(s) to integer datatype and then ordering field(s) for descending
  """
  descByInteger: [String!]

  """
  Converting field(s) to integer datatype and then ordering field(s) for ascending
  """
  ascByInteger: [String!]

  """
  Flow direction
  """
  direction: FlowDirection

  """
  Do not include transactions below this amount
  """
  minimumTxAmount: Float

  """
  Do not expand addresses having count transactions more than this
  """
  maximumAddressTxCount: Int

  """
  Maximum total transaction count returned
  """
  maximumTotalTxCount: Int

  """
  Raise error if complexity ( currently measured in transaction count ) is higher than this option
  """
  complexityLimit: Int

  """
  Invalidating cache seed
  """
  seed: Int
}

"""
Conflux Chain
"""
type Conflux {
  """
  Ethereum Active Addresses
  """
  activeAddresses(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [EthereumAddressSelector!]
    entityId: EntitySelector
    sender: [EthereumAddressSelector!]
    receiver: [EthereumAddressSelector!]
    currency: [EthereumCurrencySelector!]
    external: Boolean
    success: Boolean
    amount: [AmountSelector!]
    options: QueryOptions
  ): [EthereumActiveAddress!]

  """
  Basic information about address ( or smart contract )
  """
  address(
    address: [ConfluxAddressSelectorIn!]!
  ): [ConfluxAddressInfoWithBalance!]!

  """
  Blockchain Address Statistics
  """
  addressStats(
    address: EthereumAddressSelector!
    options: QueryOptions
  ): [EthereumAddressStats!]

  """
  Arguments of Smart Contract Calls and Events
  """
  arguments(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [ConfluxAddressSelector!]
    caller: [ConfluxAddressSelector!]
    reference: [ConfluxAddressSelector!]
    value: [ArgumentValueSelector!]
    argument: [ArgumentSelector!]
    argumentType: [ArgumentTypeSelector!]
    signatureType: SignatureTypeSelector
    smartContractAddress: [ConfluxAddressSelector!]
    smartContractMethod: MethodSelector
    smartContractEvent: EventSelector
    external: Boolean
    callDepth: StringSelector
    any: [ConfluxArgumentFilter!]
    options: QueryOptions
  ): [ConfluxArguments!]

  """
  Blockchain Blocks
  """
  blocks(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    epoch: BlockSelector
    pivot: Boolean
    blockHash: HashSelector
    referenceBlockHash: HashSelector
    miner: [ConfluxAddressSelector!]
    refereeCount: [IntegerSelector!]
    transactionCount: [IntegerSelector!]
    uncleCount: [IntegerSelector!]
    size: [IntegerSelector!]
    any: [ConfluxBlockFilter!]
    options: QueryOptions
  ): [ConfluxBlocks!]

  """
  Money flow using Coinpath technology
  """
  coinpath(
    sender: ConfluxAddressSelector
    receiver: ConfluxAddressSelector
    currency: [ConfluxCurrencySelector!]
    initialAddress: ConfluxAddressSelector
    initialDate: DateSelector
    initialTime: DateTimeSelector
    date: DateSelector
    time: DateTimeSelector
    depth: IntegerLimitedSelector
    options: CoinpathOptions
  ): [ConfluxCoinpath!]

  """
  Trades on Ethereum DEX Smart Contracts
  """
  dexTrades(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    txHash: HashSelector
    txSender: [EthereumAddressSelector!]
    txTo: [EthereumAddressSelector!]
    protocol: [StringSelector!]
    smartContractAddress: [EthereumAddressSelector!]
    exchangeAddress: [EthereumAddressSelector!]
    exchangeName: [StringSelector!]
    sellCurrency: [EthereumCurrencySelector!]
    buyCurrency: [EthereumCurrencySelector!]
    baseCurrency: [EthereumCurrencySelector!]
    quoteCurrency: [EthereumCurrencySelector!]
    maker: [EthereumAddressSelector!]
    makerSmartContractType: [SmartContractTypeSelector!]
    taker: [EthereumAddressSelector!]
    takerSmartContractType: [SmartContractTypeSelector!]
    makerOrTaker: [EthereumAddressSelector!]
    tradeIndex: [StringSelector!]
    buyAmount: [AmountSelector!]
    sellAmount: [AmountSelector!]
    price: [AmountSelector!]
    priceAsymmetry: [FloatSelector!]
    tradeAmountUsd: [FloatSelector!]
    any: [EthereumDexTradeFilter!]
    options: QueryOptions
  ): [EthereumDexTrades!]

  """
  Smart Contract Calls
  """
  smartContractCalls(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [ConfluxAddressSelector!]
    caller: [ConfluxAddressSelector!]
    smartContractAddress: [ConfluxAddressSelector!]
    smartContractMethod: MethodSelector
    smartContractType: ConfluxSmartContractTypeSelector
    external: Boolean
    success: [Boolean!]
    callDepth: StringSelector
    any: [ConfluxSmartContractCallFilter!]
    options: QueryOptions
  ): [ConfluxSmartContractCalls!]

  """
  Smart Contract Events
  """
  smartContractEvents(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [ConfluxAddressSelector!]
    smartContractType: ConfluxSmartContractTypeSelector
    smartContractAddress: [ConfluxAddressSelector!]
    smartContractEvent: EventSelector
    any: [ConfluxSmartContractEventFilter!]
    options: QueryOptions
  ): [ConfluxSmartContractEvent!]

  """
  Blockchain Transactions
  """
  transactions(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txSender: [ConfluxAddressSelector!]
    txTo: [ConfluxAddressSelector!]
    txCreates: [ConfluxAddressSelector!]
    txIndex: TxIndexSelector
    success: Boolean
    amount: [AmountSelector!]
    gasCurrency: [EthereumCurrencySelector!]
    blockHash: HashSelector
    any: [ConfluxTransactionFilter!]
    options: QueryOptions
  ): [ConfluxTransactions!]

  """
  Currency Transfers
  """
  transfers(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [ConfluxAddressSelector!]
    entityId: EntitySelector
    sender: [ConfluxAddressSelector!]
    receiver: [ConfluxAddressSelector!]
    currency: [ConfluxCurrencySelector!]
    external: Boolean
    success: Boolean
    amount: [AmountSelector!]
    any: [ConfluxTransferFilter!]
    options: QueryOptions
  ): [ConfluxTransfers!]
}

"""
Address detailed information for Conflux network
"""
type ConfluxAddressInfo {
  """
  Address
  """
  address: String

  """
  Annotations ( tags ), if exists
  """
  annotation: String

  """
  Smart Contract if exists on the address
  """
  smartContract: ConfluxSmartContractInfo
}

"""
Blockchain address
"""
type ConfluxAddressInfoWithBalance {
  """
  Address
  """
  address: String

  """
  Annotations ( tags ), if exists
  """
  annotation: String

  """
  DEPRECATED Current address balance
  """
  balance(in: BaseCurrencyEnum): Float

  """
  DEPRECATED Balances by currencies for the address
  """
  balances(
    date: DateSelector
    time: DateTimeSelector
    currency: ConfluxCurrencySelector
    height: BlockSelectorRange
  ): [ConfluxBalance!]

  """
  Smart Contract if exists on the address
  """
  smartContract: ConfluxSmartContractInfoWithAttributes
}

"""
Address should start from cfx: and contain hex digits.
  If digits are case sensitive, address is checked against checksum according to EIP-55.
"""
input ConfluxAddressSelector {
  """
  Equal to Address
  """
  is: String

  """
  Not Equal to Address
  """
  not: String

  """
  In the list of Addresses
  """
  in: [String!]

  """
  Not in the list of Addresses
  """
  notIn: [String!]
}

"""
Address should start from cfx: and contain hex digits.
  If digits are case sensitive, address is checked against checksum according to EIP-55.
"""
input ConfluxAddressSelectorIn {
  """
  Equal to Address
  """
  is: String

  """
  In the list of Addresses
  """
  in: [String!]
}

input ConfluxArgumentFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [ConfluxAddressSelector!]
  caller: [ConfluxAddressSelector!]
  reference: [ConfluxAddressSelector!]
  value: [ArgumentValueSelector!]
  argument: [ArgumentSelector!]
  argumentType: [ArgumentTypeSelector!]
  signatureType: SignatureTypeSelector
  smartContractAddress: [ConfluxAddressSelector!]
  smartContractMethod: MethodSelector
  smartContractEvent: EventSelector
  external: Boolean
  callDepth: StringSelector
}

"""
Argument name and value of smart contract call or event
"""
type ConfluxArgumentNameValue {
  """
  Argument name
  """
  argument: String!

  """
  Argument data type
  """
  argumentType: String!

  """
  Sequential index of value in array ( multi-dimensional)
  """
  index: String!

  """
  Value as String
  """
  value: String!
}

"""
Arguments of Smart Contract Calls and Events
"""
type ConfluxArguments {
  any(
    of: ConfluxArgumentsMeasureable!
    as: ConfluxArgumentsConvertable
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [ConfluxAddressSelector!]
    caller: [ConfluxAddressSelector!]
    reference: [ConfluxAddressSelector!]
    value: [ArgumentValueSelector!]
    argument: [ArgumentSelector!]
    argumentType: [ArgumentTypeSelector!]
    signatureType: SignatureTypeSelector
    smartContractAddress: [ConfluxAddressSelector!]
    smartContractMethod: MethodSelector
    smartContractEvent: EventSelector
    external: Boolean
    callDepth: StringSelector
  ): String

  """
  Method or event argument
  """
  argument(argument: [ArgumentSelector!], argumentType: String): ArgumentName

  """
  Block in the blockchain
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Depth of the call. Empty string for external call, then counted as 0...N, and
  the next layer is added through '-'. For example 0-3-9.
  """
  callDepth: String

  """
  Caller of the method invocation ( tx sender or another smart contract )
  """
  caller(caller: [ConfluxAddressSelector!]): ConfluxAddressInfo

  """
  Counts and other metrics
  """
  count(
    uniq: SmartContractArgumentsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [ConfluxAddressSelector!]
    caller: [ConfluxAddressSelector!]
    reference: [ConfluxAddressSelector!]
    value: [ArgumentValueSelector!]
    argument: [ArgumentSelector!]
    argumentType: [ArgumentTypeSelector!]
    signatureType: SignatureTypeSelector
    smartContractAddress: [ConfluxAddressSelector!]
    smartContractMethod: MethodSelector
    smartContractEvent: EventSelector
    external: Boolean
    callDepth: StringSelector
  ): Int

  """
  Counts and other metrics
  """
  countBigInt(
    uniq: SmartContractArgumentsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [ConfluxAddressSelector!]
    caller: [ConfluxAddressSelector!]
    reference: [ConfluxAddressSelector!]
    value: [ArgumentValueSelector!]
    argument: [ArgumentSelector!]
    argumentType: [ArgumentTypeSelector!]
    signatureType: SignatureTypeSelector
    smartContractAddress: [ConfluxAddressSelector!]
    smartContractMethod: MethodSelector
    smartContractEvent: EventSelector
    external: Boolean
    callDepth: StringSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  External call executed explicitly by tx sender. Internal calls executed by smart contracts.
  """
  external(external: Boolean): Boolean

  """
  Sequential index of value in array ( multi-dimensional)
  """
  index: String!
  maximum(
    of: ConfluxArgumentsMeasureable!
    get: ConfluxArgumentsMeasureable
    as: ConfluxArgumentsConvertable
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [ConfluxAddressSelector!]
    caller: [ConfluxAddressSelector!]
    reference: [ConfluxAddressSelector!]
    value: [ArgumentValueSelector!]
    argument: [ArgumentSelector!]
    argumentType: [ArgumentTypeSelector!]
    signatureType: SignatureTypeSelector
    smartContractAddress: [ConfluxAddressSelector!]
    smartContractMethod: MethodSelector
    smartContractEvent: EventSelector
    external: Boolean
    callDepth: StringSelector
  ): String
  minimum(
    of: ConfluxArgumentsMeasureable!
    get: ConfluxArgumentsMeasureable
    as: ConfluxArgumentsConvertable
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [ConfluxAddressSelector!]
    caller: [ConfluxAddressSelector!]
    reference: [ConfluxAddressSelector!]
    value: [ArgumentValueSelector!]
    argument: [ArgumentSelector!]
    argumentType: [ArgumentTypeSelector!]
    signatureType: SignatureTypeSelector
    smartContractAddress: [ConfluxAddressSelector!]
    smartContractMethod: MethodSelector
    smartContractEvent: EventSelector
    external: Boolean
    callDepth: StringSelector
  ): String
  number(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [ConfluxAddressSelector!]
    caller: [ConfluxAddressSelector!]
    reference: [ConfluxAddressSelector!]
    value: [ArgumentValueSelector!]
    argument: [ArgumentSelector!]
    argumentType: [ArgumentTypeSelector!]
    signatureType: SignatureTypeSelector
    smartContractAddress: [ConfluxAddressSelector!]
    smartContractMethod: MethodSelector
    smartContractEvent: EventSelector
    external: Boolean
    callDepth: StringSelector
  ): Float

  """
  Address value of method or event argument
  """
  reference(reference: [ConfluxAddressSelector!]): ConfluxAddressInfo

  """
  Smart contract being called
  """
  smartContract(
    smartContractAddress: [ConfluxAddressSelector!]
  ): ConfluxSmartContract

  """
  Contract method or event
  """
  smartContractSignature(
    smartContractMethod: MethodSelector
    smartContractEvent: EventSelector
    signatureType: SignatureTypeSelector
  ): Signature

  """
  True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
  """
  success(success: [Boolean!]): Boolean

  """
  Transaction where call happened
  """
  transaction(
    txHash: [HashSelector!]
    txFrom: [ConfluxAddressSelector!]
  ): ConfluxTransactionInfo

  """
  The Value of method or event argument
  """
  value(value: [ArgumentValueSelector!]): ArgumentValue
}

enum ConfluxArgumentsConvertable {
  """
  Token symbol
  """
  token_symbol

  """
  Token name
  """
  token_name
}

enum ConfluxArgumentsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Caller
  """
  caller

  """
  Smart Contract
  """
  smart_contract

  """
  Smart Contract Method Name
  """
  signature_name

  """
  Smart Contract Method Signature
  """
  signature

  """
  Smart Contract Method Signature
  """
  signature_type

  """
  Smart Contract Method Signature Hash
  """
  signature_hash

  """
  Call depth
  """
  call_depth

  """
  Argument
  """
  argument

  """
  Argument type
  """
  argument_type

  """
  Argument value
  """
  argument_value

  """
  Argument index
  """
  argument_index
}

"""
Balance in a currency
"""
type ConfluxBalance {
  """
  Currency of transfer
  """
  currency: Currency

  """
  History of balance changes by currencies for the address
  """
  history: [ConfluxBalanceChange!]
  value(in: BaseCurrencyEnum): Float
}

"""
Change of balance in a currency
"""
type ConfluxBalanceChange {
  """
  Block number (height) in blockchain
  """
  block: Int!

  """
  Block timestamp
  """
  timestamp: ISO8601DateTime

  """
  Transfer amount ( positive inbound, negative outbound)
  """
  transferAmount: Float
  value: Float
}

input ConfluxBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  epoch: BlockSelector
  pivot: Boolean
  blockHash: HashSelector
  referenceBlockHash: HashSelector
  miner: [ConfluxAddressSelector!]
  refereeCount: [IntegerSelector!]
  transactionCount: [IntegerSelector!]
  uncleCount: [IntegerSelector!]
  size: [IntegerSelector!]
}

"""
Blocks in Conflux blockchain
"""
type ConfluxBlocks {
  """
  Block is adaptive
  """
  adaptive: Boolean!
  any(of: ConfluxBlocksMeasureable!): String

  """
  Blame
  """
  blame: Int!

  """
  Block index in epoch
  """
  blockPosition: Int!
  count(
    uniq: EthereumBlocksUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    epoch: BlockSelector
    pivot: Boolean
    blockHash: HashSelector
    referenceBlockHash: HashSelector
    miner: [ConfluxAddressSelector!]
    refereeCount: [IntegerSelector!]
    transactionCount: [IntegerSelector!]
    uncleCount: [IntegerSelector!]
    size: [IntegerSelector!]
  ): Int
  countBigInt(
    uniq: EthereumBlocksUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    epoch: BlockSelector
    pivot: Boolean
    blockHash: HashSelector
    referenceBlockHash: HashSelector
    miner: [ConfluxAddressSelector!]
    refereeCount: [IntegerSelector!]
    transactionCount: [IntegerSelector!]
    uncleCount: [IntegerSelector!]
    size: [IntegerSelector!]
  ): BigInt

  """
  Calendar date
  """
  date: Date

  """
  Epoch in blockchain
  """
  epoch(height: BlockSelector): Int!
  expression(get: String!): DecimalNumber

  """
  Block hash
  """
  hash(blockHash: [HashSelector!]): String!

  """
  Block height in blockchain
  """
  height(height: BlockSelector): Int!
  maximum(of: ConfluxBlocksMeasureable!, get: ConfluxBlocksMeasureable): String

  """
  Block miner
  """
  miner(miner: [ConfluxAddressSelector!]): EthereumAddressInfo
  minimum(of: ConfluxBlocksMeasureable!, get: ConfluxBlocksMeasureable): String

  """
  Block nonce
  """
  nonce: Int!

  """
  Parent block hash
  """
  parentHash: String!

  """
  Block is pivot
  """
  pivot: Boolean!

  """
  Power Quality
  """
  powerQuality: BigInt!
  refereeCount(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    epoch: BlockSelector
    pivot: Boolean
    blockHash: HashSelector
    referenceBlockHash: HashSelector
    miner: [ConfluxAddressSelector!]
    refereeCount: [IntegerSelector!]
    transactionCount: [IntegerSelector!]
    uncleCount: [IntegerSelector!]
    size: [IntegerSelector!]
  ): Int
  refereeCountBigInt(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    epoch: BlockSelector
    pivot: Boolean
    blockHash: HashSelector
    referenceBlockHash: HashSelector
    miner: [ConfluxAddressSelector!]
    refereeCount: [IntegerSelector!]
    transactionCount: [IntegerSelector!]
    uncleCount: [IntegerSelector!]
    size: [IntegerSelector!]
  ): BigInt

  """
  Reference Block hash
  """
  referenceBlockHash(referenceBlockHash: [HashSelector!]): String!
  size(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    epoch: BlockSelector
    pivot: Boolean
    blockHash: HashSelector
    referenceBlockHash: HashSelector
    miner: [ConfluxAddressSelector!]
    refereeCount: [IntegerSelector!]
    transactionCount: [IntegerSelector!]
    uncleCount: [IntegerSelector!]
    size: [IntegerSelector!]
  ): Int

  """
  Block timestamp
  """
  timestamp(time: DateTimeSelector): DateTime
  totalDifficulty(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    epoch: BlockSelector
    pivot: Boolean
    blockHash: HashSelector
    referenceBlockHash: HashSelector
    miner: [ConfluxAddressSelector!]
    refereeCount: [IntegerSelector!]
    transactionCount: [IntegerSelector!]
    uncleCount: [IntegerSelector!]
    size: [IntegerSelector!]
  ): Float
  transactionCount(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    epoch: BlockSelector
    pivot: Boolean
    blockHash: HashSelector
    referenceBlockHash: HashSelector
    miner: [ConfluxAddressSelector!]
    refereeCount: [IntegerSelector!]
    transactionCount: [IntegerSelector!]
    uncleCount: [IntegerSelector!]
    size: [IntegerSelector!]
  ): Int
  transactionCountBigInt(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    epoch: BlockSelector
    pivot: Boolean
    blockHash: HashSelector
    referenceBlockHash: HashSelector
    miner: [ConfluxAddressSelector!]
    refereeCount: [IntegerSelector!]
    transactionCount: [IntegerSelector!]
    uncleCount: [IntegerSelector!]
    size: [IntegerSelector!]
  ): BigInt

  """
  Hash of Transaction included in block
  """
  txHash(txHash: [HashSelector!]): String!
  uncleCount(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    epoch: BlockSelector
    pivot: Boolean
    blockHash: HashSelector
    referenceBlockHash: HashSelector
    miner: [ConfluxAddressSelector!]
    refereeCount: [IntegerSelector!]
    transactionCount: [IntegerSelector!]
    uncleCount: [IntegerSelector!]
    size: [IntegerSelector!]
  ): Int
  uncleCountBigInt(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    epoch: BlockSelector
    pivot: Boolean
    blockHash: HashSelector
    referenceBlockHash: HashSelector
    miner: [ConfluxAddressSelector!]
    refereeCount: [IntegerSelector!]
    transactionCount: [IntegerSelector!]
    uncleCount: [IntegerSelector!]
    size: [IntegerSelector!]
  ): BigInt
}

enum ConfluxBlocksMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Block hash
  """
  block_hash

  """
  Block Miner
  """
  miner

  """
  Block Referee Count
  """
  referee_count

  """
  Block TX Count
  """
  transaction_count
}

enum ConfluxCallsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Caller
  """
  caller

  """
  Smart Contract
  """
  smart_contract

  """
  Smart Contract Method Name
  """
  signature_name

  """
  Smart Contract Method Signature
  """
  signature

  """
  Smart Contract Method Signature Hash
  """
  signature_hash

  """
  Call depth
  """
  call_depth
}

"""
Coinpath
"""
type ConfluxCoinpath {
  """
  Summary of transfered value
  """
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """
  Block where transaction is included
  """
  block: Block

  """
  Count of transfers
  """
  count: Int

  """
  Count of transfers
  """
  countBigInt: BigInt

  """
  Currency of transfer
  """
  currency: Currency

  """
  1-based hop depth of the graph
  """
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """
  Receiver address
  """
  receiver: ConfluxCoinpathAddress

  """
  Sender address
  """
  sender: ConfluxCoinpathAddress

  """
  Transaction of transfer happened
  """
  transaction: TransactionHashValueTime

  """
  Attributes of transaction included in Coinpath result
  """
  transactions: [CoinpathEntry!]
}

"""
Address detailed information for Conflux network
"""
type ConfluxCoinpathAddress {
  """
  Address
  """
  address: String
  amountIn: DecimalNumber
  amountOut: DecimalNumber

  """
  Annotations ( tags ), if exists
  """
  annotation: String
  balance: DecimalNumber

  """
  Smart Contract if exists on the address
  """
  firstTxAt: DateTime

  """
  Smart Contract if exists on the address
  """
  lastTxAt: DateTime
  receiversCount: Int
  sendersCount: Int

  """
  Smart Contract if exists on the address
  """
  smartContract: ConfluxSmartContractInfo

  """
  Address type
  """
  type: String
}

"""
Currency selector in Conflux blockchain.
  Currencies supported are native ( CFX ), ERC20, ERC721 tokens.
  You can specify currency symbol or smart contract address. Symbols CFX are
reserved for native currencies in Conflux mainnet and classic.
  Conflux Smart contract address should start from cfx: and contain 42 symbols.
  If digits are case sensitive, address is checked against checksum according to EIP-55.
"""
input ConfluxCurrencySelector {
  """
  Currency is
  """
  is: String

  """
  Currency not
  """
  not: String

  """
  Currency in the list
  """
  in: [String!]

  """
  Currency not in the list
  """
  notIn: [String!]
}

enum ConfluxEventsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Smart Contract
  """
  smart_contract

  """
  Smart Contract Event Name
  """
  signature_name

  """
  Smart Contract Event Signature
  """
  signature

  """
  Smart Contract Event Signature Hash
  """
  signature_hash
}

enum ConfluxNetwork {
  """
  Conflux Hydra
  """
  conflux_hydra

  """
  Conflux Oceanus
  """
  conflux_oceanus

  """
  Conflux Tethys
  """
  conflux_tethys
}

"""
Conflux smart contract
"""
type ConfluxSmartContract {
  """
  Smart Contract Address
  """
  address: Address!

  """
  Smart Contract Type
  """
  contractType: SmartContractType

  """
  Token implemented in this smart contract
  """
  currency: ScCurrency

  """
  Smart Contract Protocol Type
  """
  protocolType: String
}

input ConfluxSmartContractCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [ConfluxAddressSelector!]
  caller: [ConfluxAddressSelector!]
  smartContractAddress: [ConfluxAddressSelector!]
  smartContractMethod: MethodSelector
  smartContractType: ConfluxSmartContractTypeSelector
  external: Boolean
  success: [Boolean!]
  callDepth: StringSelector
}

"""
Smart Contract Calls
"""
type ConfluxSmartContractCalls {
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [ConfluxAddressSelector!]
    caller: [ConfluxAddressSelector!]
    smartContractAddress: [ConfluxAddressSelector!]
    smartContractMethod: MethodSelector
    smartContractType: ConfluxSmartContractTypeSelector
    external: Boolean
    success: [Boolean!]
    callDepth: StringSelector
  ): Float
  any(of: ConfluxCallsMeasureable!): String

  """
  Call arguments
  """
  arguments: [ConfluxArgumentNameValue!]

  """
  Block in the blockchain
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Depth of the call. Empty string for external call, then counted as 0...N, and
  the next layer is added through '-'. For example 0-3-9.
  """
  callDepth: String

  """
  Caller of the method invocation ( tx sender or another smart contract )
  """
  caller(caller: [ConfluxAddressSelector!]): ConfluxAddressInfo

  """
  Counts and other metrics
  """
  count(
    uniq: SmartContractCallsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [ConfluxAddressSelector!]
    caller: [ConfluxAddressSelector!]
    smartContractAddress: [ConfluxAddressSelector!]
    smartContractMethod: MethodSelector
    smartContractType: ConfluxSmartContractTypeSelector
    external: Boolean
    success: [Boolean!]
    callDepth: StringSelector
  ): Int

  """
  Counts and other metrics
  """
  countBigInt(
    uniq: SmartContractCallsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [ConfluxAddressSelector!]
    caller: [ConfluxAddressSelector!]
    smartContractAddress: [ConfluxAddressSelector!]
    smartContractMethod: MethodSelector
    smartContractType: ConfluxSmartContractTypeSelector
    external: Boolean
    success: [Boolean!]
    callDepth: StringSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date

  """
  External call executed explicitly by tx sender. Internal calls executed by smart contracts.
  """
  external(external: Boolean): Boolean

  """
  Gas used for transaction in external call, or by methd in internal call
  """
  gasValue(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [ConfluxAddressSelector!]
    caller: [ConfluxAddressSelector!]
    smartContractAddress: [ConfluxAddressSelector!]
    smartContractMethod: MethodSelector
    smartContractType: ConfluxSmartContractTypeSelector
    external: Boolean
    success: [Boolean!]
    callDepth: StringSelector
  ): Float
  maximum(of: ConfluxCallsMeasureable!, get: ConfluxCallsMeasureable): String
  minimum(of: ConfluxCallsMeasureable!, get: ConfluxCallsMeasureable): String

  """
  Smart contract being called
  """
  smartContract(
    smartContractAddress: [ConfluxAddressSelector!]
  ): ConfluxSmartContract

  """
  Contract method invoked
  """
  smartContractMethod(smartContractMethod: MethodSelector): Method

  """
  True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
  """
  success(success: [Boolean!]): Boolean

  """
  Transaction where call happened
  """
  transaction(
    txHash: [HashSelector!]
    txFrom: [ConfluxAddressSelector!]
  ): ConfluxTransactionInfo
}

"""
Smart Contract Events
"""
type ConfluxSmartContractEvent {
  any(of: ConfluxEventsMeasureable!): String

  """
  Event arguments
  """
  arguments: [ConfluxArgumentNameValue!]

  """
  Block in the blockchain
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Counts and other metrics
  """
  count(
    uniq: SmartContractCallsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [ConfluxAddressSelector!]
    smartContractType: ConfluxSmartContractTypeSelector
    smartContractAddress: [ConfluxAddressSelector!]
    smartContractEvent: EventSelector
  ): Int

  """
  Counts and other metrics
  """
  countBigInt(
    uniq: SmartContractCallsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [ConfluxAddressSelector!]
    smartContractType: ConfluxSmartContractTypeSelector
    smartContractAddress: [ConfluxAddressSelector!]
    smartContractEvent: EventSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  maximum(of: ConfluxEventsMeasureable!, get: ConfluxEventsMeasureable): String
  minimum(of: ConfluxEventsMeasureable!, get: ConfluxEventsMeasureable): String

  """
  Smart contract being called
  """
  smartContract(
    smartContractAddress: [ConfluxAddressSelector!]
  ): ConfluxSmartContract

  """
  Contract event logged
  """
  smartContractEvent(smartContractEvent: EventSelector): Event

  """
  Transaction where event happened
  """
  transaction(
    txHash: [HashSelector!]
    txFrom: [ConfluxAddressSelector!]
  ): ConfluxTransactionInfo
}

input ConfluxSmartContractEventFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [ConfluxAddressSelector!]
  smartContractType: ConfluxSmartContractTypeSelector
  smartContractAddress: [ConfluxAddressSelector!]
  smartContractEvent: EventSelector
}

"""
Blockchain smart contract
"""
type ConfluxSmartContractInfo {
  """
  Smart Contract Type
  """
  contractType: SmartContractType

  """
  Token implemented in this smart contract
  """
  currency: ScCurrency

  """
  Smart Contract Protocol Type
  """
  protocolType: String
}

type ConfluxSmartContractInfoWithAttribute {
  """
  Value as address if applicable
  """
  address: ConfluxAddressInfo

  """
  Method name
  """
  name: String!

  """
  Method return type
  """
  type: String!

  """
  Method return value
  """
  value: String!
}

"""
Blockchain smart contract
"""
type ConfluxSmartContractInfoWithAttributes {
  """
  Attributes from readonly methods
  """
  attributes: [ConfluxSmartContractInfoWithAttribute!]

  """
  Smart Contract Type
  """
  contractType: SmartContractType

  """
  Token implemented in this smart contract
  """
  currency: ScCurrency

  """
  Smart Contract Protocol Type
  """
  protocolType: String
}

"""
Selector of smart contract type
"""
input ConfluxSmartContractTypeSelector {
  """
  Smart Contract type is
  """
  is: SmartContractType

  """
  Smart Contract type not
  """
  not: SmartContractType

  """
  Smart Contract type in the list
  """
  in: [SmartContractType!]

  """
  Smart Contract type not in the list
  """
  notIn: [SmartContractType!]
}

input ConfluxTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txSender: [ConfluxAddressSelector!]
  txTo: [ConfluxAddressSelector!]
  txCreates: [ConfluxAddressSelector!]
  txIndex: TxIndexSelector
  success: Boolean
  amount: [AmountSelector!]
  gasCurrency: [EthereumCurrencySelector!]
  blockHash: HashSelector
}

"""
Blockchain transaction info
"""
type ConfluxTransactionInfo {
  """
  Gas consumed
  """
  gas: Int!

  """
  Gas price in Gwei
  """
  gasPrice: Float!

  """
  Gas value cost
  """
  gasValue: Float!

  """
  Hash hex representation
  """
  hash: String!

  """
  Transaction from address
  """
  txFrom: ConfluxAddressInfo!
}

"""
Transactions in Conflux blockchain
"""
type ConfluxTransactions {
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txSender: [ConfluxAddressSelector!]
    txTo: [ConfluxAddressSelector!]
    txCreates: [ConfluxAddressSelector!]
    txIndex: TxIndexSelector
    success: Boolean
    amount: [AmountSelector!]
    gasCurrency: [EthereumCurrencySelector!]
    blockHash: HashSelector
  ): Float
  any(of: ConfluxTransactionsMeasureable!): String

  """
  Block where transfer transaction is included
  """
  block(
    blockHash: HashSelector
    height: BlockSelector
    time: DateTimeSelector
  ): BlockInfo
  count(
    uniq: EthereumTransactionsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txSender: [ConfluxAddressSelector!]
    txTo: [ConfluxAddressSelector!]
    txCreates: [ConfluxAddressSelector!]
    txIndex: TxIndexSelector
    success: Boolean
    amount: [AmountSelector!]
    gasCurrency: [EthereumCurrencySelector!]
    blockHash: HashSelector
  ): Int
  countBigInt(
    uniq: EthereumTransactionsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txSender: [ConfluxAddressSelector!]
    txTo: [ConfluxAddressSelector!]
    txCreates: [ConfluxAddressSelector!]
    txIndex: TxIndexSelector
    success: Boolean
    amount: [AmountSelector!]
    gasCurrency: [EthereumCurrencySelector!]
    blockHash: HashSelector
  ): BigInt

  """
  Created smart contract
  """
  creates(txCreates: [ConfluxAddressSelector!]): EthereumAddressInfo

  """
  Currency of amount
  """
  currency: Currency

  """
  Calendar date
  """
  date: Date

  """
  Error message if any
  """
  error: String
  expression(get: String!): DecimalNumber
  gas(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txSender: [ConfluxAddressSelector!]
    txTo: [ConfluxAddressSelector!]
    txCreates: [ConfluxAddressSelector!]
    txIndex: TxIndexSelector
    success: Boolean
    amount: [AmountSelector!]
    gasCurrency: [EthereumCurrencySelector!]
    blockHash: HashSelector
  ): Int

  """
  Currency of gas
  """
  gasCurrency(gasCurrency: [EthereumCurrencySelector!]): Currency

  """
  Gas price in Gwei
  """
  gasPrice(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txSender: [ConfluxAddressSelector!]
    txTo: [ConfluxAddressSelector!]
    txCreates: [ConfluxAddressSelector!]
    txIndex: TxIndexSelector
    success: Boolean
    amount: [AmountSelector!]
    gasCurrency: [EthereumCurrencySelector!]
    blockHash: HashSelector
  ): Float!
  gasValue(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txSender: [ConfluxAddressSelector!]
    txTo: [ConfluxAddressSelector!]
    txCreates: [ConfluxAddressSelector!]
    txIndex: TxIndexSelector
    success: Boolean
    amount: [AmountSelector!]
    gasCurrency: [EthereumCurrencySelector!]
    blockHash: HashSelector
  ): Float

  """
  Hash hex representation
  """
  hash(txHash: [HashSelector!]): String!

  """
  Transaction index in block, 0 based
  """
  index(txIndex: [TxIndexSelector!]): Int
  maximum(
    of: ConfluxTransactionsMeasureable!
    get: ConfluxTransactionsMeasureable
  ): String
  minimum(
    of: ConfluxTransactionsMeasureable!
    get: ConfluxTransactionsMeasureable
  ): String

  """
  Transaction nonce
  """
  nonce: Int

  """
  Transaction sender
  """
  sender(txSender: [ConfluxAddressSelector!]): EthereumAddressInfo

  """
  Success
  """
  success(success: Boolean): Boolean

  """
  Transaction receiver
  """
  to(txTo: [ConfluxAddressSelector!]): EthereumAddressInfo
}

enum ConfluxTransactionsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Amount
  """
  amount

  """
  Transaction Sender
  """
  tx_sender

  """
  Gas value
  """
  gas_value

  """
  Gas price
  """
  gas_price

  """
  Gas used
  """
  gas
}

input ConfluxTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [ConfluxAddressSelector!]
  entityId: EntitySelector
  sender: [ConfluxAddressSelector!]
  receiver: [ConfluxAddressSelector!]
  currency: [ConfluxCurrencySelector!]
  external: Boolean
  success: Boolean
  amount: [AmountSelector!]
}

"""
Currency transfers from/to addresses in crypto currencies
"""
type ConfluxTransfers {
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [ConfluxAddressSelector!]
    entityId: EntitySelector
    sender: [ConfluxAddressSelector!]
    receiver: [ConfluxAddressSelector!]
    currency: [ConfluxCurrencySelector!]
    external: Boolean
    success: Boolean
    amount: [AmountSelector!]
  ): Float
  any(of: ConfluxTransfersMeasureable!): String

  """
  Block where transfer transaction is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(
    uniq: TransfersUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [ConfluxAddressSelector!]
    entityId: EntitySelector
    sender: [ConfluxAddressSelector!]
    receiver: [ConfluxAddressSelector!]
    currency: [ConfluxCurrencySelector!]
    external: Boolean
    success: Boolean
    amount: [AmountSelector!]
  ): Int
  countBigInt(
    uniq: TransfersUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [ConfluxAddressSelector!]
    entityId: EntitySelector
    sender: [ConfluxAddressSelector!]
    receiver: [ConfluxAddressSelector!]
    currency: [ConfluxCurrencySelector!]
    external: Boolean
    success: Boolean
    amount: [AmountSelector!]
  ): BigInt

  """
  Currency of transfer
  """
  currency(currency: [ConfluxCurrencySelector!]): Currency

  """
  Calendar date
  """
  date: Date

  """
  Entity identifier ( for ERC-721 NFT tokens )
  """
  entityId(entityId: EntitySelector): String

  """
  External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts.
  """
  external(external: Boolean): Boolean
  gasValue(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [ConfluxAddressSelector!]
    entityId: EntitySelector
    sender: [ConfluxAddressSelector!]
    receiver: [ConfluxAddressSelector!]
    currency: [ConfluxCurrencySelector!]
    external: Boolean
    success: Boolean
    amount: [AmountSelector!]
  ): Float
  maximum(
    of: ConfluxTransfersMeasureable!
    get: ConfluxTransfersMeasureable
  ): String
  minimum(
    of: ConfluxTransfersMeasureable!
    get: ConfluxTransfersMeasureable
  ): String

  """
  Transfer receiver
  """
  receiver(receiver: [ConfluxAddressSelector!]): ConfluxAddressInfo

  """
  Transfer sender
  """
  sender(sender: [ConfluxAddressSelector!]): ConfluxAddressInfo

  """
  Success flag
  """
  success(success: Boolean): Boolean

  """
  Transaction where transfer happened
  """
  transaction(
    txHash: [HashSelector!]
    txFrom: [ConfluxAddressSelector!]
  ): ConfluxTransactionInfo
}

enum ConfluxTransfersMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Amount
  """
  amount

  """
  Sender
  """
  sender

  """
  Receiver
  """
  receiver

  """
  Currency symbol
  """
  currency_symbol

  """
  Token address
  """
  currency_address

  """
  Entity ID
  """
  entity_id
}

"""
Cosmos Blockchain
"""
type Cosmos {
  """
  Basic information about address
  """
  address(address: [AddressSelectorIn!]!): [CosmosAddressInfo!]!

  """
  Cosmos Attributes
  """
  attributes(
    date: DateSelector
    time: DateTimeSelector
    blockHeight: BlockSelector
    blockHash: HashSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSigner: StringSelector
    messageType: StringSelector
    messageIndex: IntegerSelector
    success: BooleanSelector
    senders: StringSelector
    eventType: StringSelector
    attribute: StringSelector
    value: StringSelector
    valueIndex: IntegerSelector
    any: [CosmosAttributeFilter!]
    options: QueryOptions
  ): [CosmosAttribute!]

  """
  Cosmos Blocks
  """
  blocks(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    proposer: AddressSelector
    any: [CosmosBlocksFilter!]
    options: QueryOptions
  ): [CosmosBlock!]

  """
  Money flow using Coinpath technology
  """
  coinpath(
    sender: AddressSelector
    receiver: AddressSelector
    currency: [CosmosCurrencySelector!]
    initialAddress: AddressSelector
    initialDate: DateSelector
    initialTime: DateTimeSelector
    date: DateSelector
    time: DateTimeSelector
    depth: IntegerLimitedSelector
    options: CoinpathOptions
  ): [CosmosCoinpath!]

  """
  Cosmos Messages
  """
  messages(
    date: DateSelector
    blockHeight: BlockSelector
    blockHash: HashSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSigner: AddressSelector
    type: StringSelector
    index: IntegerSelector
    success: BooleanSelector
    senders: StringSelector
    any: [CosmosMessageFilter!]
    options: QueryOptions
  ): [CosmosMessage!]

  """
  Cosmos Transactions
  """
  transactions(
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    hash: HashSelector
    type: StringSelector
    index: IntegerSelector
    gasUsed: IntegerSelector
    gasWanted: IntegerSelector
    signer: AddressSelector
    memo: StringSelector
    fee: AmountSelector
    code: IntegerSelector
    success: BooleanSelector
    any: [CosmosTransactionFilter!]
    options: QueryOptions
  ): [CosmosTransaction!]

  """
  Cosmos Transfers
  """
  transfers(
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    blockHash: HashSelector
    transactionHash: HashSelector
    transactionIndex: IntegerSelector
    transactionSigner: AddressSelector
    sender: AddressSelector
    receiver: AddressSelector
    currency: CosmosCurrencySelector
    value: AmountSelector
    type: StringSelector
    index: IntegerSelector
    senders: AddressSelector
    typeTransfer: BooleanSelector
    any: [CosmosTransferFilter!]
    options: QueryOptions
  ): [CosmosTransfers!]
}

"""
Address detailed information for Cosmos network
"""
type CosmosAddressInfo {
  """
  Address
  """
  address: String

  """
  Annotations ( tags ), if exists
  """
  annotation: String

  """
  Native currency balance
  """
  balance(in: BaseCurrencyEnum): Float

  """
  Tokens Info
  """
  tokensInfo: [CosmosTokensInfo!]
}

"""
Attribute in Cosmos blockchain
"""
type CosmosAttribute {
  any(of: CosmosAttributesMeasurable!): String

  """
  Attribute
  """
  attribute: String

  """
  Block info where transaction included
  """
  block: CosmosBlockDimension
  count(
    uniq: CosmosAttributeUniq
    date: DateSelector
    time: DateTimeSelector
    blockHeight: BlockSelector
    blockHash: HashSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSigner: StringSelector
    messageType: StringSelector
    messageIndex: IntegerSelector
    success: BooleanSelector
    senders: StringSelector
    eventType: StringSelector
    attribute: StringSelector
    value: StringSelector
    valueIndex: IntegerSelector
  ): Int
  countBigInt(
    uniq: CosmosAttributeUniq
    date: DateSelector
    time: DateTimeSelector
    blockHeight: BlockSelector
    blockHash: HashSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSigner: StringSelector
    messageType: StringSelector
    messageIndex: IntegerSelector
    success: BooleanSelector
    senders: StringSelector
    eventType: StringSelector
    attribute: StringSelector
    value: StringSelector
    valueIndex: IntegerSelector
  ): BigInt

  """
  The date this transaction was created
  """
  date: Date

  """
  Type of the attribute
  """
  eventType: String
  expression(get: String!): DecimalNumber
  maximum(
    of: CosmosAttributesMeasurable!
    get: CosmosAttributesMeasurable
  ): String

  """
  Message info
  """
  message: CosmosMessageDimension
  minimum(
    of: CosmosAttributesMeasurable!
    get: CosmosAttributesMeasurable
  ): String

  """
  Transaction info where message included
  """
  transaction: CosmosTransactionDimension

  """
  Attribute value
  """
  value: String

  """
  Index of attribute
  """
  valueIndex: Int!
}

input CosmosAttributeFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHeight: BlockSelector
  blockHash: HashSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSigner: StringSelector
  messageType: StringSelector
  messageIndex: IntegerSelector
  success: BooleanSelector
  senders: StringSelector
  eventType: StringSelector
  attribute: StringSelector
  value: StringSelector
  valueIndex: IntegerSelector
}

enum CosmosAttributesMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Number of block in the blockhains
  """
  block

  """
  Hash of the block
  """
  blockHash

  """
  Index of the transaction in block
  """
  transactionIndex

  """
  Hash of the transaction
  """
  transactionHash

  """
  Transaction Signer
  """
  transactionSigner

  """
  Type of message
  """
  messageType

  """
  Message index in transaction
  """
  messageIndex

  """
  Message success
  """
  messageSuccess

  """
  Message senders
  """
  messageSenders

  """
  Type of attr
  """
  eventType

  """
  attribute
  """
  attribute

  """
  attributeValue
  """
  value

  """
  valueIndex
  """
  valueIndex
}

enum CosmosAttributeUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique blocks
  """
  blocks

  """
  Unique block hashes
  """
  blockHashes

  """
  Unique transaction indices
  """
  transactionIndices

  """
  Unique transaction signers
  """
  transactionSigners

  """
  Unique transaction hashes
  """
  transactionHashes

  """
  Unique message types
  """
  messageTypes

  """
  Unique message indices
  """
  messageIndices

  """
  Unique message senders
  """
  messageSenders

  """
  Unique event types
  """
  eventTypes

  """
  Unique attributes
  """
  attributes

  """
  Unique values
  """
  values

  """
  Unique value indices
  """
  valueIndices
}

"""
Block
"""
type CosmosBlock {
  any(of: CosmosBlockMeasurable!): String
  count(
    uniq: CosmosBlockUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    proposer: AddressSelector
  ): Int
  countBigInt(
    uniq: CosmosBlockUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    proposer: AddressSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Block Hash
  """
  hash: String

  """
  Block Header
  """
  header: String

  """
  Block number (height) in blockchain
  """
  height: Int!
  maximum(of: CosmosBlockMeasurable!, get: CosmosBlockMeasurable): String

  """
  Block Metadata
  """
  metadata: String
  minimum(of: CosmosBlockMeasurable!, get: CosmosBlockMeasurable): String

  """
  Proposer Address
  """
  proposer: Address

  """
  Block timestamp
  """
  timestamp: DateTime
}

"""
Information about block
"""
type CosmosBlockDimension {
  """
  Block Hash
  """
  hash: String

  """
  Block number (height) in blockchain
  """
  height: Int!

  """
  Block timestamp
  """
  timestamp: DateTime
}

enum CosmosBlockMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  height

  """
  Proposer
  """
  proposer

  """
  Block hash
  """
  hash
}

input CosmosBlocksFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  hash: HashSelector
  proposer: AddressSelector
}

enum CosmosBlockUniq {
  """
  Unique date count
  """
  dates

  """
  Unique timestamps count
  """
  times

  """
  Number of block in the blockchains
  """
  blocks

  """
  Block proposer
  """
  proposers

  """
  Block Hash
  """
  hashes
}

"""
Coinpath
"""
type CosmosCoinpath {
  """
  Summary of transfered value
  """
  amount(in: BaseCurrencyEnum): Float
  any(of: CosmosCoinpathMeasurable!): String

  """
  Block where transaction is included
  """
  block: Block

  """
  Count of transfers
  """
  count: Int

  """
  Count of transfers
  """
  countBigInt: BigInt

  """
  Currency of transfer
  """
  currency: Currency

  """
  1-based hop depth of the graph
  """
  depth: Int
  maximum(of: CosmosCoinpathMeasurable!, get: CosmosCoinpathMeasurable): String
  minimum(of: CosmosCoinpathMeasurable!, get: CosmosCoinpathMeasurable): String

  """
  Receiver address
  """
  receiver: Address

  """
  Sender address
  """
  sender: Address

  """
  Message of transfer happened
  """
  transaction: TransactionHashValue
}

enum CosmosCoinpathMeasurable {
  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  transaction_hash

  """
  Sender
  """
  sender

  """
  Receiver
  """
  receiver

  """
  Depth
  """
  depth
}

"""
Currency selector in Cosmos blockchain
"""
input CosmosCurrencySelector {
  """
  Currency is
  """
  is: String

  """
  Currency not
  """
  not: String

  """
  Currency in the list
  """
  in: [String!]

  """
  Currency not in the list
  """
  notIn: [String!]
}

"""
Message in Cosmos blockchain
"""
type CosmosMessage {
  any(of: CosmosMessageMeasurable!): String

  """
  Block info where transaction included
  """
  block: CosmosBlockDimension
  count(
    uniq: CosmosMessageUniq
    date: DateSelector
    blockHeight: BlockSelector
    blockHash: HashSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSigner: AddressSelector
    type: StringSelector
    index: IntegerSelector
    success: BooleanSelector
    senders: StringSelector
  ): Int
  countBigInt(
    uniq: CosmosMessageUniq
    date: DateSelector
    blockHeight: BlockSelector
    blockHash: HashSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSigner: AddressSelector
    type: StringSelector
    index: IntegerSelector
    success: BooleanSelector
    senders: StringSelector
  ): BigInt

  """
  The date this transaction was created
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Index in tx
  """
  index: Int!

  """
  Body of message
  """
  json: String
  maximum(of: CosmosMessageMeasurable!, get: CosmosMessageMeasurable): String
  minimum(of: CosmosMessageMeasurable!, get: CosmosMessageMeasurable): String

  """
  Message sender(s)
  """
  senders: String

  """
  Succeeded or failed
  """
  success: Boolean

  """
  Transaction info where message included
  """
  transaction: CosmosTransactionDimension

  """
  Type of the message
  """
  type: String
}

"""
Information about message
"""
type CosmosMessageDimension {
  """
  Index in tx
  """
  index: Int!

  """
  Message sender(s)
  """
  senders: String

  """
  Succeeded or failed
  """
  success: Boolean

  """
  Type of the message
  """
  type: String
}

input CosmosMessageFilter {
  date: DateSelector
  blockHeight: BlockSelector
  blockHash: HashSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSigner: AddressSelector
  type: StringSelector
  index: IntegerSelector
  success: BooleanSelector
  senders: StringSelector
}

enum CosmosMessageMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Hash of the block
  """
  blockHash

  """
  Number of block in the blockhains
  """
  blockHeight

  """
  Index of the transaction
  """
  transactionIndex

  """
  Hash of the transaction
  """
  transactionHash

  """
  Transaction Signer
  """
  transactionSigner

  """
  Type of message
  """
  type

  """
  Message index in transaction
  """
  index

  """
  Message success
  """
  success

  """
  Message senders
  """
  senders

  """
  Message json
  """
  json
}

enum CosmosMessageUniq {
  """
  Uniq date
  """
  dates

  """
  Uniq blocks
  """
  blocks

  """
  Uniq transaction signers
  """
  transactionSigners

  """
  Uniq transaction hashes
  """
  transactionHashes

  """
  Uniq transaction indices
  """
  transactionIndices

  """
  Uniq types
  """
  types

  """
  Uniq senders
  """
  senders
}

enum CosmosNetwork {
  """
  Cosmos Hub Network
  """
  cosmoshub

  """
  Heimdall (Matic Verification Network)
  """
  heimdall

  """
  Crypto.org Mainnet
  """
  crypto_mainnet

  """
  Crypto.org Croeseid Testnet
  """
  crypto_testnet

  """
  Terra Mainnet
  """
  terra
}

"""
Tokens Info
"""
type CosmosTokensInfo {
  """
  Token Balance
  """
  balance: Float

  """
  Denom
  """
  denom: String
}

"""
Transaction in Cosmos blockchain
"""
type CosmosTransaction {
  any(of: CosmosTransactionMeasurable!): String

  """
  Block info where transaction included
  """
  block: CosmosBlockDimension

  """
  code
  """
  code: Int
  count(
    uniq: CosmosTransactionUniq
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    hash: HashSelector
    type: StringSelector
    index: IntegerSelector
    gasUsed: IntegerSelector
    gasWanted: IntegerSelector
    signer: AddressSelector
    memo: StringSelector
    fee: AmountSelector
    code: IntegerSelector
    success: BooleanSelector
  ): Int
  countBigInt(
    uniq: CosmosTransactionUniq
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    hash: HashSelector
    type: StringSelector
    index: IntegerSelector
    gasUsed: IntegerSelector
    gasWanted: IntegerSelector
    signer: AddressSelector
    memo: StringSelector
    fee: AmountSelector
    code: IntegerSelector
    success: BooleanSelector
  ): BigInt

  """
  The date this transaction was created
  """
  date: Date
  expression(get: String!): DecimalNumber
  fee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    hash: HashSelector
    type: StringSelector
    index: IntegerSelector
    gasUsed: IntegerSelector
    gasWanted: IntegerSelector
    signer: AddressSelector
    memo: StringSelector
    fee: AmountSelector
    code: IntegerSelector
    success: BooleanSelector
  ): Float

  """
  Currency of transfer
  """
  feeCurrency: Currency
  feeDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    hash: HashSelector
    type: StringSelector
    index: IntegerSelector
    gasUsed: IntegerSelector
    gasWanted: IntegerSelector
    signer: AddressSelector
    memo: StringSelector
    fee: AmountSelector
    code: IntegerSelector
    success: BooleanSelector
  ): DecimalNumberAsDiv

  """
  Gas Used
  """
  gasUsed(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    hash: HashSelector
    type: StringSelector
    index: IntegerSelector
    gasUsed: IntegerSelector
    gasWanted: IntegerSelector
    signer: AddressSelector
    memo: StringSelector
    fee: AmountSelector
    code: IntegerSelector
    success: BooleanSelector
  ): BigInt!

  """
  Gas Wanted
  """
  gasWanted(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    hash: HashSelector
    type: StringSelector
    index: IntegerSelector
    gasUsed: IntegerSelector
    gasWanted: IntegerSelector
    signer: AddressSelector
    memo: StringSelector
    fee: AmountSelector
    code: IntegerSelector
    success: BooleanSelector
  ): BigInt!

  """
  Hash of the transactions
  """
  hash: String

  """
  Index of the transaction in block
  """
  index: Int
  maximum(
    of: CosmosTransactionMeasurable!
    get: CosmosTransactionMeasurable
  ): String

  """
  Memo
  """
  memo: String
  minimum(
    of: CosmosTransactionMeasurable!
    get: CosmosTransactionMeasurable
  ): String

  """
  Raw Tx
  """
  rawTx: String

  """
  Transaction Signer
  """
  signer: Address

  """
  Succeeded or failed
  """
  success: Boolean

  """
  Type of the transactions
  """
  type: String
}

"""
Information about transaction
"""
type CosmosTransactionDimension {
  """
  Hash of the transactions
  """
  hash: String

  """
  Index of the transaction in block
  """
  index: Int

  """
  Transaction Signer
  """
  signer: Address
}

input CosmosTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  blockHeight: BlockSelector
  hash: HashSelector
  type: StringSelector
  index: IntegerSelector
  gasUsed: IntegerSelector
  gasWanted: IntegerSelector
  signer: AddressSelector
  memo: StringSelector
  fee: AmountSelector
  code: IntegerSelector
  success: BooleanSelector
}

enum CosmosTransactionMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Hash of the block
  """
  block_hash

  """
  Number of block in the blockhains
  """
  block_height

  """
  Hash of the transaction
  """
  hash

  """
  Type of the transaction
  """
  type

  """
  Transaction Signer
  """
  signer

  """
  Transaction Fee
  """
  fee

  """
  Transaction Code
  """
  code

  """
  Transaction Memo
  """
  memo

  """
  Transaction Index
  """
  index

  """
  Raw Transaction
  """
  rawTx
}

enum CosmosTransactionUniq {
  """
  Unique date count
  """
  dates

  """
  Unique time
  """
  times

  """
  Unique blocks
  """
  blocks

  """
  Unique signers
  """
  signers

  """
  Unique hashes
  """
  hashes

  """
  Unique timecodes
  """
  codes

  """
  Unique types
  """
  types

  """
  Unique memos
  """
  memos

  """
  Unique indices
  """
  indices
}

input CosmosTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  blockHash: HashSelector
  transactionHash: HashSelector
  transactionIndex: IntegerSelector
  transactionSigner: AddressSelector
  sender: AddressSelector
  receiver: AddressSelector
  currency: CosmosCurrencySelector
  value: AmountSelector
  type: StringSelector
  index: IntegerSelector
  senders: AddressSelector
  typeTransfer: BooleanSelector
}

"""
Transfers in Cosmos  blockchain
"""
type CosmosTransfers {
  any(of: CosmosTransfersMeasurable!): String

  """
  Block info where transaction included
  """
  block: CosmosBlockDimension
  count(
    uniq: CosmosTransferUniq
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    blockHash: HashSelector
    transactionHash: HashSelector
    transactionIndex: IntegerSelector
    transactionSigner: AddressSelector
    sender: AddressSelector
    receiver: AddressSelector
    currency: CosmosCurrencySelector
    value: AmountSelector
    type: StringSelector
    index: IntegerSelector
    senders: AddressSelector
    typeTransfer: BooleanSelector
  ): Int
  countBigInt(
    uniq: CosmosTransferUniq
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    blockHash: HashSelector
    transactionHash: HashSelector
    transactionIndex: IntegerSelector
    transactionSigner: AddressSelector
    sender: AddressSelector
    receiver: AddressSelector
    currency: CosmosCurrencySelector
    value: AmountSelector
    type: StringSelector
    index: IntegerSelector
    senders: AddressSelector
    typeTransfer: BooleanSelector
  ): BigInt

  """
  Currency of the transfer
  """
  currency: Currency

  """
  The date this transaction was created
  """
  date: Date

  """
  Is delegated
  """
  delegated: Boolean
  expression(get: String!): DecimalNumber
  maximum(
    of: CosmosTransfersMeasurable!
    get: CosmosTransfersMeasurable
  ): String

  """
  Index in tx
  """
  messageIndex: Int!

  """
  Type of the message
  """
  messageType: String
  minimum(
    of: CosmosTransfersMeasurable!
    get: CosmosTransfersMeasurable
  ): String

  """
  Transfer receiver
  """
  receiver: Address

  """
  Transfer sender
  """
  sender: Address

  """
  Message sender(s)
  """
  senders: String

  """
  Transaction info where message included
  """
  transaction: CosmosTransactionDimension

  """
  Type of the Transfer
  """
  type: String
  value(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    blockHash: HashSelector
    transactionHash: HashSelector
    transactionIndex: IntegerSelector
    transactionSigner: AddressSelector
    sender: AddressSelector
    receiver: AddressSelector
    currency: CosmosCurrencySelector
    value: AmountSelector
    type: StringSelector
    index: IntegerSelector
    senders: AddressSelector
    typeTransfer: BooleanSelector
  ): Float
  valueDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    blockHash: HashSelector
    transactionHash: HashSelector
    transactionIndex: IntegerSelector
    transactionSigner: AddressSelector
    sender: AddressSelector
    receiver: AddressSelector
    currency: CosmosCurrencySelector
    value: AmountSelector
    type: StringSelector
    index: IntegerSelector
    senders: AddressSelector
    typeTransfer: BooleanSelector
  ): DecimalNumberAsDiv
}

enum CosmosTransfersMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Number of block in the blockhains
  """
  height

  """
  Hash of the block
  """
  blockHash

  """
  Index of the transaction
  """
  transactionIndex

  """
  Hash of the transaction
  """
  transactionHash

  """
  Transaction Signer
  """
  transactionSigner

  """
  Transfer From
  """
  sender

  """
  Transfer To
  """
  receiver

  """
  Transfer value
  """
  value

  """
  Type of transfer
  """
  type

  """
  Message index in transaction
  """
  messageIndex

  """
  Type of message
  """
  messageType

  """
  Message senders
  """
  senders

  """
  Currency Symbol
  """
  currency_symbol

  """
  Currency Address
  """
  currency_address

  """
  Token Type
  """
  token_type

  """
  Token ID
  """
  token_id
}

enum CosmosTransferUniq {
  """
  Unique times
  """
  times

  """
  Unique dates
  """
  dates

  """
  Unique blocks
  """
  blocks

  """
  Unique block hashes
  """
  blockHashes

  """
  Unique transaction indices
  """
  transactionIndices

  """
  Unique transaction hashes
  """
  transactionHashes

  """
  Unique transaction signers
  """
  transactionSigners

  """
  Unique senders (field sender)
  """
  sender

  """
  Unique time
  """
  receiver

  """
  Unique currencies
  """
  currencies

  """
  Unique transfer types
  """
  types

  """
  Unique message indices
  """
  messageIndices

  """
  Unique message types
  """
  messageTypes

  """
  Unique senders (field senders)
  """
  senders
}

"""
Crypto currency ( token, coin, currency )
"""
type Currency {
  """
  Token Smart Contract Address
  """
  address: String

  """
  Decimals
  """
  decimals: Int!

  """
  Currency name
  """
  name: String

  """
  Currency symbol
  """
  symbol: String!

  """
  Token ID
  """
  tokenId: String

  """
  Token Type
  """
  tokenType: String
}

"""
Currency selector
"""
input CurrencySelector {
  """
  Currency is
  """
  is: String

  """
  Currency not
  """
  not: String

  """
  Currency in the list
  """
  in: [String!]

  """
  Currency not in the list
  """
  notIn: [String!]
}

"""
Instruction Data
"""
type Data {
  base58: String!
  hex: String!
}

"""
Date
"""
type Date {
  """
  String date representation with default format as YYYY-MM-DD
  """
  date(format: String): String!

  """
  Day of month (1-31)
  """
  dayOfMonth: Int!

  """
  Day of week  (Monday is 1, and Sunday is 7)
  """
  dayOfWeek: Int!

  """
  Month number (1-12)
  """
  month: Int!

  """
  Returns start of date interval ,
      date representation with default format as YYYY-MM-DD. Example is start of interval for 3 weeks each,
    starting on wednesdays will read as: 'startOfInterval(unit: week, interval: 3, offset: 2)'
  """
  startOfInterval(
    format: String
    interval: Int
    offset: Int
    unit: DateInterval!
  ): String!

  """
  Year number
  """
  year: Int!
}

enum DateInterval {
  """
  Year
  """
  year

  """
  Month
  """
  month

  """
  Week
  """
  week

  """
  Day
  """
  day
}

"""
Selecting the date in a range, list or just date
"""
input DateSelector {
  """
  Since date
  """
  since: ISO8601DateTime

  """
  Till date
  """
  till: ISO8601DateTime

  """
  Range of dates
  """
  between: [ISO8601DateTime!]

  """
  Before date
  """
  before: ISO8601DateTime

  """
  After date
  """
  after: ISO8601DateTime

  """
  In dates
  """
  in: [ISO8601DateTime!]

  """
  Not in dates
  """
  notIn: [ISO8601DateTime!]

  """
  Date equals
  """
  is: ISO8601DateTime

  """
  Date not equals
  """
  not: ISO8601DateTime
}

"""
Date and Time
"""
type DateTime {
  """
  Day of month (1-31)
  """
  dayOfMonth: Int!

  """
  Day of week  (Monday is 1, and Sunday is 7)
  """
  dayOfWeek: Int!

  """
  Hour (0-23)
  """
  hour: Int!

  """
  ISO8601 date time such as '2020-03-02T13:30:41+00:00'
  """
  iso8601: ISO8601DateTime!

  """
  Minute (0-59)
  """
  minute: Int!

  """
  Month number (1-12)
  """
  month: Int!

  """
  Second (0-59)
  """
  second: Int!

  """
  String date representation with default format as YYYY-MM-DD
  """
  time(format: String): String!

  """
  Unix timestamp
  """
  unixtime: Int!

  """
  Year number
  """
  year: Int!
}

"""
Selecting the time in a range, list or just time
"""
input DateTimeSelector {
  """
  Since time
  """
  since: ISO8601DateTime

  """
  Till time
  """
  till: ISO8601DateTime

  """
  Range of time
  """
  between: [ISO8601DateTime!]

  """
  Before time
  """
  before: ISO8601DateTime

  """
  After time
  """
  after: ISO8601DateTime

  """
  In times
  """
  in: [ISO8601DateTime!]

  """
  Not in times
  """
  notIn: [ISO8601DateTime!]

  """
  Time equals
  """
  is: ISO8601DateTime

  """
  Time not equals
  """
  not: ISO8601DateTime
}

"""
Represents fractional signed whole numeric values.
Since the value may exceed the size of a 32-bit integer, it's encoded as a string.
"""
scalar DecimalNumber

"""
Represents fractional signed whole numeric values.
Since the value may exceed the size of a 32-bit integer, it's encoded as a string.
"""
scalar DecimalNumberAsDiv

enum DiemNetwork {
  """
  Diem Testnet
  """
  diem_testnet

  """
  Libra Testnet
  """
  libra_testnet
}

"""
Elrond Chain
"""
type Elrond {
  """
  Basic information about address
  """
  address(address: [AddressSelectorIn!]!): [ElrondAddressInfoWithBalance!]!

  """
  Information about validators of the block
  """
  blockValidators(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    previousBlockHash: HashSelector
    blockHash: HashSelector
    shard: BigIntIdSelector
    proposer: HashSelector
    epoch: IntegerSelector
    blockNonce: IntegerSelector
    round: IntegerSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    publicKeyBitmap: StringSelector
    stateRootHash: HashSelector
    transactionCount: IntegerSelector
    validator: HashSelector
    any: [ElrondBlockValidatorFilter!]
    options: QueryOptions
  ): [ElrondBlockValidator!]

  """
  Information about blocks
  """
  blocks(
    date: DateSelector
    time: DateTimeSelector
    hash: HashSelector
    height: BlockSelector
    previousBlockHash: HashSelector
    shard: BigIntIdSelector
    proposer: HashSelector
    epoch: IntegerSelector
    nonce: IntegerSelector
    round: IntegerSelector
    publicKeyBitmap: StringSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    stateRootHash: IntegerSelector
    transactionCount: IntegerSelector
    any: [ElrondBlockFilter!]
    options: QueryOptions
  ): [ElrondBlock!]

  """
  Information about calls
  """
  callResults(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    previousBlockHash: HashSelector
    shard: BigIntIdSelector
    proposer: HashSelector
    epoch: IntegerSelector
    blockNonce: IntegerSelector
    round: IntegerSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    publicKeyBitmap: StringSelector
    stateRootHash: HashSelector
    transactionCount: IntegerSelector
    miniblockHash: HashSelector
    miniblockReceiverBlockHash: HashSelector
    miniblockReceiverShard: BigIntIdSelector
    type: StringSelector
    txHash: HashSelector
    index: IntegerSelector
    nonce: IntegerSelector
    txReceiver: HashSelector
    txReceiverShard: BigIntIdSelector
    txSender: HashSelector
    txSenderShard: BigIntIdSelector
    signature: HashSelector
    status: StringSelector
    data: StringSelector
    dataOperation: StringSelector
    callResultIndex: IntegerSelector
    callResultType: StringSelector
    callResultData: StringSelector
    callResultDataOperation: StringSelector
    callResultHash: HashSelector
    callResultNonce: IntegerSelector
    previousTxHash: HashSelector
    callResultReceiver: HashSelector
    callResultSender: HashSelector
    returnMessage: StringSelector
    relayed: StringSelector
    callResultValue: FloatSelector
    callResultRelayedValue: FloatSelector
    callResultGasPrice: FloatSelector
    callResultGasLimit: FloatSelector
    any: [ElrondCallResultFilter!]
    options: QueryOptions
  ): [ElrondCallResult!]

  """
  Information about Event
  """
  events(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    previousBlockHash: HashSelector
    shard: BigIntIdSelector
    proposer: HashSelector
    epoch: IntegerSelector
    blockNonce: IntegerSelector
    round: IntegerSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    publicKeyBitmap: StringSelector
    stateRootHash: HashSelector
    transactionCount: IntegerSelector
    miniblockHash: HashSelector
    miniblockReceiverBlockHash: HashSelector
    miniblockReceiverShard: BigIntIdSelector
    type: StringSelector
    txHash: HashSelector
    index: IntegerSelector
    nonce: IntegerSelector
    txReceiver: HashSelector
    txReceiverShard: BigIntIdSelector
    txSender: HashSelector
    txSenderShard: BigIntIdSelector
    signature: HashSelector
    status: StringSelector
    data: StringSelector
    dataOperation: StringSelector
    txFunction: StringSelector
    eventIndex: IntegerSelector
    callResultPath: StringSelector
    eventType: EventTypeSelector
    address: AddressSelector
    identifier: StringSelector
    any: [ElrondEventFilter!]
    options: QueryOptions
  ): [ElrondEvent!]

  """
  Information about miniblocks
  """
  miniblocks(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    previousBlockHash: HashSelector
    blockHash: HashSelector
    shard: BigIntIdSelector
    proposer: HashSelector
    epoch: IntegerSelector
    blockNonce: IntegerSelector
    round: IntegerSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    publicKeyBitmap: StringSelector
    stateRootHash: HashSelector
    transactionCount: IntegerSelector
    miniblockHash: HashSelector
    receiverBlockHash: HashSelector
    receiverShard: BigIntIdSelector
    type: StringSelector
    any: [ElrondMiniblockFilter!]
    options: QueryOptions
  ): [ElrondMiniblock!]

  """
  Information about notarized block
  """
  notarizedBlock(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    previousBlockHash: HashSelector
    blockHash: HashSelector
    shard: BigIntIdSelector
    proposer: HashSelector
    epoch: IntegerSelector
    blockNonce: IntegerSelector
    round: IntegerSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    publicKeyBitmap: StringSelector
    stateRootHash: HashSelector
    transactionCount: IntegerSelector
    notarizedBlockHash: HashSelector
    any: [ElrondNotarizedBlockFilter!]
    options: QueryOptions
  ): [ElrondNotarizedBlock!]

  """
  Information about Token Operations
  """
  operations(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    previousBlockHash: HashSelector
    shard: BigIntIdSelector
    proposer: HashSelector
    epoch: IntegerSelector
    blockNonce: IntegerSelector
    round: IntegerSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    publicKeyBitmap: StringSelector
    stateRootHash: HashSelector
    transactionCount: IntegerSelector
    miniblockHash: HashSelector
    miniblockReceiverBlockHash: HashSelector
    miniblockReceiverShard: BigIntIdSelector
    type: StringSelector
    txHash: HashSelector
    index: IntegerSelector
    nonce: IntegerSelector
    txReceiver: HashSelector
    txReceiverShard: BigIntIdSelector
    txSender: HashSelector
    txSenderShard: BigIntIdSelector
    signature: HashSelector
    status: StringSelector
    data: StringSelector
    dataOperation: StringSelector
    txFunction: StringSelector
    operationIndex: IntegerSelector
    operationAction: StringSelector
    operationType: StringSelector
    operationSender: AddressSelector
    operationReceiver: AddressSelector
    operationData: StringSelector
    any: [ElrondOperationFilter!]
    options: QueryOptions
  ): [ElrondOperation!]

  """
  Information about transactions
  """
  transactions(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    previousBlockHash: HashSelector
    blockHash: HashSelector
    shard: BigIntIdSelector
    proposer: HashSelector
    epoch: IntegerSelector
    blockNonce: IntegerSelector
    round: IntegerSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    publicKeyBitmap: StringSelector
    stateRootHash: HashSelector
    transactionCount: IntegerSelector
    miniblockHash: HashSelector
    miniblockReceiverBlockHash: HashSelector
    miniblockReceiverShard: BigIntIdSelector
    type: StringSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txNonce: IntegerSelector
    txReceiver: HashSelector
    txReceiverShard: BigIntIdSelector
    txSender: HashSelector
    txSenderShard: BigIntIdSelector
    signature: HashSelector
    status: StringSelector
    data: StringSelector
    dataOperation: StringSelector
    fee: FloatSelector
    gasUsed: FloatSelector
    gasLimit: FloatSelector
    gasPrice: FloatSelector
    txValue: FloatSelector
    function: StringSelector
    actionName: StringSelector
    actionCategory: StringSelector
    actionDescription: StringSelector
    any: [ElrondTransactionFilter!]
    options: QueryOptions
  ): [ElrondTransaction!]

  """
  Information about transactions
  """
  transfers(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    previousBlockHash: HashSelector
    blockHash: HashSelector
    shard: BigIntIdSelector
    proposer: HashSelector
    epoch: IntegerSelector
    blockNonce: IntegerSelector
    round: IntegerSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    publicKeyBitmap: StringSelector
    stateRootHash: HashSelector
    transactionCount: IntegerSelector
    miniblockHash: HashSelector
    miniblockReceiverBlockHash: HashSelector
    miniblockReceiverShard: BigIntIdSelector
    type: StringSelector
    txHash: HashSelector
    index: IntegerSelector
    nonce: IntegerSelector
    txReceiver: HashSelector
    txReceiverShard: BigIntIdSelector
    txSender: HashSelector
    txSenderShard: BigIntIdSelector
    signature: HashSelector
    status: StringSelector
    data: StringSelector
    dataOperation: StringSelector
    currency: CurrencySelector
    transferSender: AddressSelector
    transferReceiver: AddressSelector
    entityId: EntitySelector
    action: ActionSelector
    transferType: StringSelector
    esdtType: StringSelector
    any: [ElrondTransferFilter!]
    options: QueryOptions
  ): [ElrondTransfer!]
}

"""
Blockchain address hash
"""
type ElrondAddressHash {
  """
  String hex address representation
  """
  hex: String!
}

"""
Address detailed information for Elrond network
"""
type ElrondAddressInfoWithBalance {
  """
  Address
  """
  address: String

  """
  Annotations ( tags ), if exists
  """
  annotation: String

  """
  Native currency balance
  """
  balance(in: BaseCurrencyEnum): Float

  """
  Extra information abount address from node
  """
  extraInfo: ElrondExtraInfo

  """
  Staked EGLD
  """
  staking(in: BaseCurrencyEnum): Float

  """
  Tokens Info
  """
  tokensInfo: [ElrondTokensInfo!]
}

"""
Blocks in Elrond  blockchain
"""
type ElrondBlock {
  any(of: ElrondBlocksMeasureable!): String
  count(uniq: ElrondBlockUniq): Int
  countBigInt(uniq: ElrondBlockUniq): BigInt

  """
  The date this transaction was created
  """
  date: Date

  """
  Epoch
  """
  epoch: Int
  expression(get: String!): DecimalNumber

  """
  Hash of the the block
  """
  hash: String

  """
  Number of block in the blockchains
  """
  height: BigInt
  maximum(of: ElrondBlocksMeasureable!, get: ElrondBlocksMeasureable): String
  minimum(of: ElrondBlocksMeasureable!, get: ElrondBlocksMeasureable): String

  """
  Block Height
  """
  nonce: BigInt

  """
  The block hash of this block`s parent
  """
  previousBlockHash: String

  """
  Proposer block hash
  """
  proposer: ElrondAddressHash

  """
  Public Key Bitmap
  """
  publicKeyBitmap: String

  """
  Round
  """
  round: BigInt

  """
  Shard number of block
  """
  shard: String

  """
  Size
  """
  size: Int

  """
  Size Tx
  """
  sizeTxs: Int

  """
  State root hash
  """
  stateRootHash: String

  """
  The time this transaction was created
  """
  time: DateTime

  """
  Count of transactions in this block
  """
  transactionCount: BigInt
}

"""
Information about block
"""
type ElrondBlockDimension {
  """
  Epoch
  """
  epoch: Int

  """
  Hash of the block
  """
  hash: String

  """
  Number of block in the blockchains
  """
  height: BigInt

  """
  Block Height
  """
  nonce: BigInt

  """
  The block hash of this block`s parent
  """
  previousBlockHash: String

  """
  Proposer block hash
  """
  proposer: ElrondAddressHash

  """
  Public Key Bitmap
  """
  publicKeyBitmap: String

  """
  Round
  """
  round: BigInt

  """
  Shard number of block
  """
  shard: String

  """
  Size
  """
  size: Int

  """
  Size Tx
  """
  sizeTxs: Int

  """
  State root hash
  """
  stateRootHash: String

  """
  Count of transactions in this block
  """
  transactionCount: BigInt
}

input ElrondBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  hash: HashSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  nonce: IntegerSelector
  round: IntegerSelector
  publicKeyBitmap: StringSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  stateRootHash: IntegerSelector
  transactionCount: IntegerSelector
}

enum ElrondBlocksMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Hash of the the block
  """
  hash

  """
  Number of block in the blockhains
  """
  height

  """
  The block hash of this block`s parent
  """
  previous_block_hash

  """
  Shard number of block
  """
  shard

  """
  Block proposer
  """
  proposer

  """
  Block epoch
  """
  epoch

  """
  Block nonce
  """
  nonce

  """
  Block round
  """
  round

  """
  Block public key bitmap
  """
  public_key_bitmap

  """
  Block size
  """
  size

  """
  Block size txs
  """
  size_txs

  """
  State root hash
  """
  state_root_hash

  """
  Count of transactions in this block
  """
  transaction_count
}

enum ElrondBlockUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique Number of block in the blockchains
  """
  height

  """
  Unique Number of Shards in the blockchains
  """
  block_shard
}

"""
BlockValidators in Elrond  blockchain
"""
type ElrondBlockValidator {
  any(of: ElrondBlockValidatorsMeasureable!): String

  """
  Information about blocks notarized block
  """
  block(
    height: BlockSelector
    previousBlockHash: HashSelector
    blockHash: HashSelector
    shard: BigIntIdSelector
    proposer: HashSelector
    epoch: IntegerSelector
    blockNonce: IntegerSelector
    round: IntegerSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    publicKeyBitmap: StringSelector
    stateRootHash: HashSelector
    transactionCount: IntegerSelector
  ): ElrondBlockDimension
  count(uniq: ElrondBlockValidatorUniq): Int
  countBigInt(uniq: ElrondBlockValidatorUniq): BigInt

  """
  The date this transaction was created
  """
  date: Date
  maximum(
    of: ElrondBlockValidatorsMeasureable!
    get: ElrondBlockValidatorsMeasureable
  ): String
  minimum(
    of: ElrondBlockValidatorsMeasureable!
    get: ElrondBlockValidatorsMeasureable
  ): String

  """
  The time this transaction was created
  """
  time: DateTime

  """
  Hash of validator
  """
  validator: ElrondAddressHash
}

input ElrondBlockValidatorFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  blockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  blockNonce: IntegerSelector
  round: IntegerSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  publicKeyBitmap: StringSelector
  stateRootHash: HashSelector
  transactionCount: IntegerSelector
  validator: HashSelector
}

enum ElrondBlockValidatorsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Hash of the the block
  """
  hash

  """
  Number of block in the blockhains
  """
  height

  """
  The block hash of this block`s parent
  """
  previous_block_hash

  """
  Shard number of block
  """
  shard

  """
  Block proposer
  """
  proposer

  """
  Block epoch
  """
  epoch

  """
  Block nonce
  """
  nonce

  """
  Block round
  """
  round

  """
  Block public key bitmap
  """
  public_key_bitmap

  """
  Block size
  """
  size

  """
  Block size txs
  """
  size_txs

  """
  State root hash
  """
  state_root_hash

  """
  Count of transactions in this block
  """
  transaction_count

  """
  Hash of the validator
  """
  validator
}

enum ElrondBlockValidatorUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique Number of block in the blockchains
  """
  height

  """
  Unique number of validators
  """
  validators
}

"""
CallResults in Elrond blockchain
"""
type ElrondCallResult {
  any(of: ElrondCallResultsMeasureable!): String
  count(uniq: ElrondCallResultUniq): Int
  countBigInt(uniq: ElrondCallResultUniq): BigInt

  """
  Call result data
  """
  data(callResultData: StringSelector): String

  """
  Call result data operation
  """
  dataOperation(callResultDataOperation: StringSelector): String

  """
  The date this transaction was created
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Call result gas limit
  """
  gasLimit(callResultGasLimit: IntegerSelector): BigInt

  """
  Call result gas price
  """
  gasPrice(callResultGasPrice: IntegerSelector): BigInt

  """
  Hash of the call result
  """
  hash(callResultHash: HashSelector): String

  """
  Call result index
  """
  index(callResultIndex: IntegerSelector): Int
  maximum(
    of: ElrondCallResultsMeasureable!
    get: ElrondCallResultsMeasureable
  ): String

  """
  Information about calls miniblock
  """
  miniblock(
    miniblockHash: HashSelector
    miniblockReceiverBlockHash: HashSelector
    miniblockReceiverShard: BigIntIdSelector
    type: StringSelector
  ): MiniblockElrond
  minimum(
    of: ElrondCallResultsMeasureable!
    get: ElrondCallResultsMeasureable
  ): String

  """
  Nonce of the call result
  """
  nonce(callResultNonce: IntegerSelector): BigInt

  """
  Hash of the previous transaction
  """
  previousTxHash(previousTxHash: HashSelector): String

  """
  Call result receiver
  """
  receiver(callResultReceiver: HashSelector): Address

  """
  Call result relayed
  """
  relayed(relayed: StringSelector): String
  relayedValue(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    previousBlockHash: HashSelector
    shard: BigIntIdSelector
    proposer: HashSelector
    epoch: IntegerSelector
    blockNonce: IntegerSelector
    round: IntegerSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    publicKeyBitmap: StringSelector
    stateRootHash: HashSelector
    transactionCount: IntegerSelector
    miniblockHash: HashSelector
    miniblockReceiverBlockHash: HashSelector
    miniblockReceiverShard: BigIntIdSelector
    type: StringSelector
    txHash: HashSelector
    index: IntegerSelector
    nonce: IntegerSelector
    txReceiver: HashSelector
    txReceiverShard: BigIntIdSelector
    txSender: HashSelector
    txSenderShard: BigIntIdSelector
    signature: HashSelector
    status: StringSelector
    data: StringSelector
    dataOperation: StringSelector
    callResultIndex: IntegerSelector
    callResultType: StringSelector
    callResultData: StringSelector
    callResultDataOperation: StringSelector
    callResultHash: HashSelector
    callResultNonce: IntegerSelector
    previousTxHash: HashSelector
    callResultReceiver: HashSelector
    callResultSender: HashSelector
    returnMessage: StringSelector
    relayed: StringSelector
    callResultValue: FloatSelector
    callResultRelayedValue: FloatSelector
    callResultGasPrice: FloatSelector
    callResultGasLimit: FloatSelector
  ): Float

  """
  Call result return message
  """
  returnMessage(returnMessage: StringSelector): String

  """
  Call result sender
  """
  sender(callResultSender: HashSelector): Address

  """
  Information about calls block
  """
  senderBlock(
    height: BlockSelector
    previousBlockHash: HashSelector
    blockHash: HashSelector
    shard: BigIntIdSelector
    proposer: HashSelector
    epoch: IntegerSelector
    blockNonce: IntegerSelector
    round: IntegerSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    publicKeyBitmap: StringSelector
    stateRootHash: HashSelector
    transactionCount: IntegerSelector
  ): ElrondBlockDimension

  """
  The time this transaction was created
  """
  time: DateTime

  """
  Information about calls transaction
  """
  transaction(
    txHash: HashSelector
    index: IntegerSelector
    nonce: IntegerSelector
    txReceiver: HashSelector
    txReceiverShard: BigIntIdSelector
    txSender: HashSelector
    txSenderShard: BigIntIdSelector
    signature: HashSelector
    status: StringSelector
    data: StringSelector
    dataOperation: StringSelector
    txFunction: StringSelector
  ): TransactionElrond

  """
  Call result type
  """
  type(callResultType: StringSelector): String
  value(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    previousBlockHash: HashSelector
    shard: BigIntIdSelector
    proposer: HashSelector
    epoch: IntegerSelector
    blockNonce: IntegerSelector
    round: IntegerSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    publicKeyBitmap: StringSelector
    stateRootHash: HashSelector
    transactionCount: IntegerSelector
    miniblockHash: HashSelector
    miniblockReceiverBlockHash: HashSelector
    miniblockReceiverShard: BigIntIdSelector
    type: StringSelector
    txHash: HashSelector
    index: IntegerSelector
    nonce: IntegerSelector
    txReceiver: HashSelector
    txReceiverShard: BigIntIdSelector
    txSender: HashSelector
    txSenderShard: BigIntIdSelector
    signature: HashSelector
    status: StringSelector
    data: StringSelector
    dataOperation: StringSelector
    callResultIndex: IntegerSelector
    callResultType: StringSelector
    callResultData: StringSelector
    callResultDataOperation: StringSelector
    callResultHash: HashSelector
    callResultNonce: IntegerSelector
    previousTxHash: HashSelector
    callResultReceiver: HashSelector
    callResultSender: HashSelector
    returnMessage: StringSelector
    relayed: StringSelector
    callResultValue: FloatSelector
    callResultRelayedValue: FloatSelector
    callResultGasPrice: FloatSelector
    callResultGasLimit: FloatSelector
  ): Float
}

input ElrondCallResultFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  previousBlockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  blockNonce: IntegerSelector
  round: IntegerSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  publicKeyBitmap: StringSelector
  stateRootHash: HashSelector
  transactionCount: IntegerSelector
  miniblockHash: HashSelector
  miniblockReceiverBlockHash: HashSelector
  miniblockReceiverShard: BigIntIdSelector
  type: StringSelector
  txHash: HashSelector
  index: IntegerSelector
  nonce: IntegerSelector
  txReceiver: HashSelector
  txReceiverShard: BigIntIdSelector
  txSender: HashSelector
  txSenderShard: BigIntIdSelector
  signature: HashSelector
  status: StringSelector
  data: StringSelector
  dataOperation: StringSelector
  callResultIndex: IntegerSelector
  callResultType: StringSelector
  callResultData: StringSelector
  callResultDataOperation: StringSelector
  callResultHash: HashSelector
  callResultNonce: IntegerSelector
  previousTxHash: HashSelector
  callResultReceiver: HashSelector
  callResultSender: HashSelector
  returnMessage: StringSelector
  relayed: StringSelector
  callResultValue: FloatSelector
  callResultRelayedValue: FloatSelector
  callResultGasPrice: FloatSelector
  callResultGasLimit: FloatSelector
}

enum ElrondCallResultsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Hash of the the block
  """
  block_hash

  """
  Number of block in the blockhains
  """
  height

  """
  The block hash of this block`s parent
  """
  previous_block_hash

  """
  The block hash of this block`s parent
  """
  transaction_count

  """
  Hash of the miniblock
  """
  miniblock_hash

  """
  Hash of the miniblocks receiver block
  """
  miniblock_receiver_block_hash

  """
  Miniblock receiver shard
  """
  miniblock_receiver_shard

  """
  Type of miniblock
  """
  type

  """
  Transaction hash
  """
  tx_hash

  """
  Receiver hash
  """
  tx_receiver

  """
  Shard number of the receiver
  """
  tx_receiver_shard

  """
  Sender hash
  """
  tx_sender

  """
  Shard number of the sender
  """
  tx_sender_shard

  """
  Data
  """
  data

  """
  Gas Limit
  """
  gas_limit

  """
  Gas Price
  """
  gas_price

  """
  Gas Used
  """
  gas_used

  """
  Value
  """
  tx_value

  """
  Index of the call result
  """
  call_result_index

  """
  Data of the call result
  """
  call_result_data

  """
  Hash of the call result
  """
  call_result_hash

  """
  Previous transaction hash of the call result
  """
  previous_tx_hash

  """
  Receiver of the call result
  """
  call_result_receiver

  """
  Sender of the call result
  """
  call_result_sender
}

enum ElrondCallResultUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique Number of block in the blockchains
  """
  height

  """
  Unique Number of call results
  """
  index
}

"""
Events in Elrond blockchain
"""
type ElrondEvent {
  """
  Address
  """
  address: Address
  any(of: ElrondEventsMeasureable!): String

  """
  Call Result Path
  """
  callResultPath: String
  count(uniq: ElrondEventUniq): Int
  countBigInt(uniq: ElrondEventUniq): BigInt

  """
  The date this transaction was created
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Identifier
  """
  identifier: String

  """
  Index
  """
  index: Int
  maximum(of: ElrondEventsMeasureable!, get: ElrondEventsMeasureable): String

  """
  Information about miniblock
  """
  miniblock(
    miniblockHash: HashSelector
    miniblockReceiverBlockHash: HashSelector
    miniblockReceiverShard: BigIntIdSelector
    type: StringSelector
  ): MiniblockElrond
  minimum(of: ElrondEventsMeasureable!, get: ElrondEventsMeasureable): String

  """
  Information about calls block
  """
  senderBlock(
    height: BlockSelector
    previousBlockHash: HashSelector
    blockHash: HashSelector
    shard: BigIntIdSelector
    proposer: HashSelector
    epoch: IntegerSelector
    blockNonce: IntegerSelector
    round: IntegerSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    publicKeyBitmap: StringSelector
    stateRootHash: HashSelector
    transactionCount: IntegerSelector
  ): ElrondBlockDimension

  """
  The time this transaction was created
  """
  time: DateTime

  """
  Data
  """
  topics: [String!]

  """
  Information about transactions
  """
  transaction(
    txHash: HashSelector
    index: IntegerSelector
    nonce: IntegerSelector
    txReceiver: HashSelector
    txReceiverShard: BigIntIdSelector
    txSender: HashSelector
    txSenderShard: BigIntIdSelector
    signature: HashSelector
    status: StringSelector
    data: StringSelector
    dataOperation: StringSelector
    txFunction: StringSelector
  ): TransactionElrond

  """
  Type
  """
  type: String
  value(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    previousBlockHash: HashSelector
    shard: BigIntIdSelector
    proposer: HashSelector
    epoch: IntegerSelector
    blockNonce: IntegerSelector
    round: IntegerSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    publicKeyBitmap: StringSelector
    stateRootHash: HashSelector
    transactionCount: IntegerSelector
    miniblockHash: HashSelector
    miniblockReceiverBlockHash: HashSelector
    miniblockReceiverShard: BigIntIdSelector
    type: StringSelector
    txHash: HashSelector
    index: IntegerSelector
    nonce: IntegerSelector
    txReceiver: HashSelector
    txReceiverShard: BigIntIdSelector
    txSender: HashSelector
    txSenderShard: BigIntIdSelector
    signature: HashSelector
    status: StringSelector
    data: StringSelector
    dataOperation: StringSelector
    txFunction: StringSelector
    eventIndex: IntegerSelector
    callResultPath: StringSelector
    eventType: EventTypeSelector
    address: AddressSelector
    identifier: StringSelector
  ): Float
}

input ElrondEventFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  previousBlockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  blockNonce: IntegerSelector
  round: IntegerSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  publicKeyBitmap: StringSelector
  stateRootHash: HashSelector
  transactionCount: IntegerSelector
  miniblockHash: HashSelector
  miniblockReceiverBlockHash: HashSelector
  miniblockReceiverShard: BigIntIdSelector
  type: StringSelector
  txHash: HashSelector
  index: IntegerSelector
  nonce: IntegerSelector
  txReceiver: HashSelector
  txReceiverShard: BigIntIdSelector
  txSender: HashSelector
  txSenderShard: BigIntIdSelector
  signature: HashSelector
  status: StringSelector
  data: StringSelector
  dataOperation: StringSelector
  txFunction: StringSelector
  eventIndex: IntegerSelector
  callResultPath: StringSelector
  eventType: EventTypeSelector
  address: AddressSelector
  identifier: StringSelector
}

enum ElrondEventsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Hash of the the block
  """
  block_hash

  """
  Number of block in the blockhains
  """
  height

  """
  The block hash of this block`s parent
  """
  previous_block_hash

  """
  The block hash of this block`s parent
  """
  transaction_count

  """
  Hash of the miniblock
  """
  miniblock_hash

  """
  Hash of the miniblocks receiver block
  """
  miniblock_receiver_block_hash

  """
  Miniblock receiver shard
  """
  miniblock_receiver_shard

  """
  Type of miniblock
  """
  type

  """
  Transaction hash
  """
  tx_hash

  """
  Receiver hash
  """
  tx_receiver

  """
  Shard number of the receiver
  """
  tx_receiver_shard

  """
  Sender hash
  """
  tx_sender

  """
  Shard number of the sender
  """
  tx_sender_shard

  """
  Data
  """
  data

  """
  Gas Limit
  """
  gas_limit

  """
  Gas Price
  """
  gas_price

  """
  Gas Used
  """
  gas_used

  """
  Value
  """
  tx_value

  """
  Event Index
  """
  event_index

  """
  Call Result Path
  """
  call_result_path

  """
  Event Type
  """
  event_type

  """
  Address
  """
  address

  """
  Identifier
  """
  identifier
}

enum ElrondEventUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique count of block in the blockchains
  """
  height
}

type ElrondExtraInfo {
  """
  Root Hash
  """
  rootHash: String

  """
  Shard
  """
  shard: BigInt

  """
  Transactions Count
  """
  txCount: BigInt
}

"""
Miniblocks in Elrond  blockchain
"""
type ElrondMiniblock {
  any(of: ElrondMiniblocksMeasureable!): String
  count(uniq: ElrondMiniblockUniq): Int
  countBigInt(uniq: ElrondMiniblockUniq): BigInt

  """
  The date this transaction was created
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Miniblock hash
  """
  hash: String
  maximum(
    of: ElrondMiniblocksMeasureable!
    get: ElrondMiniblocksMeasureable
  ): String
  minimum(
    of: ElrondMiniblocksMeasureable!
    get: ElrondMiniblocksMeasureable
  ): String

  """
  Hash of the receiver block
  """
  receiverBlockHash: String

  """
  Number of the receiver shard
  """
  receiverShard: String

  """
  Information about miniblocks block
  """
  senderBlock: ElrondBlockDimension

  """
  The time this transaction was created
  """
  time: DateTime

  """
  Miniblock type
  """
  type: String
}

input ElrondMiniblockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  blockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  blockNonce: IntegerSelector
  round: IntegerSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  publicKeyBitmap: StringSelector
  stateRootHash: HashSelector
  transactionCount: IntegerSelector
  miniblockHash: HashSelector
  receiverBlockHash: HashSelector
  receiverShard: BigIntIdSelector
  type: StringSelector
}

enum ElrondMiniblocksMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Hash of the the block
  """
  block_hash

  """
  Number of block in the blockhains
  """
  height

  """
  The block hash of this block`s parent
  """
  previous_block_hash

  """
  Count of transactions
  """
  transaction_count

  """
  Hash of the miniblock
  """
  hash

  """
  Hash of the miniblocks receiver block
  """
  receiver_block_hash

  """
  Miniblock receiver shard
  """
  receiver_shard

  """
  Type of miniblock
  """
  type
}

enum ElrondMiniblockUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique Number of block in the blockchains
  """
  height
}

enum ElrondNetwork {
  """
  Elrond mainnet
  """
  elrond
}

"""
NotarizedBlocks in Elrond blockchain
"""
type ElrondNotarizedBlock {
  any(of: ElrondNotarizedBlocksMeasureable!): String

  """
  Information about blocks notarized block
  """
  block: ElrondBlockDimension
  count(uniq: ElrondNotarizedBlockUniq): Int
  countBigInt(uniq: ElrondNotarizedBlockUniq): BigInt

  """
  The date this transaction was created
  """
  date: Date
  expression(get: String!): DecimalNumber
  maximum(
    of: ElrondNotarizedBlocksMeasureable!
    get: ElrondNotarizedBlocksMeasureable
  ): String
  minimum(
    of: ElrondNotarizedBlocksMeasureable!
    get: ElrondNotarizedBlocksMeasureable
  ): String

  """
  Hash of the notarized block
  """
  notarizedBlockHash: String

  """
  The time this transaction was created
  """
  time: DateTime
}

input ElrondNotarizedBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  blockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  blockNonce: IntegerSelector
  round: IntegerSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  publicKeyBitmap: StringSelector
  stateRootHash: HashSelector
  transactionCount: IntegerSelector
  notarizedBlockHash: HashSelector
}

enum ElrondNotarizedBlocksMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Hash of the the block
  """
  hash

  """
  Number of block in the blockhains
  """
  height

  """
  The block hash of this block`s parent
  """
  previous_block_hash

  """
  Shard number of block
  """
  shard

  """
  Block proposer
  """
  proposer

  """
  Block epoch
  """
  epoch

  """
  Block nonce
  """
  nonce

  """
  Block round
  """
  round

  """
  Block public key bitmap
  """
  public_key_bitmap

  """
  Block size
  """
  size

  """
  Block size txs
  """
  size_txs

  """
  State root hash
  """
  state_root_hash

  """
  Count of transactions in this block
  """
  transaction_count

  """
  Notarized block hash
  """
  notarized_block_hash
}

enum ElrondNotarizedBlockUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique Number of block in the blockchains
  """
  height

  """
  Unique hash of notarized block
  """
  notarized_block_hash
}

"""
Operations in Elrond blockchain
"""
type ElrondOperation {
  """
  Action
  """
  action: String
  any(of: ElrondOperationsMeasureable!): String
  count(uniq: ElrondOperationUniq): Int
  countBigInt(uniq: ElrondOperationUniq): BigInt

  """
  Data
  """
  data: String

  """
  The date this transaction was created
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Index
  """
  index: Int
  maximum(
    of: ElrondOperationsMeasureable!
    get: ElrondOperationsMeasureable
  ): String

  """
  Message
  """
  message: String

  """
  Information about calls miniblock
  """
  miniblock(
    miniblockHash: HashSelector
    miniblockReceiverBlockHash: HashSelector
    miniblockReceiverShard: BigIntIdSelector
    type: StringSelector
  ): MiniblockElrond
  minimum(
    of: ElrondOperationsMeasureable!
    get: ElrondOperationsMeasureable
  ): String

  """
  Receiver
  """
  receiver: Address

  """
  Sender
  """
  sender: Address

  """
  Information about calls block
  """
  senderBlock(
    height: BlockSelector
    previousBlockHash: HashSelector
    blockHash: HashSelector
    shard: BigIntIdSelector
    proposer: HashSelector
    epoch: IntegerSelector
    blockNonce: IntegerSelector
    round: IntegerSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    publicKeyBitmap: StringSelector
    stateRootHash: HashSelector
    transactionCount: IntegerSelector
  ): ElrondBlockDimension

  """
  The time this transaction was created
  """
  time: DateTime

  """
  Information about calls transaction
  """
  transaction(
    txHash: HashSelector
    index: IntegerSelector
    nonce: IntegerSelector
    txReceiver: HashSelector
    txReceiverShard: BigIntIdSelector
    txSender: HashSelector
    txSenderShard: BigIntIdSelector
    signature: HashSelector
    status: StringSelector
    data: StringSelector
    dataOperation: StringSelector
    txFunction: StringSelector
  ): TransactionElrond

  """
  Type
  """
  type: String
}

input ElrondOperationFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  previousBlockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  blockNonce: IntegerSelector
  round: IntegerSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  publicKeyBitmap: StringSelector
  stateRootHash: HashSelector
  transactionCount: IntegerSelector
  miniblockHash: HashSelector
  miniblockReceiverBlockHash: HashSelector
  miniblockReceiverShard: BigIntIdSelector
  type: StringSelector
  txHash: HashSelector
  index: IntegerSelector
  nonce: IntegerSelector
  txReceiver: HashSelector
  txReceiverShard: BigIntIdSelector
  txSender: HashSelector
  txSenderShard: BigIntIdSelector
  signature: HashSelector
  status: StringSelector
  data: StringSelector
  dataOperation: StringSelector
  txFunction: StringSelector
  operationIndex: IntegerSelector
  operationAction: StringSelector
  operationType: StringSelector
  operationSender: AddressSelector
  operationReceiver: AddressSelector
  operationData: StringSelector
}

enum ElrondOperationsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Hash of the the block
  """
  block_hash

  """
  Number of block in the blockhains
  """
  height

  """
  The block hash of this block`s parent
  """
  previous_block_hash

  """
  The block hash of this block`s parent
  """
  transaction_count

  """
  Hash of the miniblock
  """
  miniblock_hash

  """
  Hash of the miniblocks receiver block
  """
  miniblock_receiver_block_hash

  """
  Miniblock receiver shard
  """
  miniblock_receiver_shard

  """
  Type of miniblock
  """
  type

  """
  Transaction hash
  """
  tx_hash

  """
  Receiver hash
  """
  tx_receiver

  """
  Shard number of the receiver
  """
  tx_receiver_shard

  """
  Sender hash
  """
  tx_sender

  """
  Shard number of the sender
  """
  tx_sender_shard

  """
  Data
  """
  data

  """
  Gas Limit
  """
  gas_limit

  """
  Gas Price
  """
  gas_price

  """
  Gas Used
  """
  gas_used

  """
  Value
  """
  tx_value

  """
  Operation Index
  """
  operation_index

  """
  Operation Action
  """
  operation_action

  """
  Operation type
  """
  operation_type

  """
  Operation sender
  """
  operation_sender

  """
  Operation receiver
  """
  operation_receiver

  """
  Operation data
  """
  operation_data

  """
  Operation message
  """
  operation_message
}

enum ElrondOperationUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique count of block in the blockchains
  """
  height

  """
  Unique count of operations
  """
  operations
}

"""
Tokens Info
"""
type ElrondTokensInfo {
  """
  Token Balance
  """
  balance: Float

  """
  Currency Info
  """
  currency: Currency
}

"""
Transactions in Elrond blockchain
"""
type ElrondTransaction {
  """
  Transaction Action
  """
  action: ElrondTransactionAction
  any(of: ElrondTransactionsMeasureable!): String
  count(uniq: ElrondTransactionUniq): Int
  countBigInt(uniq: ElrondTransactionUniq): BigInt

  """
  Data
  """
  data: String

  """
  Data operation
  """
  dataOperation: String

  """
  The date this transaction was created
  """
  date: Date
  expression(get: String!): DecimalNumber
  fee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    previousBlockHash: HashSelector
    blockHash: HashSelector
    shard: BigIntIdSelector
    proposer: HashSelector
    epoch: IntegerSelector
    blockNonce: IntegerSelector
    round: IntegerSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    publicKeyBitmap: StringSelector
    stateRootHash: HashSelector
    transactionCount: IntegerSelector
    miniblockHash: HashSelector
    miniblockReceiverBlockHash: HashSelector
    miniblockReceiverShard: BigIntIdSelector
    type: StringSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txNonce: IntegerSelector
    txReceiver: HashSelector
    txReceiverShard: BigIntIdSelector
    txSender: HashSelector
    txSenderShard: BigIntIdSelector
    signature: HashSelector
    status: StringSelector
    data: StringSelector
    dataOperation: StringSelector
    fee: FloatSelector
    gasUsed: FloatSelector
    gasLimit: FloatSelector
    gasPrice: FloatSelector
    txValue: FloatSelector
    function: StringSelector
    actionName: StringSelector
    actionCategory: StringSelector
    actionDescription: StringSelector
  ): Float

  """
  Tx function
  """
  function: String

  """
  Number of gas limit
  """
  gasLimit: BigInt

  """
  Number of gas price
  """
  gasPrice: BigInt

  """
  Number of gas used
  """
  gasUsed: BigInt

  """
  Transaction hash
  """
  hash: String

  """
  Transaction index
  """
  index: Int
  maximum(
    of: ElrondTransactionsMeasureable!
    get: ElrondTransactionsMeasureable
  ): String

  """
  Information about transactions miniblock
  """
  miniblock: MiniblockElrond
  minimum(
    of: ElrondTransactionsMeasureable!
    get: ElrondTransactionsMeasureable
  ): String

  """
  Transaction nonce
  """
  nonce: Int

  """
  TX  receiver
  """
  receiver: Address

  """
  Shard number of receiver
  """
  receiverShard: BigInt

  """
  Hash of the sender
  """
  sender: Address

  """
  Information about transactions block
  """
  senderBlock: ElrondBlockDimension

  """
  Shard number of sender
  """
  senderShard: BigInt

  """
  Signature
  """
  signature: String

  """
  Tx Status
  """
  status: String

  """
  The time this transaction was created
  """
  time: DateTime
  value(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    previousBlockHash: HashSelector
    blockHash: HashSelector
    shard: BigIntIdSelector
    proposer: HashSelector
    epoch: IntegerSelector
    blockNonce: IntegerSelector
    round: IntegerSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    publicKeyBitmap: StringSelector
    stateRootHash: HashSelector
    transactionCount: IntegerSelector
    miniblockHash: HashSelector
    miniblockReceiverBlockHash: HashSelector
    miniblockReceiverShard: BigIntIdSelector
    type: StringSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txNonce: IntegerSelector
    txReceiver: HashSelector
    txReceiverShard: BigIntIdSelector
    txSender: HashSelector
    txSenderShard: BigIntIdSelector
    signature: HashSelector
    status: StringSelector
    data: StringSelector
    dataOperation: StringSelector
    fee: FloatSelector
    gasUsed: FloatSelector
    gasLimit: FloatSelector
    gasPrice: FloatSelector
    txValue: FloatSelector
    function: StringSelector
    actionName: StringSelector
    actionCategory: StringSelector
    actionDescription: StringSelector
  ): Float
}

"""
Action of transction information
"""
type ElrondTransactionAction {
  """
  Category
  """
  category: String

  """
  Description
  """
  description: String

  """
  Name
  """
  name: String
}

input ElrondTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  blockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  blockNonce: IntegerSelector
  round: IntegerSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  publicKeyBitmap: StringSelector
  stateRootHash: HashSelector
  transactionCount: IntegerSelector
  miniblockHash: HashSelector
  miniblockReceiverBlockHash: HashSelector
  miniblockReceiverShard: BigIntIdSelector
  type: StringSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  txNonce: IntegerSelector
  txReceiver: HashSelector
  txReceiverShard: BigIntIdSelector
  txSender: HashSelector
  txSenderShard: BigIntIdSelector
  signature: HashSelector
  status: StringSelector
  data: StringSelector
  dataOperation: StringSelector
  fee: FloatSelector
  gasUsed: FloatSelector
  gasLimit: FloatSelector
  gasPrice: FloatSelector
  txValue: FloatSelector
  function: StringSelector
  actionName: StringSelector
  actionCategory: StringSelector
  actionDescription: StringSelector
}

enum ElrondTransactionsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Hash of the the block
  """
  block_hash

  """
  Number of block in the blockhains
  """
  height

  """
  The block hash of this block`s parent
  """
  previous_block_hash

  """
  The block hash of this block`s parent
  """
  transaction_count

  """
  Hash of the miniblock
  """
  miniblock_hash

  """
  Hash of the miniblocks receiver block
  """
  miniblock_receiver_block_hash

  """
  Miniblock receiver shard
  """
  miniblock_receiver_shard

  """
  Type of miniblock
  """
  type

  """
  Transaction hash
  """
  hash

  """
  Receiver hash
  """
  tx_receiver

  """
  Shard number of the receiver
  """
  tx_receiver_shard

  """
  Sender hash
  """
  tx_sender

  """
  Shard number of the sender
  """
  tx_sender_shard

  """
  Data
  """
  data

  """
  Gas Limit
  """
  gas_limit

  """
  Gas Price
  """
  gas_price

  """
  Gas Used
  """
  gas_used

  """
  Value
  """
  value

  """
  Action Function
  """
  function

  """
  Action Name
  """
  action_name

  """
  Action Category
  """
  action_category

  """
  Action Description
  """
  action_description
}

enum ElrondTransactionUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique Number of block in the blockchains
  """
  height
}

"""
Transfers of Smart Contract Calls and Events
"""
type ElrondTransfer {
  """
  Action
  """
  action: String
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    previousBlockHash: HashSelector
    blockHash: HashSelector
    shard: BigIntIdSelector
    proposer: HashSelector
    epoch: IntegerSelector
    blockNonce: IntegerSelector
    round: IntegerSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    publicKeyBitmap: StringSelector
    stateRootHash: HashSelector
    transactionCount: IntegerSelector
    miniblockHash: HashSelector
    miniblockReceiverBlockHash: HashSelector
    miniblockReceiverShard: BigIntIdSelector
    type: StringSelector
    txHash: HashSelector
    index: IntegerSelector
    nonce: IntegerSelector
    txReceiver: HashSelector
    txReceiverShard: BigIntIdSelector
    txSender: HashSelector
    txSenderShard: BigIntIdSelector
    signature: HashSelector
    status: StringSelector
    data: StringSelector
    dataOperation: StringSelector
    currency: CurrencySelector
    transferSender: AddressSelector
    transferReceiver: AddressSelector
    entityId: EntitySelector
    action: ActionSelector
    transferType: StringSelector
    esdtType: StringSelector
  ): Float
  any(of: ElrondTransfersMeasureable!): String
  count(uniq: ElrondTransferUniq): Int
  countBigInt(
    uniq: ElrondTransferUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    previousBlockHash: HashSelector
    blockHash: HashSelector
    shard: BigIntIdSelector
    proposer: HashSelector
    epoch: IntegerSelector
    blockNonce: IntegerSelector
    round: IntegerSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    publicKeyBitmap: StringSelector
    stateRootHash: HashSelector
    transactionCount: IntegerSelector
    miniblockHash: HashSelector
    miniblockReceiverBlockHash: HashSelector
    miniblockReceiverShard: BigIntIdSelector
    type: StringSelector
    txHash: HashSelector
    index: IntegerSelector
    nonce: IntegerSelector
    txReceiver: HashSelector
    txReceiverShard: BigIntIdSelector
    txSender: HashSelector
    txSenderShard: BigIntIdSelector
    signature: HashSelector
    status: StringSelector
    data: StringSelector
    dataOperation: StringSelector
    currency: CurrencySelector
    transferSender: AddressSelector
    transferReceiver: AddressSelector
    entityId: EntitySelector
    action: ActionSelector
    transferType: StringSelector
    esdtType: StringSelector
  ): BigInt

  """
  Currency of transfer
  """
  currency(currency: CurrencySelector): Currency

  """
  The date this transaction was created
  """
  date: Date

  """
  Entity ID
  """
  entityId: BigInt

  """
  Esdt Type
  """
  esdtType: String
  expression(get: String!): DecimalNumber
  maximum(
    of: ElrondTransfersMeasureable!
    get: ElrondTransfersMeasureable
  ): String

  """
  Information about arguments miniblock
  """
  miniblock(
    miniblockHash: HashSelector
    miniblockReceiverBlockHash: HashSelector
    miniblockReceiverShard: BigIntIdSelector
    type: StringSelector
  ): MiniblockElrond
  minimum(
    of: ElrondTransfersMeasureable!
    get: ElrondTransfersMeasureable
  ): String

  """
  Receiver account address
  """
  receiver: Address

  """
  Sender account address
  """
  sender: Address

  """
  Information about arguments block
  """
  senderBlock(
    height: BlockSelector
    previousBlockHash: HashSelector
    blockHash: HashSelector
    shard: BigIntIdSelector
    proposer: HashSelector
    epoch: IntegerSelector
    blockNonce: IntegerSelector
    round: IntegerSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    publicKeyBitmap: StringSelector
    stateRootHash: HashSelector
    transactionCount: IntegerSelector
  ): ElrondBlockDimension

  """
  The time this transaction was created
  """
  time: DateTime

  """
  Information about arguments transaction
  """
  transaction(
    txHash: HashSelector
    index: IntegerSelector
    nonce: IntegerSelector
    txReceiver: HashSelector
    txReceiverShard: BigIntIdSelector
    txSender: HashSelector
    txSenderShard: BigIntIdSelector
    signature: HashSelector
    status: StringSelector
    data: StringSelector
    dataOperation: StringSelector
    txFunction: StringSelector
  ): TransactionElrond

  """
  Type
  """
  type: String
}

input ElrondTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  blockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  blockNonce: IntegerSelector
  round: IntegerSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  publicKeyBitmap: StringSelector
  stateRootHash: HashSelector
  transactionCount: IntegerSelector
  miniblockHash: HashSelector
  miniblockReceiverBlockHash: HashSelector
  miniblockReceiverShard: BigIntIdSelector
  type: StringSelector
  txHash: HashSelector
  index: IntegerSelector
  nonce: IntegerSelector
  txReceiver: HashSelector
  txReceiverShard: BigIntIdSelector
  txSender: HashSelector
  txSenderShard: BigIntIdSelector
  signature: HashSelector
  status: StringSelector
  data: StringSelector
  dataOperation: StringSelector
  currency: CurrencySelector
  transferSender: AddressSelector
  transferReceiver: AddressSelector
  entityId: EntitySelector
  action: ActionSelector
  transferType: StringSelector
  esdtType: StringSelector
}

enum ElrondTransfersMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Hash of the the block
  """
  block_hash

  """
  Number of block in the blockhains
  """
  height

  """
  The block hash of this block`s parent
  """
  previous_block_hash

  """
  The block hash of this block`s parent
  """
  transaction_count

  """
  Hash of the miniblock
  """
  miniblock_hash

  """
  Hash of the miniblocks receiver block
  """
  miniblock_receiver_block_hash

  """
  Miniblock receiver shard
  """
  miniblock_receiver_shard

  """
  Type of miniblock
  """
  type

  """
  Transaction hash
  """
  tx_hash

  """
  Receiver hash
  """
  tx_receiver

  """
  Shard number of the receiver
  """
  tx_receiver_shard

  """
  Sender hash
  """
  tx_sender

  """
  Shard number of the sender
  """
  tx_sender_shard

  """
  Data
  """
  data

  """
  Gas Limit
  """
  gas_limit

  """
  Gas Price
  """
  gas_price

  """
  Gas Used
  """
  gas_used

  """
  Value
  """
  tx_value

  """
  Transfer Amount
  """
  amount

  """
  Sender
  """
  sender

  """
  Receiver
  """
  receiver

  """
  Entity ID
  """
  entity_id

  """
  Action
  """
  action

  """
  Transfer Type
  """
  transferType

  """
  ESDT Type
  """
  esdtType

  """
  Currency symbol
  """
  currency_symbol

  """
  Token address
  """
  currency_address

  """
  Token ID
  """
  token_id

  """
  Token type
  """
  token_type
}

enum ElrondTransferUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique Number of block in the blockchains
  """
  block_height

  """
  Unique Transaction Hash
  """
  signature

  """
  Unique count of transfers type
  """
  transferType
}

"""
Entity
"""
type Entity {
  """
  Entity ID
  """
  id(entityId: String): String!

  """
  Entity number
  """
  num: Int!

  """
  Entity realm ID
  """
  realmId: Int!

  """
  Entity shard ID
  """
  shardId: Int!

  """
  Entity Type
  """
  type: String!
}

"""
Selector of entity ID for NFT  tokens
"""
input EntitySelector {
  """
  EntityID is
  """
  is: String

  """
  EntityID not
  """
  not: String

  """
  EntityID in the list
  """
  in: [String!]

  """
  EntityID not in the list
  """
  notIn: [String!]
}

enum EntityTypeEnum {
  """
  account
  """
  account

  """
  contract
  """
  contract

  """
  file
  """
  file

  """
  topic
  """
  topic

  """
  token
  """
  token

  """
  schedule
  """
  schedule
}

"""
Select by entity type
"""
input EntityTypeSelector {
  """
  Type is
  """
  is: EntityTypeEnum

  """
  Type not
  """
  not: EntityTypeEnum

  """
  Type in the list
  """
  in: [EntityTypeEnum!]

  """
  Type not in the list
  """
  notIn: [EntityTypeEnum!]
}

"""
EOS Chain
"""
type Eos {
  """
  Basic information about address ( or smart contract )
  """
  address(address: [AddressSelectorIn!]!): [EosAddressInfo!]!

  """
  Blockchain Address Statistics
  """
  addressStats(
    address: AddressSelector!
    options: QueryOptions
  ): [EosAddressStats!]

  """
  Blockchain Blocks
  """
  blocks(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    proposer: AddressSelector
    any: [EosBlockFilter!]
    options: QueryOptions
  ): [EosBlocks!]

  """
  Money flow using Coinpath technology
  """
  coinpath(
    sender: AddressSelector
    receiver: AddressSelector
    currency: EosCurrencySelector
    initialAddress: AddressSelector
    initialDate: DateSelector
    initialTime: DateTimeSelector
    date: DateSelector
    time: DateTimeSelector
    depth: IntegerLimitedSelector
    options: CoinpathOptions
  ): [EosCoinpath!]

  """
  Smart Contract Calls
  """
  smartContractCalls(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    external: Boolean
    success: Boolean
    scheduled: Boolean
    any: [EosSmartContractCallFilter!]
    options: QueryOptions
  ): [EosSmartContractCalls!]

  """
  Blockchain Transactions
  """
  transactions(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
    success: Boolean
    scheduled: Boolean
    any: [EosTransactionFilter!]
    options: QueryOptions
  ): [EosTransactions!]

  """
  Currency Transfers
  """
  transfers(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    sender: AddressSelector
    receiver: AddressSelector
    currency: EosCurrencySelector
    entityId: EntitySelector
    external: Boolean
    success: Boolean
    amount: [AmountSelector!]
    any: [EosTransferFilter!]
    options: QueryOptions
  ): [EosTransfers!]
}

"""
Address detailed information for EOS network
"""
type EosAddressInfo {
  """
  Address
  """
  address: String

  """
  Annotations ( tags ), if exists
  """
  annotation: String

  """
  Smart Contract if exists on the address
  """
  smartContract: EosSmartContractInfo
}

"""
Address with statistics
"""
type EosAddressStat {
  """
  Address
  """
  address: Address

  """
  Balance
  """
  balance: BigInt

  """
  Call Tx Count
  """
  callTxCount: BigInt

  """
  Called Tx Count
  """
  calledTxCount: BigInt

  """
  Days with received
  """
  daysWithReceived: BigInt

  """
  Days with sent
  """
  daysWithSent: BigInt

  """
  Days with transactions
  """
  daysWithTransactions: BigInt

  """
  Days with transfers
  """
  daysWithTransfers: BigInt

  """
  First transfer at
  """
  firstTransferAt: DateTime

  """
  First tx at
  """
  firstTxAt: DateTime

  """
  Last transfer at
  """
  lastTransferAt: DateTime

  """
  Last tx at
  """
  lastTxAt: DateTime

  """
  Other Tx Count
  """
  otherTxCount: BigInt

  """
  Receive Amount
  """
  receiveAmount: BigInt

  """
  Receive from Count
  """
  receiveFromCount: BigInt

  """
  Receive from currencies
  """
  receiveFromCurrencies: BigInt

  """
  Receive tx Count
  """
  receiveTxCount: BigInt

  """
  Send Amount
  """
  sendAmount: BigInt

  """
  Send to count
  """
  sendToCount: BigInt

  """
  Send to currencies
  """
  sendToCurrencies: BigInt

  """
  Send tx count
  """
  sendTxCount: BigInt
}

"""
AddressStat
"""
type EosAddressStats {
  """
  Address With Statistics
  """
  address: EosAddressStat
}

input EosBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  proposer: AddressSelector
}

"""
Blocks in EOS blockchain
"""
type EosBlocks {
  any(of: EosBlocksMeasureable!): String
  count(
    uniq: EosBlocksUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    proposer: AddressSelector
  ): Int
  countBigInt(
    uniq: EosBlocksUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    proposer: AddressSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Block hash
  """
  hash(blockHash: [HashSelector!]): String!

  """
  Block number (height) in blockchain
  """
  height(height: BlockSelector): Int!
  maximum(of: EosBlocksMeasureable!, get: EosBlocksMeasureable): String
  minimum(of: EosBlocksMeasureable!, get: EosBlocksMeasureable): String

  """
  Block producer
  """
  producer(producer: AddressSelector): Address

  """
  Block timestamp
  """
  timestamp(time: DateTimeSelector): DateTime
}

enum EosBlocksMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Block hash
  """
  block_hash

  """
  Block Proposer
  """
  proposer
}

enum EosBlocksUniq {
  """
  Unique proposer count
  """
  proposers

  """
  Unique date count
  """
  dates
}

enum EosCallsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Sender
  """
  tx_sender

  """
  Action From
  """
  tx_from

  """
  Action To
  """
  tx_to

  """
  Smart Contract
  """
  smart_contract

  """
  Smart Contract Method Name
  """
  signature_name

  """
  Smart Contract Method Signature
  """
  signature

  """
  Smart Contract Method Signature Hash
  """
  signature_hash

  """
  Call depth
  """
  call_depth
}

"""
Coinpath
"""
type EosCoinpath {
  """
  Summary of transfered value
  """
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """
  Block where transaction is included
  """
  block: Block

  """
  Count of transfers
  """
  count: Int

  """
  Count of transfers
  """
  countBigInt: BigInt

  """
  Currency of transfer
  """
  currency: Currency

  """
  1-based hop depth of the graph
  """
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """
  Receiver address
  """
  receiver: EosCoinpathAddress

  """
  Sender address
  """
  sender: EosCoinpathAddress

  """
  Transaction of transfer happened
  """
  transaction: TransactionHashValueTime
}

"""
Address detailed information for Eos network
"""
type EosCoinpathAddress {
  """
  Address
  """
  address: String
  amountIn: DecimalNumber
  amountOut: DecimalNumber

  """
  Annotations ( tags ), if exists
  """
  annotation: String
  balance: DecimalNumber

  """
  Smart Contract if exists on the address
  """
  firstTxAt: DateTime

  """
  Smart Contract if exists on the address
  """
  lastTxAt: DateTime
  receiversCount: Int
  sendersCount: Int

  """
  Smart Contract if exists on the address
  """
  smartContract: EosSmartContractInfo

  """
  Address type
  """
  type: String
}

"""
Currency selector in EOS blockchain.
Token identified by address of contract ( eosio.token for main EOS token )
"""
input EosCurrencySelector {
  """
  Currency is
  """
  is: String

  """
  Currency not
  """
  not: String

  """
  Currency in the list
  """
  in: [String!]

  """
  Currency not in the list
  """
  notIn: [String!]
}

enum EosNetwork {
  """
  EOS mainnet
  """
  eos
}

"""
Eos smart contract
"""
type EosSmartContract {
  """
  Smart Contract Address
  """
  address: Address!

  """
  Smart Contract Type
  """
  contractType: SmartContractType

  """
  Token implemented in this smart contract
  """
  currency: ScCurrency

  """
  Smart Contract Protocol Type
  """
  protocolType: String
}

input EosSmartContractCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  smartContractAddress: AddressSelector
  smartContractMethod: MethodSelector
  external: Boolean
  success: Boolean
  scheduled: Boolean
}

"""
Smart Contract Calls
"""
type EosSmartContractCalls {
  """
  Actors
  """
  actors: String
  any(of: EosCallsMeasureable!): String

  """
  Block in the blockchain
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Depth of the call. Empty string for external call, then counted as 0...N, and
  the next layer is added through '-'. For example 0-3-9.
  """
  callDepth: String

  """
  Console
  """
  console: String

  """
  Counts and other metrics
  """
  count(
    uniq: SmartContractCallsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    external: Boolean
    success: Boolean
    scheduled: Boolean
  ): Int

  """
  Counts and other metrics
  """
  countBigInt(
    uniq: SmartContractCallsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    external: Boolean
    success: Boolean
    scheduled: Boolean
  ): BigInt

  """
  Calendar date
  """
  date: Date

  """
  Error Code
  """
  errorCode(errorCode: IntIdSelector): Int
  expression(get: String!): DecimalNumber

  """
  External call executed explicitly by tx sender. Internal calls executed by smart contracts.
  """
  external(external: Boolean): Boolean
  maximum(of: EosCallsMeasureable!, get: EosCallsMeasureable): String
  minimum(of: EosCallsMeasureable!, get: EosCallsMeasureable): String

  """
  Permissions
  """
  permissions: String

  """
  Receivers
  """
  receivers: String

  """
  True if call scheduled
  """
  scheduled(scheduled: [Boolean!]): Boolean

  """
  Smart contract being called
  """
  smartContract(smartContractAddress: AddressSelector): EosSmartContract

  """
  Contract method invoked
  """
  smartContractMethod(smartContractMethod: MethodSelector): Method

  """
  True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
  """
  success(success: [Boolean!]): Boolean

  """
  Action from address
  """
  txFrom(txFrom: AddressSelector): Address

  """
  Transaction hash where transfer happened
  """
  txHash(txHash: HashSelector): String

  """
  Action to address
  """
  txTo(txTo: AddressSelector): Address
}

"""
Blockchain smart contract
"""
type EosSmartContractInfo {
  """
  Smart Contract Type
  """
  contractType: SmartContractType

  """
  Token implemented in this smart contract
  """
  currency: ScCurrency

  """
  Smart Contract Protocol Type
  """
  protocolType: String
}

input EosTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: TxIndexSelector
  success: Boolean
  scheduled: Boolean
}

"""
Transactions in EOS blockchain
"""
type EosTransactions {
  any(of: EosTransactionsMeasureable!): String

  """
  Block where transfer transaction is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(
    uniq: EosTransactionsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
    success: Boolean
    scheduled: Boolean
  ): Int
  countBigInt(
    uniq: EosTransactionsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
    success: Boolean
    scheduled: Boolean
  ): BigInt
  cpuUsageUs(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
    success: Boolean
    scheduled: Boolean
  ): Int

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Hash hex representation
  """
  hash(txHash: [HashSelector!]): String!

  """
  Transaction index in block, 0 based
  """
  index(txIndex: [TxIndexSelector!]): Int
  maximum(
    of: EosTransactionsMeasureable!
    get: EosTransactionsMeasureable
  ): String
  minimum(
    of: EosTransactionsMeasureable!
    get: EosTransactionsMeasureable
  ): String
  netUsageWords(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
    success: Boolean
    scheduled: Boolean
  ): Int

  """
  Success
  """
  scheduled(scheduled: Boolean): Boolean

  """
  Success
  """
  success(success: Boolean): Boolean
}

enum EosTransactionsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  CPU Usage
  """
  cpu_usage_us

  """
  Net Usage
  """
  net_usage_words
}

enum EosTransactionsUniq {
  """
  Unique blocks
  """
  blocks

  """
  Unique date count
  """
  dates
}

input EosTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  sender: AddressSelector
  receiver: AddressSelector
  currency: EosCurrencySelector
  entityId: EntitySelector
  external: Boolean
  success: Boolean
  amount: [AmountSelector!]
}

"""
Currency transfers from/to addresses in crypto currencies
"""
type EosTransfers {
  """
  Actors
  """
  actors: String
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    sender: AddressSelector
    receiver: AddressSelector
    currency: EosCurrencySelector
    entityId: EntitySelector
    external: Boolean
    success: Boolean
    amount: [AmountSelector!]
  ): Float
  any(of: EosTransfersMeasureable!): String

  """
  Block where transfer transaction is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(
    uniq: TransfersUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    sender: AddressSelector
    receiver: AddressSelector
    currency: EosCurrencySelector
    entityId: EntitySelector
    external: Boolean
    success: Boolean
    amount: [AmountSelector!]
  ): Int
  countBigInt(
    uniq: TransfersUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    sender: AddressSelector
    receiver: AddressSelector
    currency: EosCurrencySelector
    entityId: EntitySelector
    external: Boolean
    success: Boolean
    amount: [AmountSelector!]
  ): BigInt

  """
  Currency of transfer
  """
  currency(currency: EosCurrencySelector): Currency

  """
  Calendar date
  """
  date: Date

  """
  Entity identifier ( for ERC-721 NFT tokens )
  """
  entityId(entityId: EntitySelector): String
  expression(get: String!): DecimalNumber

  """
  External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts.
  """
  external(external: Boolean): Boolean
  maximum(of: EosTransfersMeasureable!, get: EosTransfersMeasureable): String

  """
  Memo
  """
  memo: String
  minimum(of: EosTransfersMeasureable!, get: EosTransfersMeasureable): String

  """
  Transfer receiver
  """
  receiver(receiver: AddressSelector): Address

  """
  Transfer sender
  """
  sender(sender: AddressSelector): Address

  """
  Transfer succeeded
  """
  success(success: Boolean): Boolean

  """
  Action from address
  """
  txFrom(txFrom: AddressSelector): Address

  """
  Transaction hash where transfer happened
  """
  txHash(txHash: HashSelector): String

  """
  Action to address
  """
  txTo(txTo: AddressSelector): Address
}

enum EosTransfersMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Amount
  """
  amount

  """
  Sender
  """
  sender

  """
  Receiver
  """
  receiver

  """
  Currency symbol
  """
  currency_symbol

  """
  Token address
  """
  currency_address
}

"""
Ethereum Chain
"""
type Ethereum {
  """
  Ethereum Active Addresses
  """
  activeAddresses(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [EthereumAddressSelector!]
    entityId: EntitySelector
    sender: [EthereumAddressSelector!]
    receiver: [EthereumAddressSelector!]
    currency: [EthereumCurrencySelector!]
    external: Boolean
    success: Boolean
    amount: [AmountSelector!]
    options: QueryOptions
  ): [EthereumActiveAddress!]

  """
  Basic information about address ( or smart contract )
  """
  address(
    address: [EthereumAddressSelectorIn!]!
  ): [EthereumAddressInfoWithBalance!]!

  """
  Blockchain Address Statistics
  """
  addressStats(
    address: EthereumAddressSelector!
    options: QueryOptions
  ): [EthereumAddressStats!]

  """
  Arguments of Smart Contract Calls and Events
  """
  arguments(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [EthereumAddressSelector!]
    caller: [EthereumAddressSelector!]
    reference: [EthereumAddressSelector!]
    value: [ArgumentValueSelector!]
    argument: [ArgumentSelector!]
    argumentType: [ArgumentTypeSelector!]
    signatureType: SignatureTypeSelector
    smartContractAddress: [EthereumAddressSelector!]
    smartContractMethod: MethodSelector
    smartContractEvent: EventSelector
    external: Boolean
    callDepth: StringSelector
    any: [EthereumArgumentFilter!]
    options: QueryOptions
  ): [EthereumArguments!]

  """
  Blockchain Blocks
  """
  blocks(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    miner: [EthereumAddressSelector!]
    blockReward: [AmountSelector!]
    transactionCount: [IntegerSelector!]
    uncleCount: [IntegerSelector!]
    size: [IntegerSelector!]
    any: [EthereumBlockFilter!]
    options: QueryOptions
  ): [EthereumBlocks!]

  """
  Money flow using Coinpath technology
  """
  coinpath(
    sender: EthereumAddressSelector
    receiver: EthereumAddressSelector
    currency: [EthereumCurrencySelector!]
    initialAddress: EthereumAddressSelector
    initialDate: DateSelector
    initialTime: DateTimeSelector
    date: DateSelector
    time: DateTimeSelector
    depth: IntegerLimitedSelector
    options: CoinpathOptions
  ): [EthereumCoinpath!]

  """
  Trades on Ethereum DEX Smart Contracts
  """
  dexTrades(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    txHash: HashSelector
    txSender: [EthereumAddressSelector!]
    txTo: [EthereumAddressSelector!]
    protocol: [StringSelector!]
    smartContractAddress: [EthereumAddressSelector!]
    exchangeAddress: [EthereumAddressSelector!]
    exchangeName: [StringSelector!]
    sellCurrency: [EthereumCurrencySelector!]
    buyCurrency: [EthereumCurrencySelector!]
    baseCurrency: [EthereumCurrencySelector!]
    quoteCurrency: [EthereumCurrencySelector!]
    maker: [EthereumAddressSelector!]
    makerSmartContractType: [SmartContractTypeSelector!]
    taker: [EthereumAddressSelector!]
    takerSmartContractType: [SmartContractTypeSelector!]
    makerOrTaker: [EthereumAddressSelector!]
    tradeIndex: [StringSelector!]
    buyAmount: [AmountSelector!]
    sellAmount: [AmountSelector!]
    price: [AmountSelector!]
    priceAsymmetry: [FloatSelector!]
    tradeAmountUsd: [FloatSelector!]
    any: [EthereumDexTradeFilter!]
    options: QueryOptions
  ): [EthereumDexTrades!]

  """
  Smart Contract Calls
  """
  smartContractCalls(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [EthereumAddressSelector!]
    caller: [EthereumAddressSelector!]
    smartContractAddress: [EthereumAddressSelector!]
    smartContractMethod: MethodSelector
    smartContractType: SmartContractTypeSelector
    external: Boolean
    success: Boolean
    callDepth: StringSelector
    any: [EthereumSmartContractCallFilter!]
    options: QueryOptions
  ): [EthereumSmartContractCalls!]

  """
  Smart Contract Events
  """
  smartContractEvents(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [EthereumAddressSelector!]
    smartContractType: SmartContractTypeSelector
    smartContractAddress: [EthereumAddressSelector!]
    smartContractEvent: EventSelector
    any: [EthereumSmartContractEventFilter!]
    options: QueryOptions
  ): [EthereumSmartContractEvent!]

  """
  Blockchain Transactions
  """
  transactions(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txSender: [EthereumAddressSelector!]
    txTo: [EthereumAddressSelector!]
    txCreates: [EthereumAddressSelector!]
    txIndex: TxIndexSelector
    success: Boolean
    amount: [AmountSelector!]
    gasCurrency: [EthereumCurrencySelector!]
    gasValue: [AmountSelector!]
    txType: [StringSelector!]
    feePayer: [StringSelector!]
    feeRatio: TxIndexSelector
    any: [EthereumTransactionFilter!]
    options: QueryOptions
  ): [EthereumTransactions!]

  """
  Currency Transfers
  """
  transfers(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [EthereumAddressSelector!]
    entityId: EntitySelector
    sender: [EthereumAddressSelector!]
    receiver: [EthereumAddressSelector!]
    currency: [EthereumCurrencySelector!]
    external: Boolean
    success: Boolean
    amount: [AmountSelector!]
    any: [EthereumTransferFilter!]
    options: QueryOptions
  ): [EthereumTransfers!]
}

"""
Ethereum v 2.0 Baecon Chain
"""
type Ethereum2 {
  """
  Attestations in block
  """
  attestations(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
    validatorIndex: [IntegerSelector!]
    committeeIndex: [IntegerSelector!]
    attestationSlot: [IntegerSelector!]
    attestationEpoch: [IntegerSelector!]
    any: [Ethereum2Filter!]
    options: QueryOptions
  ): [Ethereum2Attestation!]

  """
  Attester Slashings
  """
  attesterSlashings(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
    validatorIndex: [IntegerSelector!]
    attestationSlot: [IntegerSelector!]
    attestationEpoch: [IntegerSelector!]
    any: [Ethereum2Filter!]
    options: QueryOptions
  ): [Ethereum2AttesterSlashing!]

  """
  Blockchain Blocks
  """
  blocks(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
    any: [Ethereum2Filter!]
    options: QueryOptions
  ): [Ethereum2Blocks!]

  """
  Attestations of blocks
  """
  deposits(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
    validatorIndex: [IntegerSelector!]
    any: [Ethereum2Filter!]
    options: QueryOptions
  ): [Ethereum2Deposit!]

  """
  Proposer Slashings
  """
  proposerSlashings(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
    slashingProposerIndex: [IntegerSelector!]
    slashingSlot: [IntegerSelector!]
    slashingEpoch: [IntegerSelector!]
    any: [Ethereum2Filter!]
    options: QueryOptions
  ): [Ethereum2ProposerSlashing!]

  """
  Validator Updates
  """
  validatorUpdates(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
    epoch: [StringSelector!]
    blockProposerPubkey: [HashSelector!]
    stateRootHash: [HashSelector!]
    validatorIndex: [IntegerSelector!]
    validatorStatus: [StringSelector!]
    validatorPubkey: [HashSelector!]
    eth1DepositRootHash: [HashSelector!]
    eth1DepositCount: [IntegerSelector!]
    eth1BlockHash: [HashSelector!]
    validatorWithdrawalCredentials: [HashSelector!]
    validatorSlashed: [BooleanSelector!]
    validatorBalance: [AmountSelector!]
    validatorBalanceChange: [AmountSelector!]
    validatorEffectiveBalance: [AmountSelector!]
    validatorActivationEpoch: [StringSelector!]
    validatorExitEpoch: [StringSelector!]
    validatorWithdrawableEpoch: [StringSelector!]
    any: [Ethereum2ValidatorUpdatesFilter!]
    options: QueryOptions
  ): [Ethereum2ValidatorUpdates!]

  """
  Voluntary Exits
  """
  voluntaryExits(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
    validatorIndex: [IntegerSelector!]
    voluntaryExitEpoch: [IntegerSelector!]
    any: [Ethereum2Filter!]
    options: QueryOptions
  ): [Ethereum2VoluntaryExit!]
}

"""
Attestations in Ethereum v2.0 blockchain
"""
type Ethereum2Attestation {
  aggregationBits: String!
  any(of: Ethereum2AttestationsMeasureable!): String
  attestation: Ethereum2AttestationInfo!

  """
  Attestation Index (0 based ) in block
  """
  attestationIndex: Int!

  """
  Block in the blockchain
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Block root hash
  """
  blockRoot(blockRootHash: [HashSelector!]): String!

  """
  Committee index for attestation
  """
  committeeIndex: Int!
  count(
    uniq: Ethereum2AttestationsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
    validatorIndex: [IntegerSelector!]
    committeeIndex: [IntegerSelector!]
    attestationSlot: [IntegerSelector!]
    attestationEpoch: [IntegerSelector!]
  ): Int
  countBigInt(
    uniq: Ethereum2AttestationsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
    validatorIndex: [IntegerSelector!]
    committeeIndex: [IntegerSelector!]
    attestationSlot: [IntegerSelector!]
    attestationEpoch: [IntegerSelector!]
  ): BigInt

  """
  Calendar date
  """
  date: Date

  """
  Block Eth1 information
  """
  eth1: Ethereum2Eth1Info!
  expression(get: String!): DecimalNumber
  maximum(
    of: Ethereum2AttestationsMeasureable!
    get: Ethereum2AttestationsMeasureable
  ): String
  minimum(
    of: Ethereum2AttestationsMeasureable!
    get: Ethereum2AttestationsMeasureable
  ): String

  """
  Block parent hash
  """
  parentRoot: String!

  """
  Block proposer
  """
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo

  """
  Block state root hash
  """
  stateRoot: String!

  """
  Validator
  """
  validator: Ethereum2ValidatorInfo!

  """
  Sequential index of validator in committee ( 0-based)
  """
  validatorInCommitteeIndex: Int!
}

"""
AttestationFieldInfo for Ethereum v 2.0 network
"""
type Ethereum2AttestationFieldInfo {
  epoch: Int!

  """
  Root Hash
  """
  root: String!
}

"""
AttestationInfo for Ethereum v 2.0 network
"""
type Ethereum2AttestationInfo {
  beaconBlockRoot: String!
  epoch: Int!
  signature: String!
  slot: Int!
  source: Ethereum2AttestationFieldInfo!
  target: Ethereum2AttestationFieldInfo!
}

enum Ethereum2AttestationsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Block hash
  """
  block_root_hash

  """
  Block Proposer
  """
  block_proposer

  """
  Committee Index
  """
  committee

  """
  Validator index
  """
  validator
}

enum Ethereum2AttestationsUniq {
  """
  Unique blocks
  """
  blocks

  """
  Unique block proposers
  """
  block_proposers

  """
  Unique date count
  """
  dates

  """
  Unique commitees
  """
  committees

  """
  Unique validators
  """
  validators

  """
  Unique attestations
  """
  attestations

  """
  Unique attestation slots
  """
  attestation_slots

  """
  Unique attestation epochs
  """
  attestation_epochs
}

"""
Attester Slashing in Ethereum v2.0 blockchain
"""
type Ethereum2AttesterSlashing {
  any(of: Ethereum2AttesterSlashingMeasureable!): String
  attestation: Ethereum2AttestationInfo!

  """
  Attestation slashing sequential number
  """
  attestationOrder: Int!

  """
  Attester Slashing Index (0 based ) in block
  """
  attesterSlashingIndex: Int!

  """
  Block in the blockchain
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Block root hash
  """
  blockRoot(blockRootHash: [HashSelector!]): String!
  count(
    uniq: Ethereum2AttesterSlashingsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
    validatorIndex: [IntegerSelector!]
    attestationSlot: [IntegerSelector!]
    attestationEpoch: [IntegerSelector!]
  ): Int
  countBigInt(
    uniq: Ethereum2AttesterSlashingsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
    validatorIndex: [IntegerSelector!]
    attestationSlot: [IntegerSelector!]
    attestationEpoch: [IntegerSelector!]
  ): BigInt

  """
  Calendar date
  """
  date: Date

  """
  Block Eth1 information
  """
  eth1: Ethereum2Eth1Info!
  maximum(
    of: Ethereum2AttesterSlashingMeasureable!
    get: Ethereum2AttesterSlashingMeasureable
  ): String
  minimum(
    of: Ethereum2AttesterSlashingMeasureable!
    get: Ethereum2AttesterSlashingMeasureable
  ): String

  """
  Block parent hash
  """
  parentRoot: String!

  """
  Block proposer
  """
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo

  """
  Block state root hash
  """
  stateRoot: String!

  """
  Validator
  """
  validator: Ethereum2ValidatorInfo!

  """
  Validator index in slashing sequential numbern
  """
  validatorInAttestationIndex: Int!
}

enum Ethereum2AttesterSlashingMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Block hash
  """
  block_root_hash

  """
  Block Proposer
  """
  block_proposer

  """
  Validator index
  """
  validator
}

enum Ethereum2AttesterSlashingsUniq {
  """
  Unique blocks
  """
  blocks

  """
  Unique block proposers
  """
  block_proposers

  """
  Unique date count
  """
  dates

  """
  Unique validators
  """
  validators

  """
  Unique slashing slots
  """
  attestation_slots

  """
  Unique slashing epochs
  """
  attestation_epochs
}

"""
Blocks in Ethereum v2.0 blockchain
"""
type Ethereum2Blocks {
  any(of: Ethereum2BlocksMeasureable!): String
  attestationsCount(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
  ): Int
  attestationsCountBigInt(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
  ): BigInt
  attesterSlashingsCount(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
  ): Int
  attesterSlashingsCountBigInt(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
  ): BigInt

  """
  Block root hash
  """
  blockRoot(blockRootHash: [HashSelector!]): String!
  count(
    uniq: Ethereum2BlocksUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
  ): Int
  countBigInt(
    uniq: Ethereum2BlocksUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
  ): BigInt

  """
  Calendar date
  """
  date: Date
  depositsCount(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
  ): Int
  depositsCountBigInt(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
  ): BigInt

  """
  Epoch in blockchain
  """
  epoch: Int!

  """
  Block Eth1 information
  """
  eth1: Ethereum2Eth1Info!
  expression(get: String!): DecimalNumber

  """
  Graffiti
  """
  graffiti: String!

  """
  Block number (height) in blockchain
  """
  height(height: BlockSelector): Int!
  maximum(
    of: Ethereum2BlocksMeasureable!
    get: Ethereum2BlocksMeasureable
  ): String
  minimum(
    of: Ethereum2BlocksMeasureable!
    get: Ethereum2BlocksMeasureable
  ): String

  """
  Block parent hash
  """
  parentRoot: String!

  """
  Block proposer
  """
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo
  proposerSlashingsCount(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
  ): Int
  proposerSlashingsCountBigInt(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
  ): BigInt

  """
  Randao Reveal
  """
  randaoReveal: String!

  """
  Block signature
  """
  signature: String!

  """
  Block state root hash
  """
  stateRoot: String!

  """
  Block timestamp
  """
  timestamp(time: DateTimeSelector): DateTime
  voluntaryExitsCount(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
  ): Int
  voluntaryExitsCountBigInt(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
  ): BigInt
}

enum Ethereum2BlocksMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Block hash
  """
  block_root_hash

  """
  Block Miner
  """
  block_proposer
}

enum Ethereum2BlocksUniq {
  """
  Unique proposers
  """
  block_proposers

  """
  Unique date count
  """
  dates
}

"""
Deposit in Ethereum v2.0 blockchain
"""
type Ethereum2Deposit {
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
    validatorIndex: [IntegerSelector!]
  ): Float
  any(of: Ethereum2DepositsMeasureable!): String

  """
  Block in the blockchain
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Block root hash
  """
  blockRoot(blockRootHash: [HashSelector!]): String!
  count(
    uniq: Ethereum2DepositsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
  ): Int
  countBigInt(
    uniq: Ethereum2DepositsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
  ): BigInt

  """
  Calendar date
  """
  date: Date

  """
  Deposit Index (0 based ) in block
  """
  depositIndex: Int!

  """
  Block Eth1 information
  """
  eth1: Ethereum2Eth1Info!
  expression(get: String!): DecimalNumber
  maximum(
    of: Ethereum2DepositsMeasureable!
    get: Ethereum2DepositsMeasureable
  ): String
  minimum(
    of: Ethereum2DepositsMeasureable!
    get: Ethereum2DepositsMeasureable
  ): String

  """
  Block parent hash
  """
  parentRoot: String!
  proof: String!

  """
  Block proposer
  """
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo
  signature: String!

  """
  Block state root hash
  """
  stateRoot: String!

  """
  Validator
  """
  validator: Ethereum2ValidatorInfo!
}

enum Ethereum2DepositsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Block hash
  """
  block_root_hash

  """
  Block Proposer
  """
  block_proposer

  """
  Validator index
  """
  validator
}

enum Ethereum2DepositsUniq {
  """
  Unique blocks
  """
  blocks

  """
  Unique block proposers
  """
  block_proposers

  """
  Unique date count
  """
  dates

  """
  Unique validators
  """
  validators
}

"""
Eth1 attributes for Ethereum v 2.0 network
"""
type Ethereum2Eth1Info {
  """
  Block Eth1 block hash
  """
  blockHash: String!

  """
  Block Eth1 deposit count
  """
  depositCount: Int!

  """
  Block Eth1 deposit root hash
  """
  depositRootHash: String!
}

input Ethereum2Filter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockRootHash: HashSelector
  blockProposerIndex: [IntegerSelector!]
}

enum Ethereum2Network {
  """
  Beacon Chain Ethereum 2.0
  """
  eth2

  """
  Medalla Ethereum 2.0 Beacon Testnet
  """
  medalla
}

"""
Proposer attributes for Ethereum v 2.0 network
"""
type Ethereum2ProposerInfo {
  """
  Proposer Index as Integer
  """
  index: Int!

  """
  Proposer Pub Key
  """
  pubkey: String!
}

"""
Proposer Slashing in Ethereum v2.0 blockchain
"""
type Ethereum2ProposerSlashing {
  any(of: Ethereum2ProposerSlashingMeasureable!): String

  """
  Block in the blockchain
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Block root hash
  """
  blockRoot(blockRootHash: [HashSelector!]): String!
  count(
    uniq: Ethereum2ProposerSlashingsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
    slashingProposerIndex: [IntegerSelector!]
    slashingSlot: [IntegerSelector!]
    slashingEpoch: [IntegerSelector!]
  ): Int
  countBigInt(
    uniq: Ethereum2ProposerSlashingsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
    slashingProposerIndex: [IntegerSelector!]
    slashingSlot: [IntegerSelector!]
    slashingEpoch: [IntegerSelector!]
  ): BigInt

  """
  Calendar date
  """
  date: Date

  """
  Block Eth1 information
  """
  eth1: Ethereum2Eth1Info!
  expression(get: String!): DecimalNumber

  """
  Header slashing sequential numbern
  """
  headerOrder: Int!
  maximum(
    of: Ethereum2ProposerSlashingMeasureable!
    get: Ethereum2ProposerSlashingMeasureable
  ): String
  minimum(
    of: Ethereum2ProposerSlashingMeasureable!
    get: Ethereum2ProposerSlashingMeasureable
  ): String

  """
  Block parent hash
  """
  parentRoot: String!

  """
  Block proposer
  """
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo

  """
  Proposer Slashing Index (0 based ) in block
  """
  proposerSlashingIndex: Int!
  slashing: Ethereum2SlashingInfo!

  """
  Block state root hash
  """
  stateRoot: String!
}

enum Ethereum2ProposerSlashingMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Block hash
  """
  block_root_hash

  """
  Block Proposer
  """
  block_proposer

  """
  Slashed Proposer
  """
  proposer
}

enum Ethereum2ProposerSlashingsUniq {
  """
  Unique blocks
  """
  blocks

  """
  Unique block proposers
  """
  block_proposers

  """
  Unique date count
  """
  dates

  """
  Unique slashing slots
  """
  slashing_slots

  """
  Unique slashing epochs
  """
  slashing_epochs

  """
  Unique slashing proposers
  """
  slashing_proposers
}

"""
SlashingInfo for Ethereum v 2.0 network
"""
type Ethereum2SlashingInfo {
  """
  Block body hash
  """
  bodyRoot: String!
  epoch: Int!

  """
  Block parent hash
  """
  parentRoot: String!

  """
  Block proposer
  """
  proposer: Ethereum2ValidatorInfo
  signature: String!
  slot: Int!

  """
  Block state root hash
  """
  stateRoot: String!
}

"""
Validator attributes for Ethereum v 2.0 network
"""
type Ethereum2ValidatorInfo {
  """
  Validator Index as Integer
  """
  index: Int!

  """
  Validator Pub Key
  """
  pubkey: String!
}

"""
Validator Updates in Ethereum v2.0 blockchain
"""
type Ethereum2ValidatorUpdates {
  any(of: Ethereum2ValidatorUpdatesMeasureable!): String

  """
  Block in the blockchain
  """
  block: Block

  """
  Block root hash
  """
  blockRootHash: String!
  count(
    uniq: Ethereum2ValidatorUpdatesUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
    epoch: [StringSelector!]
    blockProposerPubkey: [HashSelector!]
    stateRootHash: [HashSelector!]
    validatorIndex: [IntegerSelector!]
    validatorStatus: [StringSelector!]
    validatorPubkey: [HashSelector!]
    eth1DepositRootHash: [HashSelector!]
    eth1DepositCount: [IntegerSelector!]
    eth1BlockHash: [HashSelector!]
    validatorWithdrawalCredentials: [HashSelector!]
    validatorSlashed: [BooleanSelector!]
    validatorBalance: [AmountSelector!]
    validatorBalanceChange: [AmountSelector!]
    validatorEffectiveBalance: [AmountSelector!]
    validatorActivationEpoch: [StringSelector!]
    validatorExitEpoch: [StringSelector!]
    validatorWithdrawableEpoch: [StringSelector!]
  ): Int
  countBigInt(
    uniq: Ethereum2ValidatorUpdatesUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
    epoch: [StringSelector!]
    blockProposerPubkey: [HashSelector!]
    stateRootHash: [HashSelector!]
    validatorIndex: [IntegerSelector!]
    validatorStatus: [StringSelector!]
    validatorPubkey: [HashSelector!]
    eth1DepositRootHash: [HashSelector!]
    eth1DepositCount: [IntegerSelector!]
    eth1BlockHash: [HashSelector!]
    validatorWithdrawalCredentials: [HashSelector!]
    validatorSlashed: [BooleanSelector!]
    validatorBalance: [AmountSelector!]
    validatorBalanceChange: [AmountSelector!]
    validatorEffectiveBalance: [AmountSelector!]
    validatorActivationEpoch: [StringSelector!]
    validatorExitEpoch: [StringSelector!]
    validatorWithdrawableEpoch: [StringSelector!]
  ): BigInt

  """
  Calendar date
  """
  date: Date

  """
  Epoch
  """
  epoch: BigInt!

  """
  Block Eth1 information
  """
  eth1: Ethereum2Eth1Info!
  expression(get: String!): DecimalNumber
  maximum(
    of: Ethereum2ValidatorUpdatesMeasureable!
    get: Ethereum2ValidatorUpdatesMeasureable
  ): String
  minimum(
    of: Ethereum2ValidatorUpdatesMeasureable!
    get: Ethereum2ValidatorUpdatesMeasureable
  ): String

  """
  Block parent hash
  """
  parentRootHash: String!

  """
  Block proposer
  """
  proposer: Ethereum2ProposerInfo

  """
  Block state root hash
  """
  stateRootHash: String!

  """
  Time date
  """
  time: DateTime

  """
  Block validator
  """
  validator: Ethereum2ValidatorInfo

  """
  Validator activation epoch
  """
  validatorActivationEpoch: BigInt!

  """
  Validator balance
  """
  validatorBalance(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
    epoch: [StringSelector!]
    blockProposerPubkey: [HashSelector!]
    stateRootHash: [HashSelector!]
    validatorIndex: [IntegerSelector!]
    validatorStatus: [StringSelector!]
    validatorPubkey: [HashSelector!]
    eth1DepositRootHash: [HashSelector!]
    eth1DepositCount: [IntegerSelector!]
    eth1BlockHash: [HashSelector!]
    validatorWithdrawalCredentials: [HashSelector!]
    validatorSlashed: [BooleanSelector!]
    validatorBalance: [AmountSelector!]
    validatorBalanceChange: [AmountSelector!]
    validatorEffectiveBalance: [AmountSelector!]
    validatorActivationEpoch: [StringSelector!]
    validatorExitEpoch: [StringSelector!]
    validatorWithdrawableEpoch: [StringSelector!]
  ): Float

  """
  Validator balance change
  """
  validatorBalanceChange(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
    epoch: [StringSelector!]
    blockProposerPubkey: [HashSelector!]
    stateRootHash: [HashSelector!]
    validatorIndex: [IntegerSelector!]
    validatorStatus: [StringSelector!]
    validatorPubkey: [HashSelector!]
    eth1DepositRootHash: [HashSelector!]
    eth1DepositCount: [IntegerSelector!]
    eth1BlockHash: [HashSelector!]
    validatorWithdrawalCredentials: [HashSelector!]
    validatorSlashed: [BooleanSelector!]
    validatorBalance: [AmountSelector!]
    validatorBalanceChange: [AmountSelector!]
    validatorEffectiveBalance: [AmountSelector!]
    validatorActivationEpoch: [StringSelector!]
    validatorExitEpoch: [StringSelector!]
    validatorWithdrawableEpoch: [StringSelector!]
  ): Float!

  """
  Validator effective balance
  """
  validatorEffectiveBalance(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
    epoch: [StringSelector!]
    blockProposerPubkey: [HashSelector!]
    stateRootHash: [HashSelector!]
    validatorIndex: [IntegerSelector!]
    validatorStatus: [StringSelector!]
    validatorPubkey: [HashSelector!]
    eth1DepositRootHash: [HashSelector!]
    eth1DepositCount: [IntegerSelector!]
    eth1BlockHash: [HashSelector!]
    validatorWithdrawalCredentials: [HashSelector!]
    validatorSlashed: [BooleanSelector!]
    validatorBalance: [AmountSelector!]
    validatorBalanceChange: [AmountSelector!]
    validatorEffectiveBalance: [AmountSelector!]
    validatorActivationEpoch: [StringSelector!]
    validatorExitEpoch: [StringSelector!]
    validatorWithdrawableEpoch: [StringSelector!]
  ): Float!

  """
  Validator exit epoch
  """
  validatorExitEpoch: BigInt!

  """
  Validator Slashed
  """
  validatorSlashed: Boolean!

  """
  Validator Status
  """
  validatorStatus: String!

  """
  Validator withdrawable epoch
  """
  validatorWithdrawableEpoch: BigInt!

  """
  Validator Withdrawal Credentials
  """
  validatorWithdrawalCredentials: String!
}

input Ethereum2ValidatorUpdatesFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockRootHash: HashSelector
  blockProposerIndex: [IntegerSelector!]
  epoch: [StringSelector!]
  blockProposerPubkey: [HashSelector!]
  stateRootHash: [HashSelector!]
  validatorIndex: [IntegerSelector!]
  validatorStatus: [StringSelector!]
  validatorPubkey: [HashSelector!]
  eth1DepositRootHash: [HashSelector!]
  eth1DepositCount: [IntegerSelector!]
  eth1BlockHash: [HashSelector!]
  validatorWithdrawalCredentials: [HashSelector!]
  validatorSlashed: [BooleanSelector!]
  validatorBalance: [AmountSelector!]
  validatorBalanceChange: [AmountSelector!]
  validatorEffectiveBalance: [AmountSelector!]
  validatorActivationEpoch: [StringSelector!]
  validatorExitEpoch: [StringSelector!]
  validatorWithdrawableEpoch: [StringSelector!]
}

enum Ethereum2ValidatorUpdatesMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Epoch
  """
  epoch

  """
  Block hash
  """
  block_root_hash

  """
  Parent root hash
  """
  parent_root_hash

  """
  State root hash
  """
  state_root_hash

  """
  Eth1 deposit root hash
  """
  eth1_deposit_root_hash

  """
  Eth1 deposit count
  """
  eth1_deposit_count

  """
  Eth1 block hash
  """
  eth1_block_hash

  """
  Proposer index
  """
  proposer_index

  """
  Proposer pubkey hash
  """
  proposer_pubkey_hash

  """
  Validator index
  """
  validator_index

  """
  Validator pubkey hash
  """
  validator_pubkey_hash

  """
  Validator slashed
  """
  validator_slashed

  """
  Validator balance
  """
  validator_balance

  """
  Validator effective balance
  """
  validator_effective_balance

  """
  Validator balance change
  """
  validator_balance_change

  """
  Validator activation epoch
  """
  validator_activation_epoch

  """
  Validator exit epoch
  """
  validator_exit_epoch

  """
  Validator withdrawable epoch
  """
  validator_withdrawable_epoch
}

enum Ethereum2ValidatorUpdatesUniq {
  """
  Unique blocks
  """
  blocks

  """
  Unique date count
  """
  dates

  """
  Unique proposers
  """
  proposers

  """
  Unique validators
  """
  validators

  """
  Unique epochs
  """
  epochs
}

"""
Voluntary Exit in Ethereum v2.0 blockchain
"""
type Ethereum2VoluntaryExit {
  any(of: Ethereum2VoluntaryExitsMeasureable!): String

  """
  Block in the blockchain
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Block root hash
  """
  blockRoot(blockRootHash: [HashSelector!]): String!
  count(
    uniq: Ethereum2VoluntaryExitsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
    validatorIndex: [IntegerSelector!]
    voluntaryExitEpoch: [IntegerSelector!]
  ): Int
  countBigInt(
    uniq: Ethereum2VoluntaryExitsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockRootHash: HashSelector
    blockProposerIndex: [IntegerSelector!]
    validatorIndex: [IntegerSelector!]
    voluntaryExitEpoch: [IntegerSelector!]
  ): BigInt

  """
  Calendar date
  """
  date: Date

  """
  Block Eth1 information
  """
  eth1: Ethereum2Eth1Info!
  expression(get: String!): DecimalNumber
  maximum(
    of: Ethereum2VoluntaryExitsMeasureable!
    get: Ethereum2VoluntaryExitsMeasureable
  ): String
  minimum(
    of: Ethereum2VoluntaryExitsMeasureable!
    get: Ethereum2VoluntaryExitsMeasureable
  ): String

  """
  Block parent hash
  """
  parentRoot: String!

  """
  Block proposer
  """
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo

  """
  Signature
  """
  signature: String!

  """
  Block state root hash
  """
  stateRoot: String!

  """
  Validator
  """
  validator: Ethereum2ValidatorInfo!
  voluntaryExitEpoch: Int!

  """
  Voluntary Exit Index (0 based ) in block
  """
  voluntaryExitIndex: Int!
}

enum Ethereum2VoluntaryExitsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Block hash
  """
  block_root_hash

  """
  Block Proposer
  """
  block_proposer

  """
  Validator index
  """
  validator
}

enum Ethereum2VoluntaryExitsUniq {
  """
  Unique blocks
  """
  blocks

  """
  Unique block proposers
  """
  block_proposers

  """
  Unique date count
  """
  dates

  """
  Unique validators
  """
  validators
}

"""
Address that have been active in transfers
"""
type EthereumActiveAddress {
  """
  Transfer address
  """
  address: EthereumAddressInfo
  count(
    uniq: ActiveAddress!
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [EthereumAddressSelector!]
    entityId: EntitySelector
    sender: [EthereumAddressSelector!]
    receiver: [EthereumAddressSelector!]
    currency: [EthereumCurrencySelector!]
    external: Boolean
    success: Boolean
    amount: [AmountSelector!]
  ): Int
  countBigInt(
    uniq: ActiveAddress!
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [EthereumAddressSelector!]
    entityId: EntitySelector
    sender: [EthereumAddressSelector!]
    receiver: [EthereumAddressSelector!]
    currency: [EthereumCurrencySelector!]
    external: Boolean
    success: Boolean
    amount: [AmountSelector!]
  ): BigInt
}

"""
Address detailed information for Ethereum network
"""
type EthereumAddressInfo {
  """
  Address
  """
  address: String

  """
  Annotations ( tags ), if exists
  """
  annotation: String

  """
  Smart Contract if exists on the address
  """
  smartContract: EthereumSmartContractInfo
}

"""
Blockchain address
"""
type EthereumAddressInfoWithBalance {
  """
  Address
  """
  address: String

  """
  Annotations ( tags ), if exists
  """
  annotation: String

  """
  DEPRECATED Current address balance
  """
  balance(in: BaseCurrencyEnum): Float

  """
  DEPRECATED Balances by currencies for the address
  """
  balances(
    date: DateSelector
    time: DateTimeSelector
    currency: EthereumCurrencySelector
    height: BlockSelectorRange
  ): [EthereumBalance!]

  """
  Smart Contract if exists on the address
  """
  smartContract: EthereumSmartContractInfoWithAttributes
}

"""
Address should start from 0x and contain hex digits.
  If digits are case sensitive, address is checked against checksum according to EIP-55.
"""
input EthereumAddressSelector {
  """
  Equal to Address
  """
  is: String

  """
  Not Equal to Address
  """
  not: String

  """
  In the list of Addresses
  """
  in: [String!]

  """
  Not in the list of Addresses
  """
  notIn: [String!]
}

"""
Address should start from 0x and contain hex digits.
  If digits are case sensitive, address is checked against checksum according to EIP-55.
"""
input EthereumAddressSelectorIn {
  """
  Equal to Address
  """
  is: String

  """
  In the list of Addresses
  """
  in: [String!]
}

"""
Counts and aggregates for the address, transfer count,
                  amount, number of distinct currencies,
                  times of the first and the last transactions
"""
type EthereumAddressStat {
  """
  Address
  """
  address: Address

  """
  Balance
  """
  balance: BigInt

  """
  Call Tx Count
  """
  callTxCount: BigInt

  """
  Called Tx Count
  """
  calledTxCount: BigInt

  """
  Days with received
  """
  daysWithReceived: BigInt

  """
  Days with sent
  """
  daysWithSent: BigInt

  """
  Days with transactions
  """
  daysWithTransactions: BigInt

  """
  Days with transfers
  """
  daysWithTransfers: BigInt

  """
  Amount of paid fee
  """
  feeAmount: BigInt

  """
  First transfer at
  """
  firstTransferAt: DateTime

  """
  First tx at
  """
  firstTxAt: DateTime

  """
  Last transfer at
  """
  lastTransferAt: DateTime

  """
  Last tx at
  """
  lastTxAt: DateTime

  """
  Other Tx Count
  """
  otherTxCount: BigInt

  """
  Receive Amount
  """
  receiveAmount: BigInt

  """
  Receive from Count
  """
  receiveFromCount: BigInt

  """
  Receive from currencies
  """
  receiveFromCurrencies: BigInt

  """
  Receive tx Count
  """
  receiveTxCount: BigInt

  """
  Send Amount
  """
  sendAmount: BigInt

  """
  Send to count
  """
  sendToCount: BigInt

  """
  Send to currencies
  """
  sendToCurrencies: BigInt

  """
  Send tx count
  """
  sendTxCount: BigInt
}

"""
AddressStats
"""
type EthereumAddressStats {
  """
  Address With Statistics
  """
  address: EthereumAddressStat
}

input EthereumArgumentFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [EthereumAddressSelector!]
  caller: [EthereumAddressSelector!]
  reference: [EthereumAddressSelector!]
  value: [ArgumentValueSelector!]
  argument: [ArgumentSelector!]
  argumentType: [ArgumentTypeSelector!]
  signatureType: SignatureTypeSelector
  smartContractAddress: [EthereumAddressSelector!]
  smartContractMethod: MethodSelector
  smartContractEvent: EventSelector
  external: Boolean
  callDepth: StringSelector
}

"""
Arguments of Smart Contract Calls and Events
"""
type EthereumArguments {
  any(
    of: EthereumArgumentsMeasureable!
    as: EthereumArgumentsConvertable
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [EthereumAddressSelector!]
    caller: [EthereumAddressSelector!]
    reference: [EthereumAddressSelector!]
    value: [ArgumentValueSelector!]
    argument: [ArgumentSelector!]
    argumentType: [ArgumentTypeSelector!]
    signatureType: SignatureTypeSelector
    smartContractAddress: [EthereumAddressSelector!]
    smartContractMethod: MethodSelector
    smartContractEvent: EventSelector
    external: Boolean
    callDepth: StringSelector
  ): String

  """
  Method or event argument
  """
  argument(argument: [ArgumentSelector!], argumentType: String): ArgumentName

  """
  Block in the blockchain
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Depth of the call. Empty string for external call, then counted as 0...N, and
  the next layer is added through '-'. For example 0-3-9.
  """
  callDepth: String

  """
  Caller of the method invocation ( tx sender or another smart contract )
  """
  caller(caller: [EthereumAddressSelector!]): EthereumAddressInfo

  """
  Counts and other metrics
  """
  count(
    uniq: SmartContractArgumentsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [EthereumAddressSelector!]
    caller: [EthereumAddressSelector!]
    reference: [EthereumAddressSelector!]
    value: [ArgumentValueSelector!]
    argument: [ArgumentSelector!]
    argumentType: [ArgumentTypeSelector!]
    signatureType: SignatureTypeSelector
    smartContractAddress: [EthereumAddressSelector!]
    smartContractMethod: MethodSelector
    smartContractEvent: EventSelector
    external: Boolean
    callDepth: StringSelector
  ): Int

  """
  Counts and other metrics
  """
  countBigInt(
    uniq: SmartContractArgumentsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [EthereumAddressSelector!]
    caller: [EthereumAddressSelector!]
    reference: [EthereumAddressSelector!]
    value: [ArgumentValueSelector!]
    argument: [ArgumentSelector!]
    argumentType: [ArgumentTypeSelector!]
    signatureType: SignatureTypeSelector
    smartContractAddress: [EthereumAddressSelector!]
    smartContractMethod: MethodSelector
    smartContractEvent: EventSelector
    external: Boolean
    callDepth: StringSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  External call executed explicitly by tx sender. Internal calls executed by smart contracts.
  """
  external(external: Boolean): Boolean

  """
  Sequential index of value in array ( multi-dimensional)
  """
  index: String!
  maximum(
    of: EthereumArgumentsMeasureable!
    get: EthereumArgumentsMeasureable
    as: EthereumArgumentsConvertable
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [EthereumAddressSelector!]
    caller: [EthereumAddressSelector!]
    reference: [EthereumAddressSelector!]
    value: [ArgumentValueSelector!]
    argument: [ArgumentSelector!]
    argumentType: [ArgumentTypeSelector!]
    signatureType: SignatureTypeSelector
    smartContractAddress: [EthereumAddressSelector!]
    smartContractMethod: MethodSelector
    smartContractEvent: EventSelector
    external: Boolean
    callDepth: StringSelector
  ): String
  minimum(
    of: EthereumArgumentsMeasureable!
    get: EthereumArgumentsMeasureable
    as: EthereumArgumentsConvertable
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [EthereumAddressSelector!]
    caller: [EthereumAddressSelector!]
    reference: [EthereumAddressSelector!]
    value: [ArgumentValueSelector!]
    argument: [ArgumentSelector!]
    argumentType: [ArgumentTypeSelector!]
    signatureType: SignatureTypeSelector
    smartContractAddress: [EthereumAddressSelector!]
    smartContractMethod: MethodSelector
    smartContractEvent: EventSelector
    external: Boolean
    callDepth: StringSelector
  ): String
  number(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [EthereumAddressSelector!]
    caller: [EthereumAddressSelector!]
    reference: [EthereumAddressSelector!]
    value: [ArgumentValueSelector!]
    argument: [ArgumentSelector!]
    argumentType: [ArgumentTypeSelector!]
    signatureType: SignatureTypeSelector
    smartContractAddress: [EthereumAddressSelector!]
    smartContractMethod: MethodSelector
    smartContractEvent: EventSelector
    external: Boolean
    callDepth: StringSelector
  ): Float

  """
  Address value of method or event argument
  """
  reference(reference: [EthereumAddressSelector!]): EthereumAddressInfo

  """
  Smart contract being called
  """
  smartContract(
    smartContractAddress: [EthereumAddressSelector!]
  ): EthereumSmartContract

  """
  Contract method or event
  """
  smartContractSignature(
    smartContractMethod: MethodSelector
    smartContractEvent: EventSelector
    signatureType: SignatureTypeSelector
  ): Signature

  """
  True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
  """
  success(success: [Boolean!]): Boolean

  """
  Transaction where call happened
  """
  transaction(
    txHash: [HashSelector!]
    txFrom: [EthereumAddressSelector!]
  ): EthereumTransactionInfo

  """
  The Value of method or event argument
  """
  value(value: [ArgumentValueSelector!]): ArgumentValue
}

enum EthereumArgumentsConvertable {
  """
  Token symbol
  """
  token_symbol

  """
  Token name
  """
  token_name
}

enum EthereumArgumentsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Caller
  """
  caller

  """
  Smart Contract
  """
  smart_contract

  """
  Smart Contract Method Name
  """
  signature_name

  """
  Smart Contract Method Signature
  """
  signature

  """
  Smart Contract Method Signature
  """
  signature_type

  """
  Smart Contract Method Signature Hash
  """
  signature_hash

  """
  Call depth
  """
  call_depth

  """
  Argument
  """
  argument

  """
  Argument type
  """
  argument_type

  """
  Argument value
  """
  argument_value

  """
  Argument index
  """
  argument_index
}

"""
Balance in a currency
"""
type EthereumBalance {
  """
  Currency of transfer
  """
  currency: Currency

  """
  History of balance changes by currencies for the address
  """
  history: [EthereumBalanceChange!]
  value(in: BaseCurrencyEnum): Float
}

"""
Change of balance in a currency
"""
type EthereumBalanceChange {
  """
  Block number (height) in blockchain
  """
  block: Int!

  """
  Block timestamp
  """
  timestamp: ISO8601DateTime

  """
  Transfer amount ( positive inbound, negative outbound)
  """
  transferAmount: Float
  value: Float
}

input EthereumBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  miner: [EthereumAddressSelector!]
  blockReward: [AmountSelector!]
  transactionCount: [IntegerSelector!]
  uncleCount: [IntegerSelector!]
  size: [IntegerSelector!]
}

"""
Blocks in Ethereum blockchain
"""
type EthereumBlocks {
  any(of: EthereumBlocksMeasureable!): String
  count(
    uniq: EthereumBlocksUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    miner: [EthereumAddressSelector!]
    blockReward: [AmountSelector!]
    transactionCount: [IntegerSelector!]
    uncleCount: [IntegerSelector!]
    size: [IntegerSelector!]
  ): Int
  countBigInt(
    uniq: EthereumBlocksUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    miner: [EthereumAddressSelector!]
    blockReward: [AmountSelector!]
    transactionCount: [IntegerSelector!]
    uncleCount: [IntegerSelector!]
    size: [IntegerSelector!]
  ): BigInt

  """
  Calendar date
  """
  date: Date
  difficulty(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    miner: [EthereumAddressSelector!]
    blockReward: [AmountSelector!]
    transactionCount: [IntegerSelector!]
    uncleCount: [IntegerSelector!]
    size: [IntegerSelector!]
  ): Float
  expression(get: String!): DecimalNumber
  gasLimit(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    miner: [EthereumAddressSelector!]
    blockReward: [AmountSelector!]
    transactionCount: [IntegerSelector!]
    uncleCount: [IntegerSelector!]
    size: [IntegerSelector!]
  ): Float
  gasUsed(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    miner: [EthereumAddressSelector!]
    blockReward: [AmountSelector!]
    transactionCount: [IntegerSelector!]
    uncleCount: [IntegerSelector!]
    size: [IntegerSelector!]
  ): Float

  """
  Block hash
  """
  hash(blockHash: [HashSelector!]): String!

  """
  Block number (height) in blockchain
  """
  height(height: BlockSelector): Int!
  maximum(
    of: EthereumBlocksMeasureable!
    get: EthereumBlocksMeasureable
  ): String

  """
  Block miner
  """
  miner(miner: [EthereumAddressSelector!]): EthereumAddressInfo
  minimum(
    of: EthereumBlocksMeasureable!
    get: EthereumBlocksMeasureable
  ): String

  """
  Block nonce
  """
  nonce: Int!

  """
  Parent block hash
  """
  parentHash: String!
  reward(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    miner: [EthereumAddressSelector!]
    blockReward: [AmountSelector!]
    transactionCount: [IntegerSelector!]
    uncleCount: [IntegerSelector!]
    size: [IntegerSelector!]
  ): Float

  """
  Currency of reward
  """
  rewardCurrency: Currency
  size(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    miner: [EthereumAddressSelector!]
    blockReward: [AmountSelector!]
    transactionCount: [IntegerSelector!]
    uncleCount: [IntegerSelector!]
    size: [IntegerSelector!]
  ): Int

  """
  Block timestamp
  """
  timestamp(time: DateTimeSelector): DateTime
  totalDifficulty(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    miner: [EthereumAddressSelector!]
    blockReward: [AmountSelector!]
    transactionCount: [IntegerSelector!]
    uncleCount: [IntegerSelector!]
    size: [IntegerSelector!]
  ): Float
  transactionCount(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    miner: [EthereumAddressSelector!]
    blockReward: [AmountSelector!]
    transactionCount: [IntegerSelector!]
    uncleCount: [IntegerSelector!]
    size: [IntegerSelector!]
  ): Int
  transactionCountBigInt(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    miner: [EthereumAddressSelector!]
    blockReward: [AmountSelector!]
    transactionCount: [IntegerSelector!]
    uncleCount: [IntegerSelector!]
    size: [IntegerSelector!]
  ): BigInt
  uncleCount(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    miner: [EthereumAddressSelector!]
    blockReward: [AmountSelector!]
    transactionCount: [IntegerSelector!]
    uncleCount: [IntegerSelector!]
    size: [IntegerSelector!]
  ): Int
  uncleCountBigInt(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    miner: [EthereumAddressSelector!]
    blockReward: [AmountSelector!]
    transactionCount: [IntegerSelector!]
    uncleCount: [IntegerSelector!]
    size: [IntegerSelector!]
  ): BigInt
}

enum EthereumBlocksMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Block hash
  """
  block_hash

  """
  Block Reward
  """
  block_reward

  """
  Block Miner
  """
  miner
}

enum EthereumBlocksUniq {
  """
  Unique miner count
  """
  miners

  """
  Unique date count
  """
  dates
}

enum EthereumCallsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Caller
  """
  caller

  """
  Smart Contract
  """
  smart_contract

  """
  Smart Contract Method Name
  """
  signature_name

  """
  Smart Contract Method Signature
  """
  signature

  """
  Smart Contract Method Signature Hash
  """
  signature_hash

  """
  Call depth
  """
  call_depth
}

"""
Coinpath
"""
type EthereumCoinpath {
  """
  Summary of transfered value
  """
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """
  Block where transaction is included
  """
  block: Block

  """
  Count of transfers
  """
  count: Int

  """
  Count of transfers
  """
  countBigInt: BigInt

  """
  Currency of transfer
  """
  currency: Currency

  """
  1-based hop depth of the graph
  """
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """
  Receiver address
  """
  receiver: EthereumCoinpathAddress

  """
  Sender address
  """
  sender: EthereumCoinpathAddress

  """
  Transaction of transfer happened
  """
  transaction: TransactionHashValueTime

  """
  Attributes of transaction included in Coinpath result
  """
  transactions: [CoinpathEntry!]
}

"""
Address detailed information for Ethereum network
"""
type EthereumCoinpathAddress {
  """
  Address
  """
  address: String
  amountIn: DecimalNumber
  amountOut: DecimalNumber

  """
  Annotations ( tags ), if exists
  """
  annotation: String
  balance: DecimalNumber

  """
  Smart Contract if exists on the address
  """
  firstTxAt: DateTime

  """
  Smart Contract if exists on the address
  """
  lastTxAt: DateTime
  receiversCount: Int
  sendersCount: Int

  """
  Smart Contract if exists on the address
  """
  smartContract: EthereumSmartContractInfo

  """
  Address type
  """
  type: String
}

"""
Currency selector in Ethereum blockchain.
  Currencies supported are native ( ETH / ETC ), ERC20, ERC721 tokens.
  You can specify currency symbol or smart contract address. Symbols ETH/ETC are
reserved for native currencies in Ethereum mainnet and classic.
  Ethereum Smart contract address should start from 0x and contain 40 hex digits.
  If digits are case sensitive, address is checked against checksum according to EIP-55.
"""
input EthereumCurrencySelector {
  """
  Currency is
  """
  is: String

  """
  Currency not
  """
  not: String

  """
  Currency in the list
  """
  in: [String!]

  """
  Currency not in the list
  """
  notIn: [String!]
}

"""
Ethereum DEX attributes
"""
type EthereumDex {
  """
  Address for DEX exchange identification
  """
  address: Address!

  """
  Full name ( name for known, Protocol for unknown )
  """
  fullName: String!

  """
  Full name ( name for known, Protocol / address for unknown )
  """
  fullNameWithId: String!

  """
  Name for known exchanges
  """
  name: String
}

input EthereumDexTradeFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  txHash: HashSelector
  txSender: [EthereumAddressSelector!]
  txTo: [EthereumAddressSelector!]
  protocol: [StringSelector!]
  smartContractAddress: [EthereumAddressSelector!]
  exchangeAddress: [EthereumAddressSelector!]
  exchangeName: [StringSelector!]
  sellCurrency: [EthereumCurrencySelector!]
  buyCurrency: [EthereumCurrencySelector!]
  baseCurrency: [EthereumCurrencySelector!]
  quoteCurrency: [EthereumCurrencySelector!]
  maker: [EthereumAddressSelector!]
  makerSmartContractType: [SmartContractTypeSelector!]
  taker: [EthereumAddressSelector!]
  takerSmartContractType: [SmartContractTypeSelector!]
  makerOrTaker: [EthereumAddressSelector!]
  tradeIndex: [StringSelector!]
  buyAmount: [AmountSelector!]
  sellAmount: [AmountSelector!]
  price: [AmountSelector!]
  priceAsymmetry: [FloatSelector!]
  tradeAmountUsd: [FloatSelector!]
}

"""
Trades on DEX smart contracts
"""
type EthereumDexTrades {
  """
  Trader (maker or taker)
  """
  address(makerOrTaker: [EthereumAddressSelector!]): Address
  any(of: EthereumDexTradesMeasureable!): String
  baseAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  """
  Base currency
  """
  baseCurrency(baseCurrency: [EthereumCurrencySelector!]): Currency

  """
  Block in the blockchain
  """
  block(height: BlockSelector, time: DateTimeSelector): BlockExtended
  buyAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  """
  Maker buys this currency
  """
  buyCurrency(buyCurrency: [EthereumCurrencySelector!]): Currency
  count(
    uniq: EthereumDexTradesUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    txHash: HashSelector
    txSender: [EthereumAddressSelector!]
    txTo: [EthereumAddressSelector!]
    protocol: [StringSelector!]
    smartContractAddress: [EthereumAddressSelector!]
    exchangeAddress: [EthereumAddressSelector!]
    exchangeName: [StringSelector!]
    sellCurrency: [EthereumCurrencySelector!]
    buyCurrency: [EthereumCurrencySelector!]
    baseCurrency: [EthereumCurrencySelector!]
    quoteCurrency: [EthereumCurrencySelector!]
    maker: [EthereumAddressSelector!]
    makerSmartContractType: [SmartContractTypeSelector!]
    taker: [EthereumAddressSelector!]
    takerSmartContractType: [SmartContractTypeSelector!]
    makerOrTaker: [EthereumAddressSelector!]
    tradeIndex: [StringSelector!]
    buyAmount: [AmountSelector!]
    sellAmount: [AmountSelector!]
    price: [AmountSelector!]
    priceAsymmetry: [FloatSelector!]
    tradeAmountUsd: [FloatSelector!]
  ): Int
  countBigInt(
    uniq: EthereumDexTradesUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    txHash: HashSelector
    txSender: [EthereumAddressSelector!]
    txTo: [EthereumAddressSelector!]
    protocol: [StringSelector!]
    smartContractAddress: [EthereumAddressSelector!]
    exchangeAddress: [EthereumAddressSelector!]
    exchangeName: [StringSelector!]
    sellCurrency: [EthereumCurrencySelector!]
    buyCurrency: [EthereumCurrencySelector!]
    baseCurrency: [EthereumCurrencySelector!]
    quoteCurrency: [EthereumCurrencySelector!]
    maker: [EthereumAddressSelector!]
    makerSmartContractType: [SmartContractTypeSelector!]
    taker: [EthereumAddressSelector!]
    takerSmartContractType: [SmartContractTypeSelector!]
    makerOrTaker: [EthereumAddressSelector!]
    tradeIndex: [StringSelector!]
    buyAmount: [AmountSelector!]
    sellAmount: [AmountSelector!]
    price: [AmountSelector!]
    priceAsymmetry: [FloatSelector!]
    tradeAmountUsd: [FloatSelector!]
  ): BigInt

  """
  Calendar date
  """
  date: Date

  """
  Identification of admin / manager / factory of smart contract, executing trades
  """
  exchange(
    exchangeAddress: [EthereumAddressSelector!]
    exchangeName: [StringSelector!]
  ): EthereumDex
  expression(get: String!): DecimalNumber
  gas(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    txHash: HashSelector
    txSender: [EthereumAddressSelector!]
    txTo: [EthereumAddressSelector!]
    protocol: [StringSelector!]
    smartContractAddress: [EthereumAddressSelector!]
    exchangeAddress: [EthereumAddressSelector!]
    exchangeName: [StringSelector!]
    sellCurrency: [EthereumCurrencySelector!]
    buyCurrency: [EthereumCurrencySelector!]
    baseCurrency: [EthereumCurrencySelector!]
    quoteCurrency: [EthereumCurrencySelector!]
    maker: [EthereumAddressSelector!]
    makerSmartContractType: [SmartContractTypeSelector!]
    taker: [EthereumAddressSelector!]
    takerSmartContractType: [SmartContractTypeSelector!]
    makerOrTaker: [EthereumAddressSelector!]
    tradeIndex: [StringSelector!]
    buyAmount: [AmountSelector!]
    sellAmount: [AmountSelector!]
    price: [AmountSelector!]
    priceAsymmetry: [FloatSelector!]
    tradeAmountUsd: [FloatSelector!]
  ): Float

  """
  Gas price in Gwei
  """
  gasPrice(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    txHash: HashSelector
    txSender: [EthereumAddressSelector!]
    txTo: [EthereumAddressSelector!]
    protocol: [StringSelector!]
    smartContractAddress: [EthereumAddressSelector!]
    exchangeAddress: [EthereumAddressSelector!]
    exchangeName: [StringSelector!]
    sellCurrency: [EthereumCurrencySelector!]
    buyCurrency: [EthereumCurrencySelector!]
    baseCurrency: [EthereumCurrencySelector!]
    quoteCurrency: [EthereumCurrencySelector!]
    maker: [EthereumAddressSelector!]
    makerSmartContractType: [SmartContractTypeSelector!]
    taker: [EthereumAddressSelector!]
    takerSmartContractType: [SmartContractTypeSelector!]
    makerOrTaker: [EthereumAddressSelector!]
    tradeIndex: [StringSelector!]
    buyAmount: [AmountSelector!]
    sellAmount: [AmountSelector!]
    price: [AmountSelector!]
    priceAsymmetry: [FloatSelector!]
    tradeAmountUsd: [FloatSelector!]
  ): Float!
  gasValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  """
  Trade 'maker' side
  """
  maker(maker: [EthereumAddressSelector!]): Address
  maximum(
    of: EthereumDexTradesMeasureable!
    get: EthereumDexTradesMeasureable
  ): String
  minimum(
    of: EthereumDexTradesMeasureable!
    get: EthereumDexTradesMeasureable
  ): String
  price(
    calculate: PriceAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    txHash: HashSelector
    txSender: [EthereumAddressSelector!]
    txTo: [EthereumAddressSelector!]
    protocol: [StringSelector!]
    smartContractAddress: [EthereumAddressSelector!]
    exchangeAddress: [EthereumAddressSelector!]
    exchangeName: [StringSelector!]
    sellCurrency: [EthereumCurrencySelector!]
    buyCurrency: [EthereumCurrencySelector!]
    baseCurrency: [EthereumCurrencySelector!]
    quoteCurrency: [EthereumCurrencySelector!]
    maker: [EthereumAddressSelector!]
    makerSmartContractType: [SmartContractTypeSelector!]
    taker: [EthereumAddressSelector!]
    takerSmartContractType: [SmartContractTypeSelector!]
    makerOrTaker: [EthereumAddressSelector!]
    tradeIndex: [StringSelector!]
    buyAmount: [AmountSelector!]
    sellAmount: [AmountSelector!]
    price: [AmountSelector!]
    priceAsymmetry: [FloatSelector!]
    tradeAmountUsd: [FloatSelector!]
  ): Float

  """
  Protocol name of the smart contract
  """
  protocol(protocol: [StringSelector!]): String
  quoteAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  """
  Quote currency
  """
  quoteCurrency(quoteCurrency: [EthereumCurrencySelector!]): Currency
  quotePrice(
    calculate: PriceAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    txHash: HashSelector
    txSender: [EthereumAddressSelector!]
    txTo: [EthereumAddressSelector!]
    protocol: [StringSelector!]
    smartContractAddress: [EthereumAddressSelector!]
    exchangeAddress: [EthereumAddressSelector!]
    exchangeName: [StringSelector!]
    sellCurrency: [EthereumCurrencySelector!]
    buyCurrency: [EthereumCurrencySelector!]
    baseCurrency: [EthereumCurrencySelector!]
    quoteCurrency: [EthereumCurrencySelector!]
    maker: [EthereumAddressSelector!]
    makerSmartContractType: [SmartContractTypeSelector!]
    taker: [EthereumAddressSelector!]
    takerSmartContractType: [SmartContractTypeSelector!]
    makerOrTaker: [EthereumAddressSelector!]
    tradeIndex: [StringSelector!]
    buyAmount: [AmountSelector!]
    sellAmount: [AmountSelector!]
    price: [AmountSelector!]
    priceAsymmetry: [FloatSelector!]
    tradeAmountUsd: [FloatSelector!]
  ): Float
  sellAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  """
  Maker sells this currency
  """
  sellCurrency(sellCurrency: [EthereumCurrencySelector!]): Currency

  """
  Side of trade ( SELL / BUY )
  """
  side: TradeSide

  """
  Smart contract being called
  """
  smartContract(
    smartContractAddress: [EthereumAddressSelector!]
  ): EthereumSmartContract

  """
  Trade 'taker' side
  """
  taker(taker: [EthereumAddressSelector!]): Address

  """
  Time interval
  """
  timeInterval: TimeInterval
  tradeAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum!): Float

  """
  Index of trade in transaction, used to separate trades in transaction
  """
  tradeIndex(tradeIndex: [StringSelector!]): String

  """
  Transaction of DexTrade
  """
  transaction(
    txHash: [HashSelector!]
    txSender: [EthereumAddressSelector!]
  ): EthereumTransactionInfoExtended
}

enum EthereumDexTradesMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Buy Amount
  """
  buy_amount

  """
  Sell Amount
  """
  sell_amount

  """
  Price
  """
  price

  """
  Quote Price
  """
  quote_price

  """
  Maker
  """
  maker

  """
  Taker
  """
  taker

  """
  Buy Currency symbol
  """
  buy_currency_symbol

  """
  Buy Token address
  """
  buy_currency_address

  """
  Sell Currency symbol
  """
  sell_currency_symbol

  """
  Sell Token address
  """
  sell_currency_address
}

enum EthereumDexTradesUniq {
  """
  Unique TX senders count
  """
  senders

  """
  Unique makers count
  """
  makers

  """
  Unique makers count
  """
  takers

  """
  Unique makers & takers count
  """
  address

  """
  Buy currencies count
  """
  buy_currency

  """
  Sell currencies count
  """
  sell_currency

  """
  Base currencies count
  """
  base_currency

  """
  Quote currencies count
  """
  quote_currency

  """
  Unique blocks
  """
  blocks

  """
  Unique transactions count
  """
  txs

  """
  Unique date count
  """
  dates

  """
  Unique smart contract count
  """
  smart_contracts

  """
  Unique protocols count
  """
  protocols
}

enum EthereumEventsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Smart Contract
  """
  smart_contract

  """
  Smart Contract Event Name
  """
  signature_name

  """
  Smart Contract Event Signature
  """
  signature

  """
  Smart Contract Event Signature Hash
  """
  signature_hash
}

enum EthereumNetwork {
  """
  Ethereum Mainnet
  """
  ethereum

  """
  Ethereum Classic
  """
  ethclassic

  """
  Ethereum PoW
  """
  ethpow

  """
  Ethereum Classic ( no reorg from block 10904146)
  """
  ethclassic_reorg

  """
  Celo Alfajores Testnet
  """
  celo_alfajores

  """
  Celo Baklava Testnet
  """
  celo_baklava

  """
  DEPRECATED. Use celo_mainnet
  """
  celo_rc1

  """
  Celo Mainnet
  """
  celo_mainnet

  """
  Binance Smart Chain Mainnet
  """
  bsc

  """
  Binance Smart Chain Testnet
  """
  bsc_testnet

  """
  Goerli Ethereum Testnet
  """
  goerli

  """
  Matic (Polygon) Mainnet
  """
  matic

  """
  Velas Mainnet
  """
  velas

  """
  Velas Testnet
  """
  velas_testnet

  """
  Klaytn Mainnet
  """
  klaytn

  """
  Avalanche C-chain
  """
  avalanche

  """
  Fantom Mainnet
  """
  fantom

  """
  Moonbeam Mainnet
  """
  moonbeam

  """
  Cronos Mainnet
  """
  cronos
}

"""
Ethereum smart contract
"""
type EthereumSmartContract {
  """
  Smart Contract Address
  """
  address: Address!

  """
  Smart Contract Type
  """
  contractType: SmartContractType

  """
  Token implemented in this smart contract
  """
  currency: ScCurrency

  """
  Smart Contract Protocol Type
  """
  protocolType: String
}

input EthereumSmartContractCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [EthereumAddressSelector!]
  caller: [EthereumAddressSelector!]
  smartContractAddress: [EthereumAddressSelector!]
  smartContractMethod: MethodSelector
  smartContractType: SmartContractTypeSelector
  external: Boolean
  success: Boolean
  callDepth: StringSelector
}

"""
Smart Contract Calls
"""
type EthereumSmartContractCalls {
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [EthereumAddressSelector!]
    caller: [EthereumAddressSelector!]
    smartContractAddress: [EthereumAddressSelector!]
    smartContractMethod: MethodSelector
    smartContractType: SmartContractTypeSelector
    external: Boolean
    success: Boolean
    callDepth: StringSelector
  ): Float
  any(of: EthereumCallsMeasureable!): String

  """
  Call arguments
  """
  arguments: [ArgumentNameValue!]

  """
  Block in the blockchain
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Depth of the call. Empty string for external call, then counted as 0...N, and
  the next layer is added through '-'. For example 0-3-9.
  """
  callDepth: String

  """
  Caller of the method invocation ( tx sender or another smart contract )
  """
  caller(caller: [EthereumAddressSelector!]): EthereumAddressInfo

  """
  Counts and other metrics
  """
  count(
    uniq: SmartContractCallsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [EthereumAddressSelector!]
    caller: [EthereumAddressSelector!]
    smartContractAddress: [EthereumAddressSelector!]
    smartContractMethod: MethodSelector
    smartContractType: SmartContractTypeSelector
    external: Boolean
    success: Boolean
    callDepth: StringSelector
  ): Int

  """
  Counts and other metrics
  """
  countBigInt(
    uniq: SmartContractCallsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [EthereumAddressSelector!]
    caller: [EthereumAddressSelector!]
    smartContractAddress: [EthereumAddressSelector!]
    smartContractMethod: MethodSelector
    smartContractType: SmartContractTypeSelector
    external: Boolean
    success: Boolean
    callDepth: StringSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  External call executed explicitly by tx sender. Internal calls executed by smart contracts.
  """
  external(external: Boolean): Boolean

  """
  Gas used for transaction in external call, or by methd in internal call
  """
  gasValue(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [EthereumAddressSelector!]
    caller: [EthereumAddressSelector!]
    smartContractAddress: [EthereumAddressSelector!]
    smartContractMethod: MethodSelector
    smartContractType: SmartContractTypeSelector
    external: Boolean
    success: Boolean
    callDepth: StringSelector
  ): Float
  maximum(of: EthereumCallsMeasureable!, get: EthereumCallsMeasureable): String
  minimum(of: EthereumCallsMeasureable!, get: EthereumCallsMeasureable): String

  """
  Smart contract being called
  """
  smartContract(
    smartContractAddress: [EthereumAddressSelector!]
  ): EthereumSmartContract

  """
  Contract method invoked
  """
  smartContractMethod(smartContractMethod: MethodSelector): Method

  """
  True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
  """
  success(success: [Boolean!]): Boolean

  """
  Transaction where call happened
  """
  transaction(
    txHash: [HashSelector!]
    txFrom: [EthereumAddressSelector!]
  ): EthereumTransactionInfo
}

"""
Smart Contract Events
"""
type EthereumSmartContractEvent {
  any(of: EthereumEventsMeasureable!): String

  """
  Event arguments
  """
  arguments: [ArgumentNameValue!]

  """
  Block in the blockchain
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Counts and other metrics
  """
  count(
    uniq: SmartContractCallsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [EthereumAddressSelector!]
    smartContractType: SmartContractTypeSelector
    smartContractAddress: [EthereumAddressSelector!]
    smartContractEvent: EventSelector
  ): Int

  """
  Counts and other metrics
  """
  countBigInt(
    uniq: SmartContractCallsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [EthereumAddressSelector!]
    smartContractType: SmartContractTypeSelector
    smartContractAddress: [EthereumAddressSelector!]
    smartContractEvent: EventSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber
  maximum(
    of: EthereumEventsMeasureable!
    get: EthereumEventsMeasureable
  ): String
  minimum(
    of: EthereumEventsMeasureable!
    get: EthereumEventsMeasureable
  ): String

  """
  Smart contract being called
  """
  smartContract(
    smartContractAddress: [EthereumAddressSelector!]
  ): EthereumSmartContract

  """
  Contract event logged
  """
  smartContractEvent(smartContractEvent: EventSelector): Event

  """
  Transaction where event happened
  """
  transaction(
    txHash: [HashSelector!]
    txFrom: [EthereumAddressSelector!]
  ): EthereumTransactionInfo
}

input EthereumSmartContractEventFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [EthereumAddressSelector!]
  smartContractType: SmartContractTypeSelector
  smartContractAddress: [EthereumAddressSelector!]
  smartContractEvent: EventSelector
}

"""
Blockchain smart contract
"""
type EthereumSmartContractInfo {
  """
  Smart Contract Type
  """
  contractType: SmartContractType

  """
  Token implemented in this smart contract
  """
  currency: ScCurrency

  """
  Smart Contract Protocol Type
  """
  protocolType: String
}

"""
Blockchain smart contract
"""
type EthereumSmartContractInfoWithAttributes {
  """
  Attributes from readonly methods
  """
  attributes: [SmartContractReadonlyAttribute!]

  """
  Smart Contract Type
  """
  contractType: SmartContractType

  """
  Token implemented in this smart contract
  """
  currency: ScCurrency

  """
  Smart Contract Protocol Type
  """
  protocolType: String
}

input EthereumTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txSender: [EthereumAddressSelector!]
  txTo: [EthereumAddressSelector!]
  txCreates: [EthereumAddressSelector!]
  txIndex: TxIndexSelector
  success: Boolean
  amount: [AmountSelector!]
  gasCurrency: [EthereumCurrencySelector!]
  gasValue: [AmountSelector!]
  txType: [StringSelector!]
  feePayer: [StringSelector!]
  feeRatio: TxIndexSelector
}

"""
Blockchain transaction info
"""
type EthereumTransactionInfo {
  """
  Gas consumed
  """
  gas: Int!

  """
  Gas price in Gwei
  """
  gasPrice: Float!

  """
  Gas value cost
  """
  gasValue: Float!

  """
  Hash hex representation
  """
  hash: String!

  """
  Transaction from address
  """
  txFrom: EthereumAddressInfo!
}

"""
Blockchain Transaction Extended info
"""
type EthereumTransactionInfoExtended {
  """
  Gas consumed
  """
  gas: Int!

  """
  Gas price in Gwei
  """
  gasPrice: Float!

  """
  Gas value cost
  """
  gasValue: Float!

  """
  Hash hex representation
  """
  hash: String!

  """
  Transaction index in block, 0 based
  """
  index: Int

  """
  Transaction nonce
  """
  nonce: Int

  """
  Transaction receiver
  """
  to: EthereumAddressInfo

  """
  Transaction from address
  """
  txFrom: EthereumAddressInfo!
}

"""
Transactions in Ethereum blockchain
"""
type EthereumTransactions {
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txSender: [EthereumAddressSelector!]
    txTo: [EthereumAddressSelector!]
    txCreates: [EthereumAddressSelector!]
    txIndex: TxIndexSelector
    success: Boolean
    amount: [AmountSelector!]
    gasCurrency: [EthereumCurrencySelector!]
    gasValue: [AmountSelector!]
    txType: [StringSelector!]
    feePayer: [StringSelector!]
    feeRatio: TxIndexSelector
  ): Float
  any(of: EthereumTransactionsMeasureable!): String

  """
  Block where transfer transaction is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(
    uniq: EthereumTransactionsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txSender: [EthereumAddressSelector!]
    txTo: [EthereumAddressSelector!]
    txCreates: [EthereumAddressSelector!]
    txIndex: TxIndexSelector
    success: Boolean
    amount: [AmountSelector!]
    gasCurrency: [EthereumCurrencySelector!]
    gasValue: [AmountSelector!]
    txType: [StringSelector!]
    feePayer: [StringSelector!]
    feeRatio: TxIndexSelector
  ): Int
  countBigInt(
    uniq: EthereumTransactionsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txSender: [EthereumAddressSelector!]
    txTo: [EthereumAddressSelector!]
    txCreates: [EthereumAddressSelector!]
    txIndex: TxIndexSelector
    success: Boolean
    amount: [AmountSelector!]
    gasCurrency: [EthereumCurrencySelector!]
    gasValue: [AmountSelector!]
    txType: [StringSelector!]
    feePayer: [StringSelector!]
    feeRatio: TxIndexSelector
  ): BigInt

  """
  Created smart contract
  """
  creates(txCreates: [EthereumAddressSelector!]): EthereumAddressInfo

  """
  Currency of amount
  """
  currency: Currency

  """
  Calendar date
  """
  date: Date

  """
  Error message if any
  """
  error: String
  expression(get: String!): DecimalNumber

  """
  Fee payer
  """
  feePayer: String

  """
  Fee ratio
  """
  feeRatio: Int
  gas(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txSender: [EthereumAddressSelector!]
    txTo: [EthereumAddressSelector!]
    txCreates: [EthereumAddressSelector!]
    txIndex: TxIndexSelector
    success: Boolean
    amount: [AmountSelector!]
    gasCurrency: [EthereumCurrencySelector!]
    gasValue: [AmountSelector!]
    txType: [StringSelector!]
    feePayer: [StringSelector!]
    feeRatio: TxIndexSelector
  ): Float

  """
  Currency of gas
  """
  gasCurrency(gasCurrency: [EthereumCurrencySelector!]): Currency

  """
  Gas price in Gwei
  """
  gasPrice(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txSender: [EthereumAddressSelector!]
    txTo: [EthereumAddressSelector!]
    txCreates: [EthereumAddressSelector!]
    txIndex: TxIndexSelector
    success: Boolean
    amount: [AmountSelector!]
    gasCurrency: [EthereumCurrencySelector!]
    gasValue: [AmountSelector!]
    txType: [StringSelector!]
    feePayer: [StringSelector!]
    feeRatio: TxIndexSelector
  ): Float!
  gasValue(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txSender: [EthereumAddressSelector!]
    txTo: [EthereumAddressSelector!]
    txCreates: [EthereumAddressSelector!]
    txIndex: TxIndexSelector
    success: Boolean
    amount: [AmountSelector!]
    gasCurrency: [EthereumCurrencySelector!]
    gasValue: [AmountSelector!]
    txType: [StringSelector!]
    feePayer: [StringSelector!]
    feeRatio: TxIndexSelector
  ): Float

  """
  Hash hex representation
  """
  hash(txHash: [HashSelector!]): String!

  """
  Transaction index in block, 0 based
  """
  index(txIndex: [TxIndexSelector!]): Int
  maximum(
    of: EthereumTransactionsMeasureable!
    get: EthereumTransactionsMeasureable
  ): String
  minimum(
    of: EthereumTransactionsMeasureable!
    get: EthereumTransactionsMeasureable
  ): String

  """
  Transaction nonce
  """
  nonce: Int

  """
  Transaction sender
  """
  sender(txSender: [EthereumAddressSelector!]): EthereumAddressInfo

  """
  Success
  """
  success(success: Boolean): Boolean

  """
  Transaction receiver
  """
  to(txTo: [EthereumAddressSelector!]): EthereumAddressInfo

  """
  Transaction type
  """
  txType: String
}

enum EthereumTransactionsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Amount
  """
  amount

  """
  Transaction Sender
  """
  tx_sender

  """
  Gas value
  """
  gas_value

  """
  Gas price
  """
  gas_price

  """
  Gas used
  """
  gas

  """
  Transaction type
  """
  tx_type

  """
  Fee payer
  """
  fee_payer

  """
  Fee ratio
  """
  fee_ratio
}

enum EthereumTransactionsUniq {
  """
  Unique TX senders count
  """
  senders

  """
  Unique TX receivers count
  """
  receivers

  """
  Unique blocks
  """
  blocks

  """
  Unique date count
  """
  dates

  """
  Unique TX types count
  """
  tx_types

  """
  Unique fee payers count
  """
  fee_payers

  """
  Unique fee ratios count
  """
  fee_ratios
}

input EthereumTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [EthereumAddressSelector!]
  entityId: EntitySelector
  sender: [EthereumAddressSelector!]
  receiver: [EthereumAddressSelector!]
  currency: [EthereumCurrencySelector!]
  external: Boolean
  success: Boolean
  amount: [AmountSelector!]
}

"""
Currency transfers from/to addresses in crypto currencies
"""
type EthereumTransfers {
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [EthereumAddressSelector!]
    entityId: EntitySelector
    sender: [EthereumAddressSelector!]
    receiver: [EthereumAddressSelector!]
    currency: [EthereumCurrencySelector!]
    external: Boolean
    success: Boolean
    amount: [AmountSelector!]
  ): Float
  any(of: EthereumTransfersMeasureable!): String

  """
  Block where transfer transaction is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(
    uniq: TransfersUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [EthereumAddressSelector!]
    entityId: EntitySelector
    sender: [EthereumAddressSelector!]
    receiver: [EthereumAddressSelector!]
    currency: [EthereumCurrencySelector!]
    external: Boolean
    success: Boolean
    amount: [AmountSelector!]
  ): Int
  countBigInt(
    uniq: TransfersUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [EthereumAddressSelector!]
    entityId: EntitySelector
    sender: [EthereumAddressSelector!]
    receiver: [EthereumAddressSelector!]
    currency: [EthereumCurrencySelector!]
    external: Boolean
    success: Boolean
    amount: [AmountSelector!]
  ): BigInt

  """
  Currency of transfer
  """
  currency(currency: [EthereumCurrencySelector!]): Currency

  """
  Calendar date
  """
  date: Date

  """
  Entity identifier ( for ERC-721 NFT tokens )
  """
  entityId(entityId: EntitySelector): String
  expression(get: String!): DecimalNumber

  """
  External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts.
  """
  external(external: Boolean): Boolean
  gasValue(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: [EthereumAddressSelector!]
    entityId: EntitySelector
    sender: [EthereumAddressSelector!]
    receiver: [EthereumAddressSelector!]
    currency: [EthereumCurrencySelector!]
    external: Boolean
    success: Boolean
    amount: [AmountSelector!]
  ): Float
  maximum(
    of: EthereumTransfersMeasureable!
    get: EthereumTransfersMeasureable
  ): String
  minimum(
    of: EthereumTransfersMeasureable!
    get: EthereumTransfersMeasureable
  ): String

  """
  Transfer receiver
  """
  receiver(receiver: [EthereumAddressSelector!]): EthereumAddressInfo

  """
  Transfer sender
  """
  sender(sender: [EthereumAddressSelector!]): EthereumAddressInfo

  """
  Success flag
  """
  success(success: Boolean): Boolean

  """
  Transaction where transfer happened
  """
  transaction(
    txHash: [HashSelector!]
    txFrom: [EthereumAddressSelector!]
  ): EthereumTransactionInfo
}

enum EthereumTransfersMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Amount
  """
  amount

  """
  Sender
  """
  sender

  """
  Receiver
  """
  receiver

  """
  Currency symbol
  """
  currency_symbol

  """
  Token address
  """
  currency_address

  """
  Entity ID
  """
  entity_id
}

"""
Smart contract event
"""
type Event {
  """
  Name
  """
  name: String

  """
  Signature
  """
  signature: String

  """
  Signature Hash
  """
  signatureHash: String!
}

"""
Smart contract event. In selector you can use the name, signature or hex hash
"""
input EventSelector {
  """
  Event signature is
  """
  is: String

  """
  Event signature not
  """
  not: String

  """
  Event signature in the list
  """
  in: [String!]

  """
  Event signature not in the list
  """
  notIn: [String!]
}

enum EventType {
  """
  Transaction
  """
  transaction

  """
  Call Result
  """
  call_result
}

"""
Select by event type
"""
input EventTypeSelector {
  """
  Eventy type is
  """
  is: EventType

  """
  Eventy type not
  """
  not: EventType

  """
  Eventy type in the list
  """
  in: [EventType!]

  """
  Eventy type not in the list
  """
  notIn: [EventType!]
}

"""
Everscale Chain
"""
type Everscale {
  """
  Information about address
  """
  address(address: [AddressSelectorIn!]!): [EverscaleAddressInfo!]!

  """
  Everscale Arguments
  """
  arguments(
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txHash: StringSelector
    txType: IntegerSelector
    txAccount: StringSelector
    txAborted: StringSelector
    txOriginalStatus: EverscaleAccountStateSelector
    txEndStatus: EverscaleAccountStateSelector
    messageHash: HashSelector
    messageTypeName: EverscaleMessageTypeNameSelector
    messageDirection: EverscaleMessageDirectionSelector
    messageSender: AddressSelector
    messageReceiver: AddressSelector
    messageValue: FloatSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    argumentType: EverscaleArgumentTypeSelector
    argumentIndex: IntegerSelector
    argumentField: StringSelector
    argumentValue: StringSelector
    any: [EverscaleArgumentFilter!]
    options: QueryOptions
  ): [EverscaleArgument!]

  """
  Everscale Blocks
  """
  blocks(
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txCount: IntegerSelector
    status: IntegerSelector
    globalId: IntegerSelector
    logicalTimeStart: BigIntegerSelector
    logicalTimeEnd: BigIntegerSelector
    version: BigIntegerSelector
    afterMerge: BooleanSelector
    afterSplit: BooleanSelector
    beforeSplit: BooleanSelector
    wantMerge: BooleanSelector
    wantSplit: BooleanSelector
    verticalSeqNo: BigIntegerSelector
    minimalReferenceMasterchainBlock: BigIntegerSelector
    catchainSeqno: IntegerSelector
    validatorListHastShort: IntegerSelector
    softwareVersion: IntegerSelector
    softwareCapabilities: StringSelector
    valueFlowFromPreviousBlock: BigIntegerSelector
    valueFlowToNextBlock: BigIntegerSelector
    valueFlowImported: BigIntegerSelector
    valueFlowExported: BigIntegerSelector
    valueFlowFeesCollected: BigIntegerSelector
    valueFlowFeesImported: BigIntegerSelector
    valueFlowCreated: BigIntegerSelector
    valueFlowMinted: BigIntegerSelector
    any: [EverscaleBlockFilter!]
    options: QueryOptions
  ): [EverscaleBlock!]

  """
  Everscale Calls
  """
  calls(
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txHash: StringSelector
    txType: IntegerSelector
    txAccount: StringSelector
    txAborted: StringSelector
    txOriginalStatus: EverscaleAccountStateSelector
    txEndStatus: EverscaleAccountStateSelector
    messageHash: HashSelector
    messageTypeName: EverscaleMessageTypeNameSelector
    messageDirection: EverscaleMessageDirectionSelector
    messageSender: AddressSelector
    messageReceiver: AddressSelector
    messageValue: FloatSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    any: [EverscaleCallFilter!]
    options: QueryOptions
  ): [EverscaleCall!]

  """
  Money flow using Coinpath technology
  """
  coinpath(
    sender: AddressSelector
    receiver: AddressSelector
    currency: CurrencySelector
    initialAddress: AddressSelector
    initialDate: DateSelector
    initialTime: DateTimeSelector
    date: DateSelector
    time: DateTimeSelector
    depth: IntegerLimitedSelector
    options: CoinpathOptions
  ): [EverscaleCoinpath!]

  """
  Everscale Events
  """
  events(
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txHash: StringSelector
    txType: IntegerSelector
    txAccount: StringSelector
    txAborted: StringSelector
    txOriginalStatus: EverscaleAccountStateSelector
    txEndStatus: EverscaleAccountStateSelector
    messageHash: HashSelector
    messageTypeName: EverscaleMessageTypeNameSelector
    messageDirection: EverscaleMessageDirectionSelector
    messageSender: AddressSelector
    messageReceiver: AddressSelector
    messageValue: FloatSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    any: [EverscaleEventFilter!]
    options: QueryOptions
  ): [EverscaleEvent!]

  """
  Everscale Messages
  """
  messages(
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txHash: StringSelector
    txType: IntegerSelector
    txAccount: StringSelector
    txAborted: StringSelector
    txOriginalStatus: EverscaleAccountStateSelector
    txEndStatus: EverscaleAccountStateSelector
    messageHash: HashSelector
    messageTypeName: EverscaleMessageTypeNameSelector
    messageDirection: EverscaleMessageDirectionSelector
    messageIndex: IntegerSelector
    messageSender: StringSelector
    messageReceiver: StringSelector
    messageValue: FloatSelector
    messageCreatedLogicalTime: BigIntegerSelector
    messageIhrDisabled: BooleanSelector
    messageIrbFee: FloatSelector
    messageFwdFee: FloatSelector
    messageBounce: BooleanSelector
    messageBounced: BooleanSelector
    messageBody: StringSelector
    messageBodyHash: StringSelector
    messageData: StringSelector
    messageDataHash: StringSelector
    messageBoc: StringSelector
    any: [EverscaleMessageFilter!]
    options: QueryOptions
  ): [EverscaleMessage!]

  """
  Everscale Phases
  """
  phases(
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txHash: StringSelector
    txType: IntegerSelector
    txAccount: StringSelector
    txAborted: StringSelector
    txOriginalStatus: EverscaleAccountStateSelector
    txEndStatus: EverscaleAccountStateSelector
    phaseType: StringSelector
    phaseFee: FloatSelector
    phaseData: StringSelector
    any: [EverscalePhaseFilter!]
    options: QueryOptions
  ): [EverscalePhase!]

  """
  Everscale Transactions
  """
  transactions(
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txHash: StringSelector
    txLogicalTime: IntegerSelector
    txType: IntegerSelector
    txOriginalStatus: EverscaleAccountStateSelector
    txEndStatus: EverscaleAccountStateSelector
    txInMessageBounceFlag: BooleanSelector
    txAccount: StringSelector
    txAborted: BooleanSelector
    txDestroyed: BooleanSelector
    txOldHash: StringSelector
    txNewHash: StringSelector
    txOutMessagesCount: IntegerSelector
    txAccountFees: FloatSelector
    txExtInAndIhrInFees: FloatSelector
    txCreditFirst: BooleanSelector
    previousTxHash: StringSelector
    previousTxLogicalTime: BigIntegerSelector
    any: [EverscaleTransactionFilter!]
    options: QueryOptions
  ): [EverscaleTransaction!]

  """
  Everscale Transfers
  """
  transfers(
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txHash: StringSelector
    txType: IntegerSelector
    txAccount: StringSelector
    txAborted: StringSelector
    txOriginalStatus: EverscaleAccountStateSelector
    txEndStatus: EverscaleAccountStateSelector
    messageHash: HashSelector
    messageTypeName: EverscaleMessageTypeNameSelector
    messageDirection: EverscaleMessageDirectionSelector
    messageSender: AddressSelector
    messageReceiver: AddressSelector
    messageValue: FloatSelector
    currency: CurrencySelector
    transferSender: StringSelector
    transferReceiver: StringSelector
    entityId: BigIntIdSelector
    transferType: EverscaleTransferTypeSelector
    any: [EverscaleTransferFilter!]
    options: QueryOptions
  ): [EverscaleTransfer!]
}

enum EverscaleAccountStateEnum {
  """
  The account`s code and data have been initialized as well.
  """
  Active

  """
  Initialized account.
  """
  NonExist

  """
  The account only has a balance; its code and data have not yet been initialized.
  """
  Uninit

  """
  The account`s code and data have been replaced by a hash, but the balance is
  still stored explicitly. The balance of a frozen account.
  """
  Frozen
}

"""
Select by account state
"""
input EverscaleAccountStateSelector {
  """
  Account state is
  """
  is: EverscaleAccountStateEnum

  """
  Account state not
  """
  not: EverscaleAccountStateEnum

  """
  Account state in the list
  """
  in: [EverscaleAccountStateEnum!]

  """
  Account state not in the list
  """
  notIn: [EverscaleAccountStateEnum!]
}

"""
Address balance information for Everscale network
"""
type EverscaleAddressBalance {
  """
  Currency
  """
  currency: Currency
  value(in: BaseCurrencyEnum): Float
}

"""
Address detailed information for Everscale network
"""
type EverscaleAddressInfo {
  """
  Address
  """
  address: Address

  """
  Current address balances
  """
  balance: [EverscaleAddressBalance!]
}

"""
Argument in Everscale blockchain
"""
type EverscaleArgument {
  any(of: EverscaleArgumentMeasurable!): String

  """
  Hash of the the block
  """
  blockHash: String

  """
  Shard number of block
  """
  blockShard: String

  """
  Proposer block hash
  """
  blockWorkchain: BigInt
  count(
    uniq: EverscaleArgumentUniq
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txHash: StringSelector
    txType: IntegerSelector
    txAccount: StringSelector
    txAborted: StringSelector
    txOriginalStatus: EverscaleAccountStateSelector
    txEndStatus: EverscaleAccountStateSelector
    messageHash: HashSelector
    messageTypeName: EverscaleMessageTypeNameSelector
    messageDirection: EverscaleMessageDirectionSelector
    messageSender: AddressSelector
    messageReceiver: AddressSelector
    messageValue: FloatSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    argumentType: EverscaleArgumentTypeSelector
    argumentIndex: IntegerSelector
    argumentField: StringSelector
    argumentValue: StringSelector
  ): Int
  countBigInt(
    uniq: EverscaleArgumentUniq
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txHash: StringSelector
    txType: IntegerSelector
    txAccount: StringSelector
    txAborted: StringSelector
    txOriginalStatus: EverscaleAccountStateSelector
    txEndStatus: EverscaleAccountStateSelector
    messageHash: HashSelector
    messageTypeName: EverscaleMessageTypeNameSelector
    messageDirection: EverscaleMessageDirectionSelector
    messageSender: AddressSelector
    messageReceiver: AddressSelector
    messageValue: FloatSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    argumentType: EverscaleArgumentTypeSelector
    argumentIndex: IntegerSelector
    argumentField: StringSelector
    argumentValue: StringSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Argument Field
  """
  field: String

  """
  Number of block in the blockchains
  """
  height: BigInt

  """
  Argument Index
  """
  index: Int
  maximum(
    of: EverscaleArgumentMeasurable!
    get: EverscaleArgumentMeasurable
  ): String

  """
  messages
  """
  messages(
    messageHash: HashSelector
    messageTypeName: EverscaleMessageTypeNameSelector
    messageDirection: EverscaleMessageDirectionSelector
    messageSender: AddressSelector
    messageReceiver: AddressSelector
    messageValue: FloatSelector
  ): EverscaleMessageDimension
  minimum(
    of: EverscaleArgumentMeasurable!
    get: EverscaleArgumentMeasurable
  ): String

  """
  Previous Block
  """
  previousBlock: BigInt

  """
  Sharded Block Information
  """
  shardedBlock(
    height: BlockSelector
    hash: HashSelector
    shard: StringIdSelector
    workchain: BigIntIdSelector
  ): EverscaleShardedBlockDimension

  """
  smart contract address
  """
  smartContractAddress: Address

  """
  Contract method invoked
  """
  smartContractMethod(smartContractMethod: MethodSelector): Method

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transactions
  """
  transactions(
    txHash: HashSelector
    txType: StringSelector
    txAccount: AddressSelector
    txAborted: BigIntIdSelector
  ): EverscaleTransactionDimension

  """
  Argument Type
  """
  type: String

  """
  Argument Vlaue
  """
  value: String
}

input EverscaleArgumentFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  blockHeight: BlockSelector
  blockShard: BigIntIdSelector
  blockWorkchain: BigIntIdSelector
  shardedHeight: BlockSelector
  shardedBlockHash: HashSelector
  shardedBlockShard: BigIntIdSelector
  shardedBlockWorkchain: BigIntIdSelector
  previousBlock: BlockSelector
  txHash: StringSelector
  txType: IntegerSelector
  txAccount: StringSelector
  txAborted: StringSelector
  txOriginalStatus: EverscaleAccountStateSelector
  txEndStatus: EverscaleAccountStateSelector
  messageHash: HashSelector
  messageTypeName: EverscaleMessageTypeNameSelector
  messageDirection: EverscaleMessageDirectionSelector
  messageSender: AddressSelector
  messageReceiver: AddressSelector
  messageValue: FloatSelector
  smartContractAddress: AddressSelector
  smartContractMethod: MethodSelector
  argumentType: EverscaleArgumentTypeSelector
  argumentIndex: IntegerSelector
  argumentField: StringSelector
  argumentValue: StringSelector
}

enum EverscaleArgumentMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Hash of the the block
  """
  hash

  """
  Number of block in the blockhains
  """
  height

  """
  Shard of block in the blockhains
  """
  shard

  """
  Workchain of block in the blockhains
  """
  workchain

  """
  Number of sharded block block in the blockhains
  """
  sharded_block

  """
  Hash of the the sharded block block
  """
  sharded_block_hash

  """
  Shard of sharded block block in the blockhains
  """
  sharded_block_shard

  """
  Workchain of sharded block block in the blockhains
  """
  sharded_block_workchain

  """
  Previous Message
  """
  previous_block

  """
  Tx Hash
  """
  tx_hash

  """
  Tx Type
  """
  tx_type

  """
  Tx Account
  """
  tx_account

  """
  Tx Aborted
  """
  tx_aborted

  """
  Message Hash
  """
  message_hash

  """
  Message type name
  """
  message_type_name

  """
  Message direction
  """
  message_direction

  """
  Message sender
  """
  message_sender

  """
  Message receiver
  """
  message_receiver

  """
  Message value
  """
  message_value

  """
  Signature
  """
  signature

  """
  Signature Name
  """
  signature_name

  """
  Signature Hash
  """
  signature_hash
}

enum EverscaleArgumentTypeEnum {
  """
  Argument of call
  """
  call

  """
  Argument of event
  """
  event
}

"""
Select by argument type
"""
input EverscaleArgumentTypeSelector {
  """
  Argument type is
  """
  is: EverscaleArgumentTypeEnum

  """
  Argument type not
  """
  not: EverscaleArgumentTypeEnum

  """
  Argument type in the list
  """
  in: [EverscaleArgumentTypeEnum!]

  """
  Argument type not in the list
  """
  notIn: [EverscaleArgumentTypeEnum!]
}

enum EverscaleArgumentUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Unique Number of block in the blockchains
  """
  height

  """
  Unique Number of Shards in the blockchains
  """
  block_shard

  """
  Unique Number of workchains in the blockchains
  """
  block_workchain

  """
  Unique Number of sharded blocks in the blockchains
  """
  sharded_blocks

  """
  Unique Number of sharded block shards in the blockchains
  """
  sharded_block_shards

  """
  Unique Number of sharded block workchains in the blockchains
  """
  sharded_block_workchains

  """
  Unique Number of transactions
  """
  txs

  """
  Unique Number of messages
  """
  messages

  """
  Unique Number of smart contracts
  """
  smart_contracts

  """
  Unique Number of signatures
  """
  smart_contract_methods
}

"""
Block in Everscale blockchain
"""
type EverscaleBlock {
  """
  After Merge
  """
  afterMerge: Boolean

  """
  After Split
  """
  afterSplit: Boolean
  any(of: EverscaleBlockMeasurable!): String

  """
  Before Split
  """
  beforeSplit: Boolean

  """
  Boc
  """
  boc: String
  count(
    uniq: EverscaleBlockUniq
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txCount: IntegerSelector
    status: IntegerSelector
    globalId: IntegerSelector
    logicalTimeStart: BigIntegerSelector
    logicalTimeEnd: BigIntegerSelector
    version: BigIntegerSelector
    afterMerge: BooleanSelector
    afterSplit: BooleanSelector
    beforeSplit: BooleanSelector
    wantMerge: BooleanSelector
    wantSplit: BooleanSelector
    verticalSeqNo: BigIntegerSelector
    minimalReferenceMasterchainBlock: BigIntegerSelector
    catchainSeqno: IntegerSelector
    validatorListHastShort: IntegerSelector
    softwareVersion: IntegerSelector
    softwareCapabilities: StringSelector
    valueFlowFromPreviousBlock: BigIntegerSelector
    valueFlowToNextBlock: BigIntegerSelector
    valueFlowImported: BigIntegerSelector
    valueFlowExported: BigIntegerSelector
    valueFlowFeesCollected: BigIntegerSelector
    valueFlowFeesImported: BigIntegerSelector
    valueFlowCreated: BigIntegerSelector
    valueFlowMinted: BigIntegerSelector
  ): Int
  countBigInt(
    uniq: EverscaleBlockUniq
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txCount: IntegerSelector
    status: IntegerSelector
    globalId: IntegerSelector
    logicalTimeStart: BigIntegerSelector
    logicalTimeEnd: BigIntegerSelector
    version: BigIntegerSelector
    afterMerge: BooleanSelector
    afterSplit: BooleanSelector
    beforeSplit: BooleanSelector
    wantMerge: BooleanSelector
    wantSplit: BooleanSelector
    verticalSeqNo: BigIntegerSelector
    minimalReferenceMasterchainBlock: BigIntegerSelector
    catchainSeqno: IntegerSelector
    validatorListHastShort: IntegerSelector
    softwareVersion: IntegerSelector
    softwareCapabilities: StringSelector
    valueFlowFromPreviousBlock: BigIntegerSelector
    valueFlowToNextBlock: BigIntegerSelector
    valueFlowImported: BigIntegerSelector
    valueFlowExported: BigIntegerSelector
    valueFlowFeesCollected: BigIntegerSelector
    valueFlowFeesImported: BigIntegerSelector
    valueFlowCreated: BigIntegerSelector
    valueFlowMinted: BigIntegerSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Information about block general
  """
  general(
    catchainSeqno: IntegerSelector
    validatorListHastShort: IntegerSelector
    softwareVersion: IntegerSelector
    softwareCapabilities: StringSelector
  ): EverscaleGeneralDimension

  """
  Global Id
  """
  globalId: Int

  """
  Hash of the the block
  """
  hash: String

  """
  Number of block in the blockchains
  """
  height: BigInt

  """
  Logical Time end
  """
  logicalTimeEnd: BigInt

  """
  Logical Time Start
  """
  logicalTimeStart: BigInt
  maximum(of: EverscaleBlockMeasurable!, get: EverscaleBlockMeasurable): String

  """
  Minimal Reference Masterchain Block
  """
  minimalReferenceMasterchainBlock: BigInt
  minimum(of: EverscaleBlockMeasurable!, get: EverscaleBlockMeasurable): String

  """
  Previous Block
  """
  previousBlock: BigInt

  """
  Random Seed
  """
  randomSeed: String

  """
  Shard number of block
  """
  shard: String

  """
  Sharded Block Information
  """
  shardedBlock(
    height: BlockSelector
    hash: HashSelector
    shard: StringIdSelector
    workchain: BigIntIdSelector
  ): EverscaleShardedBlockDimension

  """
  Status
  """
  status: Int

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Tx Count
  """
  txCount: BigInt
  value(
    valueFlowFromPreviousBlock: BigIntegerSelector
    valueFlowToNextBlock: BigIntegerSelector
    valueFlowImported: BigIntegerSelector
    valueFlowExported: BigIntegerSelector
    valueFlowFeesCollected: BigIntegerSelector
    valueFlowFeesImported: BigIntegerSelector
    valueFlowCreated: BigIntegerSelector
    valueFlowMinted: BigIntegerSelector
  ): EverscaleValueDimension

  """
  Version
  """
  version: BigInt

  """
  Vertical Sequence
  """
  verticalSeqNo: BigInt

  """
  Want Merge
  """
  wantMerge: Boolean

  """
  Want Split
  """
  wantSplit: Boolean

  """
  Proposer block hash
  """
  workchain: BigInt
}

input EverscaleBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  blockHeight: BlockSelector
  blockShard: BigIntIdSelector
  blockWorkchain: BigIntIdSelector
  shardedHeight: BlockSelector
  shardedBlockHash: HashSelector
  shardedBlockShard: BigIntIdSelector
  shardedBlockWorkchain: BigIntIdSelector
  previousBlock: BlockSelector
  txCount: IntegerSelector
  status: IntegerSelector
  globalId: IntegerSelector
  logicalTimeStart: BigIntegerSelector
  logicalTimeEnd: BigIntegerSelector
  version: BigIntegerSelector
  afterMerge: BooleanSelector
  afterSplit: BooleanSelector
  beforeSplit: BooleanSelector
  wantMerge: BooleanSelector
  wantSplit: BooleanSelector
  verticalSeqNo: BigIntegerSelector
  minimalReferenceMasterchainBlock: BigIntegerSelector
  catchainSeqno: IntegerSelector
  validatorListHastShort: IntegerSelector
  softwareVersion: IntegerSelector
  softwareCapabilities: StringSelector
  valueFlowFromPreviousBlock: BigIntegerSelector
  valueFlowToNextBlock: BigIntegerSelector
  valueFlowImported: BigIntegerSelector
  valueFlowExported: BigIntegerSelector
  valueFlowFeesCollected: BigIntegerSelector
  valueFlowFeesImported: BigIntegerSelector
  valueFlowCreated: BigIntegerSelector
  valueFlowMinted: BigIntegerSelector
}

enum EverscaleBlockMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Hash of the the block
  """
  hash

  """
  Number of block in the blockhains
  """
  height

  """
  Shard of block in the blockhains
  """
  shard

  """
  Workchain of block in the blockhains
  """
  workchain

  """
  Number of sharded block block in the blockhains
  """
  sharded_block

  """
  Hash of the the sharded block block
  """
  sharded_block_hash

  """
  Shard of sharded block block in the blockhains
  """
  sharded_block_shard

  """
  Workchain of sharded block block in the blockhains
  """
  sharded_block_workchain

  """
  Previous Block
  """
  previous_block

  """
  Count of transactions in this block
  """
  tx_count

  """
  Status
  """
  status

  """
  Global ID
  """
  global_id

  """
  Logical Time Start
  """
  logical_time_start

  """
  Logical Time End
  """
  logical_time_end

  """
  Version
  """
  version

  """
  After Merge
  """
  after_merge

  """
  After Split
  """
  after_split

  """
  Before Split
  """
  before_split

  """
  Want Merge
  """
  want_merge

  """
  Want Split
  """
  want_split

  """
  Vertical Sequence
  """
  vertical_seq_no

  """
  Minimal Reference Masterchain Block
  """
  minimal_reference_masterchain_block

  """
  Value From Previous Block
  """
  value_flow_from_previous_block

  """
  Value To Previous Block
  """
  value_flow_to_previous_block

  """
  Value Imported
  """
  value_flow_imported

  """
  Value Exported
  """
  value_flow_exported

  """
  Value Fees collected
  """
  value_flow_fees_collected

  """
  Value Fees imported
  """
  value_flow_fees_imported

  """
  Value created
  """
  value_flow_created

  """
  Value minted
  """
  value_flow_minted
}

enum EverscaleBlockUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Unique Number of block in the blockchains
  """
  height

  """
  Unique Number of Shards in the blockchains
  """
  block_shard

  """
  Unique Number of workchains in the blockchains
  """
  block_workchain

  """
  Unique Number of sharded blocks in the blockchains
  """
  sharded_blocks

  """
  Unique Number of sharded block shards in the blockchains
  """
  sharded_block_shards

  """
  Unique Number of sharded block workchains in the blockchains
  """
  sharded_block_workchains
}

"""
Call in Everscale blockchain
"""
type EverscaleCall {
  any(of: EverscaleCallMeasurable!): String

  """
  Hash of the the block
  """
  blockHash: String

  """
  Shard number of block
  """
  blockShard: String

  """
  Proposer block hash
  """
  blockWorkchain: BigInt
  count(
    uniq: EverscaleCallUniq
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txHash: StringSelector
    txType: IntegerSelector
    txAccount: StringSelector
    txAborted: StringSelector
    txOriginalStatus: EverscaleAccountStateSelector
    txEndStatus: EverscaleAccountStateSelector
    messageHash: HashSelector
    messageTypeName: EverscaleMessageTypeNameSelector
    messageDirection: EverscaleMessageDirectionSelector
    messageSender: AddressSelector
    messageReceiver: AddressSelector
    messageValue: FloatSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
  ): Int
  countBigInt(
    uniq: EverscaleCallUniq
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txHash: StringSelector
    txType: IntegerSelector
    txAccount: StringSelector
    txAborted: StringSelector
    txOriginalStatus: EverscaleAccountStateSelector
    txEndStatus: EverscaleAccountStateSelector
    messageHash: HashSelector
    messageTypeName: EverscaleMessageTypeNameSelector
    messageDirection: EverscaleMessageDirectionSelector
    messageSender: AddressSelector
    messageReceiver: AddressSelector
    messageValue: FloatSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Number of block in the blockchains
  """
  height: BigInt
  maximum(of: EverscaleCallMeasurable!, get: EverscaleCallMeasurable): String

  """
  messages
  """
  messages(
    messageHash: HashSelector
    messageTypeName: EverscaleMessageTypeNameSelector
    messageDirection: EverscaleMessageDirectionSelector
    messageSender: AddressSelector
    messageReceiver: AddressSelector
    messageValue: FloatSelector
  ): EverscaleMessageDimension
  minimum(of: EverscaleCallMeasurable!, get: EverscaleCallMeasurable): String

  """
  Previous Block
  """
  previousBlock: BigInt

  """
  Sharded Block Information
  """
  shardedBlock(
    height: BlockSelector
    hash: HashSelector
    shard: StringIdSelector
    workchain: BigIntIdSelector
  ): EverscaleShardedBlockDimension

  """
  smart contract address
  """
  smartContractAddress: Address

  """
  Contract method invoked
  """
  smartContractMethod(smartContractMethod: MethodSelector): Method

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transactions
  """
  transactions(
    txHash: HashSelector
    txType: StringSelector
    txAccount: AddressSelector
    txAborted: BigIntIdSelector
  ): EverscaleTransactionDimension
}

input EverscaleCallFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  blockHeight: BlockSelector
  blockShard: BigIntIdSelector
  blockWorkchain: BigIntIdSelector
  shardedHeight: BlockSelector
  shardedBlockHash: HashSelector
  shardedBlockShard: BigIntIdSelector
  shardedBlockWorkchain: BigIntIdSelector
  previousBlock: BlockSelector
  txHash: StringSelector
  txType: IntegerSelector
  txAccount: StringSelector
  txAborted: StringSelector
  txOriginalStatus: EverscaleAccountStateSelector
  txEndStatus: EverscaleAccountStateSelector
  messageHash: HashSelector
  messageTypeName: EverscaleMessageTypeNameSelector
  messageDirection: EverscaleMessageDirectionSelector
  messageSender: AddressSelector
  messageReceiver: AddressSelector
  messageValue: FloatSelector
  smartContractAddress: AddressSelector
  smartContractMethod: MethodSelector
}

enum EverscaleCallMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Hash of the the block
  """
  hash

  """
  Number of block in the blockhains
  """
  height

  """
  Shard of block in the blockhains
  """
  shard

  """
  Workchain of block in the blockhains
  """
  workchain

  """
  Number of sharded block block in the blockhains
  """
  sharded_block

  """
  Hash of the the sharded block block
  """
  sharded_block_hash

  """
  Shard of sharded block block in the blockhains
  """
  sharded_block_shard

  """
  Workchain of sharded block block in the blockhains
  """
  sharded_block_workchain

  """
  Previous Message
  """
  previous_block

  """
  Tx Hash
  """
  tx_hash

  """
  Tx Type
  """
  tx_type

  """
  Tx Account
  """
  tx_account

  """
  Tx Aborted
  """
  tx_aborted

  """
  Message Hash
  """
  message_hash

  """
  Message type name
  """
  message_type_name

  """
  Message direction
  """
  message_direction

  """
  Message sender
  """
  message_sender

  """
  Message receiver
  """
  message_receiver

  """
  Message value
  """
  message_value

  """
  Signature
  """
  signature

  """
  Signature Name
  """
  signature_name

  """
  Signature Hash
  """
  signature_hash
}

enum EverscaleCallUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Unique Number of block in the blockchains
  """
  height

  """
  Unique Number of Shards in the blockchains
  """
  block_shard

  """
  Unique Number of workchains in the blockchains
  """
  block_workchain

  """
  Unique Number of sharded blocks in the blockchains
  """
  sharded_blocks

  """
  Unique Number of sharded block shards in the blockchains
  """
  sharded_block_shards

  """
  Unique Number of sharded block workchains in the blockchains
  """
  sharded_block_workchains

  """
  Unique Number of transactions
  """
  txs

  """
  Unique Number of messages
  """
  messages

  """
  Unique Number of smart contracts
  """
  smart_contracts

  """
  Unique Number of signatures
  """
  smart_contract_methods
}

"""
Everscale Coinpath
"""
type EverscaleCoinpath {
  """
  Summary of transfered value
  """
  amount(in: BaseCurrencyEnum): Float
  any(of: EverscaleCoinpathMeasureable!): String

  """
  Block where transaction is included
  """
  block: Block

  """
  Count of transfers
  """
  count: Int

  """
  Count of transfers
  """
  countBigInt: BigInt

  """
  Currency of transfer
  """
  currency: Currency

  """
  1-based hop depth of the graph
  """
  depth: Int
  maximum(
    of: EverscaleCoinpathMeasureable!
    get: EverscaleCoinpathMeasureable
  ): String
  minimum(
    of: EverscaleCoinpathMeasureable!
    get: EverscaleCoinpathMeasureable
  ): String

  """
  Receiver address
  """
  receiver: Address

  """
  Sender address
  """
  sender: Address

  """
  Transaction of transfer happened
  """
  transaction: TransactionHashValueTime
}

enum EverscaleCoinpathMeasureable {
  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Version
  """
  tx_hash

  """
  Sender
  """
  sender

  """
  Receiver
  """
  receiver

  """
  Depth
  """
  depth
}

"""
Event in Everscale blockchain
"""
type EverscaleEvent {
  any(of: EverscaleEventMeasurable!): String

  """
  Hash of the the block
  """
  blockHash: String

  """
  Shard number of block
  """
  blockShard: String

  """
  Proposer block hash
  """
  blockWorkchain: BigInt
  count(
    uniq: EverscaleEventUniq
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txHash: StringSelector
    txType: IntegerSelector
    txAccount: StringSelector
    txAborted: StringSelector
    txOriginalStatus: EverscaleAccountStateSelector
    txEndStatus: EverscaleAccountStateSelector
    messageHash: HashSelector
    messageTypeName: EverscaleMessageTypeNameSelector
    messageDirection: EverscaleMessageDirectionSelector
    messageSender: AddressSelector
    messageReceiver: AddressSelector
    messageValue: FloatSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
  ): Int
  countBigInt(
    uniq: EverscaleEventUniq
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txHash: StringSelector
    txType: IntegerSelector
    txAccount: StringSelector
    txAborted: StringSelector
    txOriginalStatus: EverscaleAccountStateSelector
    txEndStatus: EverscaleAccountStateSelector
    messageHash: HashSelector
    messageTypeName: EverscaleMessageTypeNameSelector
    messageDirection: EverscaleMessageDirectionSelector
    messageSender: AddressSelector
    messageReceiver: AddressSelector
    messageValue: FloatSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Number of block in the blockchains
  """
  height: BigInt
  maximum(of: EverscaleEventMeasurable!, get: EverscaleEventMeasurable): String

  """
  messages
  """
  messages(
    messageHash: HashSelector
    messageTypeName: EverscaleMessageTypeNameSelector
    messageDirection: EverscaleMessageDirectionSelector
    messageSender: AddressSelector
    messageReceiver: AddressSelector
    messageValue: FloatSelector
  ): EverscaleMessageDimension
  minimum(of: EverscaleEventMeasurable!, get: EverscaleEventMeasurable): String

  """
  Previous Block
  """
  previousBlock: BigInt

  """
  Sharded Block Information
  """
  shardedBlock(
    height: BlockSelector
    hash: HashSelector
    shard: StringIdSelector
    workchain: BigIntIdSelector
  ): EverscaleShardedBlockDimension

  """
  smart contract address
  """
  smartContractAddress: Address

  """
  Contract method invoked
  """
  smartContractMethod(smartContractMethod: MethodSelector): Method

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transactions
  """
  transactions(
    txHash: HashSelector
    txType: StringSelector
    txAccount: AddressSelector
    txAborted: BigIntIdSelector
  ): EverscaleTransactionDimension
}

input EverscaleEventFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  blockHeight: BlockSelector
  blockShard: BigIntIdSelector
  blockWorkchain: BigIntIdSelector
  shardedHeight: BlockSelector
  shardedBlockHash: HashSelector
  shardedBlockShard: BigIntIdSelector
  shardedBlockWorkchain: BigIntIdSelector
  previousBlock: BlockSelector
  txHash: StringSelector
  txType: IntegerSelector
  txAccount: StringSelector
  txAborted: StringSelector
  txOriginalStatus: EverscaleAccountStateSelector
  txEndStatus: EverscaleAccountStateSelector
  messageHash: HashSelector
  messageTypeName: EverscaleMessageTypeNameSelector
  messageDirection: EverscaleMessageDirectionSelector
  messageSender: AddressSelector
  messageReceiver: AddressSelector
  messageValue: FloatSelector
  smartContractAddress: AddressSelector
  smartContractMethod: MethodSelector
}

enum EverscaleEventMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Hash of the the block
  """
  hash

  """
  Number of block in the blockhains
  """
  height

  """
  Shard of block in the blockhains
  """
  shard

  """
  Workchain of block in the blockhains
  """
  workchain

  """
  Number of sharded block block in the blockhains
  """
  sharded_block

  """
  Hash of the the sharded block block
  """
  sharded_block_hash

  """
  Shard of sharded block block in the blockhains
  """
  sharded_block_shard

  """
  Workchain of sharded block block in the blockhains
  """
  sharded_block_workchain

  """
  Previous Message
  """
  previous_block

  """
  Tx Hash
  """
  tx_hash

  """
  Tx Type
  """
  tx_type

  """
  Tx Account
  """
  tx_account

  """
  Tx Aborted
  """
  tx_aborted

  """
  Message Hash
  """
  message_hash

  """
  Message type name
  """
  message_type_name

  """
  Message direction
  """
  message_direction

  """
  Message sender
  """
  message_sender

  """
  Message receiver
  """
  message_receiver

  """
  Message value
  """
  message_value

  """
  Signature
  """
  signature

  """
  Signature Name
  """
  signature_name

  """
  Signature Hash
  """
  signature_hash
}

enum EverscaleEventUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Unique Number of block in the blockchains
  """
  height

  """
  Unique Number of Shards in the blockchains
  """
  block_shard

  """
  Unique Number of workchains in the blockchains
  """
  block_workchain

  """
  Unique Number of sharded blocks in the blockchains
  """
  sharded_blocks

  """
  Unique Number of sharded block shards in the blockchains
  """
  sharded_block_shards

  """
  Unique Number of sharded block workchains in the blockchains
  """
  sharded_block_workchains

  """
  Unique Number of transactions
  """
  txs

  """
  Unique Number of messages
  """
  messages

  """
  Unique Number of smart contracts
  """
  smart_contracts

  """
  Unique Number of signatures
  """
  smart_contract_methods
}

"""
General Block information
"""
type EverscaleGeneralDimension {
  """
  Catchain Sequence
  """
  catchainSeqno: BigInt

  """
  Software capabilities
  """
  softwareCapabilities: String

  """
  Software version
  """
  softwareVersion: BigInt

  """
  Validator List Hast Short
  """
  validatorListHashShort: BigInt
}

"""
Message in Everscale blockchain
"""
type EverscaleMessage {
  any(of: EverscaleMessageMeasurable!): String

  """
  Hash of the the block
  """
  blockHash: String

  """
  Shard number of block
  """
  blockShard: String

  """
  Proposer block hash
  """
  blockWorkchain: BigInt

  """
  Message boc
  """
  boc: String

  """
  Message body
  """
  body: String

  """
  Message body hash
  """
  bodyHash: String

  """
  Message Bounce
  """
  bounce: Boolean

  """
  Message bounced
  """
  bounced: Boolean
  count(
    uniq: EverscaleMessageUniq
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txHash: StringSelector
    txType: IntegerSelector
    txAccount: StringSelector
    txAborted: StringSelector
    txOriginalStatus: EverscaleAccountStateSelector
    txEndStatus: EverscaleAccountStateSelector
    messageHash: HashSelector
    messageTypeName: EverscaleMessageTypeNameSelector
    messageDirection: EverscaleMessageDirectionSelector
    messageIndex: IntegerSelector
    messageSender: StringSelector
    messageReceiver: StringSelector
    messageValue: FloatSelector
    messageCreatedLogicalTime: BigIntegerSelector
    messageIhrDisabled: BooleanSelector
    messageIrbFee: FloatSelector
    messageFwdFee: FloatSelector
    messageBounce: BooleanSelector
    messageBounced: BooleanSelector
    messageBody: StringSelector
    messageBodyHash: StringSelector
    messageData: StringSelector
    messageDataHash: StringSelector
    messageBoc: StringSelector
  ): Int
  countBigInt(
    uniq: EverscaleMessageUniq
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txHash: StringSelector
    txType: IntegerSelector
    txAccount: StringSelector
    txAborted: StringSelector
    txOriginalStatus: EverscaleAccountStateSelector
    txEndStatus: EverscaleAccountStateSelector
    messageHash: HashSelector
    messageTypeName: EverscaleMessageTypeNameSelector
    messageDirection: EverscaleMessageDirectionSelector
    messageIndex: IntegerSelector
    messageSender: StringSelector
    messageReceiver: StringSelector
    messageValue: FloatSelector
    messageCreatedLogicalTime: BigIntegerSelector
    messageIhrDisabled: BooleanSelector
    messageIrbFee: FloatSelector
    messageFwdFee: FloatSelector
    messageBounce: BooleanSelector
    messageBounced: BooleanSelector
    messageBody: StringSelector
    messageBodyHash: StringSelector
    messageData: StringSelector
    messageDataHash: StringSelector
    messageBoc: StringSelector
  ): BigInt

  """
  Message created logical time
  """
  createdLogicalTime: BigInt

  """
  Message data
  """
  data: String

  """
  Message data hash
  """
  dataHash: String

  """
  Calendar date
  """
  date: Date

  """
  Message Direction
  """
  direction: String
  expression(get: String!): DecimalNumber

  """
  Message fwd fee
  """
  fwdFee: Float

  """
  Message Hash
  """
  hash: String

  """
  Number of block in the blockchains
  """
  height: BigInt

  """
  Message ihr disabled
  """
  ihrDisabled: Boolean

  """
  Message ihr fee
  """
  ihrFee: Float

  """
  Message index
  """
  index: Int
  maximum(
    of: EverscaleMessageMeasurable!
    get: EverscaleMessageMeasurable
  ): String
  minimum(
    of: EverscaleMessageMeasurable!
    get: EverscaleMessageMeasurable
  ): String

  """
  Previous Block
  """
  previousBlock: BigInt

  """
  Message receiver
  """
  receiver: Address

  """
  Message sender
  """
  sender: Address

  """
  Sharded Block Information
  """
  shardedBlock(
    height: BlockSelector
    hash: HashSelector
    shard: StringIdSelector
    workchain: BigIntIdSelector
  ): EverscaleShardedBlockDimension

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transactions
  """
  transactions(
    txHash: HashSelector
    txType: StringSelector
    txAccount: AddressSelector
    txAborted: BigIntIdSelector
  ): EverscaleTransactionDimension

  """
  Message Type Name
  """
  typeName: String
  value(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txHash: StringSelector
    txType: IntegerSelector
    txAccount: StringSelector
    txAborted: StringSelector
    txOriginalStatus: EverscaleAccountStateSelector
    txEndStatus: EverscaleAccountStateSelector
    messageHash: HashSelector
    messageTypeName: EverscaleMessageTypeNameSelector
    messageDirection: EverscaleMessageDirectionSelector
    messageIndex: IntegerSelector
    messageSender: StringSelector
    messageReceiver: StringSelector
    messageValue: FloatSelector
    messageCreatedLogicalTime: BigIntegerSelector
    messageIhrDisabled: BooleanSelector
    messageIrbFee: FloatSelector
    messageFwdFee: FloatSelector
    messageBounce: BooleanSelector
    messageBounced: BooleanSelector
    messageBody: StringSelector
    messageBodyHash: StringSelector
    messageData: StringSelector
    messageDataHash: StringSelector
    messageBoc: StringSelector
  ): Float
}

"""
Information about message
"""
type EverscaleMessageDimension {
  """
  Message Direction
  """
  direction: String

  """
  Message Hash
  """
  hash: String

  """
  Message Receiver
  """
  receiver: Address

  """
  Message Sender
  """
  sender: Address

  """
  Message Type
  """
  typeName: String

  """
  Message value
  """
  value: Float
}

enum EverscaleMessageDirectionEnum {
  """
  Inbound message
  """
  in

  """
  Outbound Message
  """
  out
}

"""
Select by message direction
"""
input EverscaleMessageDirectionSelector {
  """
  Message Direction is
  """
  is: EverscaleMessageDirectionEnum

  """
  Message Direction not
  """
  not: EverscaleMessageDirectionEnum

  """
  Message Direction in the list
  """
  in: [EverscaleMessageDirectionEnum!]

  """
  Message Direction not in the list
  """
  notIn: [EverscaleMessageDirectionEnum!]
}

input EverscaleMessageFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  blockHeight: BlockSelector
  blockShard: BigIntIdSelector
  blockWorkchain: BigIntIdSelector
  shardedHeight: BlockSelector
  shardedBlockHash: HashSelector
  shardedBlockShard: BigIntIdSelector
  shardedBlockWorkchain: BigIntIdSelector
  previousBlock: BlockSelector
  txHash: StringSelector
  txType: IntegerSelector
  txAccount: StringSelector
  txAborted: StringSelector
  txOriginalStatus: EverscaleAccountStateSelector
  txEndStatus: EverscaleAccountStateSelector
  messageHash: HashSelector
  messageTypeName: EverscaleMessageTypeNameSelector
  messageDirection: EverscaleMessageDirectionSelector
  messageIndex: IntegerSelector
  messageSender: StringSelector
  messageReceiver: StringSelector
  messageValue: FloatSelector
  messageCreatedLogicalTime: BigIntegerSelector
  messageIhrDisabled: BooleanSelector
  messageIrbFee: FloatSelector
  messageFwdFee: FloatSelector
  messageBounce: BooleanSelector
  messageBounced: BooleanSelector
  messageBody: StringSelector
  messageBodyHash: StringSelector
  messageData: StringSelector
  messageDataHash: StringSelector
  messageBoc: StringSelector
}

enum EverscaleMessageMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Hash of the the block
  """
  hash

  """
  Number of block in the blockhains
  """
  height

  """
  Shard of block in the blockhains
  """
  shard

  """
  Workchain of block in the blockhains
  """
  workchain

  """
  Number of sharded block block in the blockhains
  """
  sharded_block

  """
  Hash of the the sharded block block
  """
  sharded_block_hash

  """
  Shard of sharded block block in the blockhains
  """
  sharded_block_shard

  """
  Workchain of sharded block block in the blockhains
  """
  sharded_block_workchain

  """
  Previous Message
  """
  previous_block

  """
  Tx Hash
  """
  tx_hash

  """
  Tx Type
  """
  tx_type

  """
  Tx Account
  """
  tx_account

  """
  Message Hash
  """
  message_hash

  """
  Message Type Name
  """
  message_type_name

  """
  Message direction
  """
  message_direction

  """
  Message Index
  """
  message_index

  """
  Message sender
  """
  message_sender

  """
  Message receiver
  """
  message_receiver

  """
  Message value
  """
  message_value

  """
  Message created logical time
  """
  created_logical_time

  """
  Message Ihr Disabled
  """
  ihr_disabled

  """
  Message ihr fee
  """
  ihr_fee

  """
  Message fwd fee
  """
  fwd_fee

  """
  Message bounce
  """
  bounce

  """
  Message bounced
  """
  bounced

  """
  Message body
  """
  body

  """
  Message body hash
  """
  body_hash

  """
  Message data
  """
  data

  """
  Message data hash
  """
  data_hash

  """
  Message boc
  """
  boc
}

enum EverscaleMessageTypeNameEnum {
  """
  Internal Message
  """
  Internal

  """
  ExtInt Message
  """
  ExtInt

  """
  ExtOut Message
  """
  ExtOut
}

"""
Select by message type name
"""
input EverscaleMessageTypeNameSelector {
  """
  Message type name is
  """
  is: EverscaleMessageTypeNameEnum

  """
  Message type name not
  """
  not: EverscaleMessageTypeNameEnum

  """
  Message type name in the list
  """
  in: [EverscaleMessageTypeNameEnum!]

  """
  Message type name not in the list
  """
  notIn: [EverscaleMessageTypeNameEnum!]
}

enum EverscaleMessageUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Unique Number of block in the blockchains
  """
  height

  """
  Unique Number of Shards in the blockchains
  """
  block_shard

  """
  Unique Number of workchains in the blockchains
  """
  block_workchain

  """
  Unique Number of sharded blocks in the blockchains
  """
  sharded_blocks

  """
  Unique Number of sharded block shards in the blockchains
  """
  sharded_block_shards

  """
  Unique Number of sharded block workchains in the blockchains
  """
  sharded_block_workchains

  """
  Unique Number of transactions
  """
  txs

  """
  Unique Number of Messages
  """
  messages

  """
  Unique Number of Message Receivers
  """
  message_receiver

  """
  Unique Number of Message Senders
  """
  message_sender
}

enum EverscaleNetwork {
  """
  Everscale
  """
  everscale
}

"""
Phase in Everscale blockchain
"""
type EverscalePhase {
  any(of: EverscalePhaseMeasurable!): String

  """
  Hash of the the block
  """
  blockHash: String

  """
  Shard number of block
  """
  blockShard: String

  """
  Proposer block hash
  """
  blockWorkchain: BigInt
  count(
    uniq: EverscalePhaseUniq
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txHash: StringSelector
    txType: IntegerSelector
    txAccount: StringSelector
    txAborted: StringSelector
    txOriginalStatus: EverscaleAccountStateSelector
    txEndStatus: EverscaleAccountStateSelector
    phaseType: StringSelector
    phaseFee: FloatSelector
    phaseData: StringSelector
  ): Int
  countBigInt(
    uniq: EverscalePhaseUniq
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txHash: StringSelector
    txType: IntegerSelector
    txAccount: StringSelector
    txAborted: StringSelector
    txOriginalStatus: EverscaleAccountStateSelector
    txEndStatus: EverscaleAccountStateSelector
    phaseType: StringSelector
    phaseFee: FloatSelector
    phaseData: StringSelector
  ): BigInt

  """
  Phase data
  """
  data: String

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber
  fee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txHash: StringSelector
    txType: IntegerSelector
    txAccount: StringSelector
    txAborted: StringSelector
    txOriginalStatus: EverscaleAccountStateSelector
    txEndStatus: EverscaleAccountStateSelector
    phaseType: StringSelector
    phaseFee: FloatSelector
    phaseData: StringSelector
  ): Float

  """
  Number of block in the blockchains
  """
  height: BigInt
  maximum(of: EverscalePhaseMeasurable!, get: EverscalePhaseMeasurable): String
  minimum(of: EverscalePhaseMeasurable!, get: EverscalePhaseMeasurable): String

  """
  Previous Block
  """
  previousBlock: BigInt

  """
  Sharded Block Information
  """
  shardedBlock(
    height: BlockSelector
    hash: HashSelector
    shard: StringIdSelector
    workchain: BigIntIdSelector
  ): EverscaleShardedBlockDimension

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transactions
  """
  transactions(
    txHash: HashSelector
    txType: StringSelector
    txAccount: AddressSelector
    txAborted: BigIntIdSelector
  ): EverscaleTransactionDimension

  """
  Phase Type
  """
  type: String
}

input EverscalePhaseFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  blockHeight: BlockSelector
  blockShard: BigIntIdSelector
  blockWorkchain: BigIntIdSelector
  shardedHeight: BlockSelector
  shardedBlockHash: HashSelector
  shardedBlockShard: BigIntIdSelector
  shardedBlockWorkchain: BigIntIdSelector
  previousBlock: BlockSelector
  txHash: StringSelector
  txType: IntegerSelector
  txAccount: StringSelector
  txAborted: StringSelector
  txOriginalStatus: EverscaleAccountStateSelector
  txEndStatus: EverscaleAccountStateSelector
  phaseType: StringSelector
  phaseFee: FloatSelector
  phaseData: StringSelector
}

enum EverscalePhaseMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Hash of the the block
  """
  hash

  """
  Number of block in the blockhains
  """
  height

  """
  Shard of block in the blockhains
  """
  shard

  """
  Workchain of block in the blockhains
  """
  workchain

  """
  Number of sharded block block in the blockhains
  """
  sharded_block

  """
  Hash of the the sharded block block
  """
  sharded_block_hash

  """
  Shard of sharded block block in the blockhains
  """
  sharded_block_shard

  """
  Workchain of sharded block block in the blockhains
  """
  sharded_block_workchain

  """
  Previous Message
  """
  previous_block

  """
  Tx Hash
  """
  tx_hash

  """
  Tx Type
  """
  tx_type

  """
  Tx Account
  """
  tx_account

  """
  Phase type
  """
  phase_type

  """
  Phase data
  """
  phase_data

  """
  Phase fee
  """
  phase_fee
}

enum EverscalePhaseUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Unique Number of block in the blockchains
  """
  height

  """
  Unique Number of Shards in the blockchains
  """
  block_shard

  """
  Unique Number of workchains in the blockchains
  """
  block_workchain

  """
  Unique Number of sharded blocks in the blockchains
  """
  sharded_blocks

  """
  Unique Number of sharded block shards in the blockchains
  """
  sharded_block_shards

  """
  Unique Number of sharded block workchains in the blockchains
  """
  sharded_block_workchains

  """
  Unique Number of transactions
  """
  txs

  """
  Unique Number of phases
  """
  phases
}

"""
Information about sharded block
"""
type EverscaleShardedBlockDimension {
  """
  Hash of the the master block
  """
  hash: String

  """
  Number of master block in the blockchains
  """
  height: BigInt

  """
  Shard master number of block
  """
  shard: String

  """
  Workchain master block hash
  """
  workchain: BigInt
}

"""
Transaction in Everscale blockchain
"""
type EverscaleTransaction {
  """
  Transaction Aborted
  """
  aborted: Boolean

  """
  Transaction Account
  """
  account: String
  accountFees(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txHash: StringSelector
    txLogicalTime: IntegerSelector
    txType: IntegerSelector
    txOriginalStatus: EverscaleAccountStateSelector
    txEndStatus: EverscaleAccountStateSelector
    txInMessageBounceFlag: BooleanSelector
    txAccount: StringSelector
    txAborted: BooleanSelector
    txDestroyed: BooleanSelector
    txOldHash: StringSelector
    txNewHash: StringSelector
    txOutMessagesCount: IntegerSelector
    txAccountFees: FloatSelector
    txExtInAndIhrInFees: FloatSelector
    txCreditFirst: BooleanSelector
    previousTxHash: StringSelector
    previousTxLogicalTime: BigIntegerSelector
  ): Float
  any(of: EverscaleTransactionMeasurable!): String

  """
  Hash of the the block
  """
  blockHash: String

  """
  Shard number of block
  """
  blockShard: String

  """
  Proposer block hash
  """
  blockWorkchain: BigInt

  """
  Transaction Boc
  """
  boc: String
  count(
    uniq: EverscaleTransactionUniq
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txHash: StringSelector
    txLogicalTime: IntegerSelector
    txType: IntegerSelector
    txOriginalStatus: EverscaleAccountStateSelector
    txEndStatus: EverscaleAccountStateSelector
    txInMessageBounceFlag: BooleanSelector
    txAccount: StringSelector
    txAborted: BooleanSelector
    txDestroyed: BooleanSelector
    txOldHash: StringSelector
    txNewHash: StringSelector
    txOutMessagesCount: IntegerSelector
    txAccountFees: FloatSelector
    txExtInAndIhrInFees: FloatSelector
    txCreditFirst: BooleanSelector
    previousTxHash: StringSelector
    previousTxLogicalTime: BigIntegerSelector
  ): Int
  countBigInt(
    uniq: EverscaleTransactionUniq
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txHash: StringSelector
    txLogicalTime: IntegerSelector
    txType: IntegerSelector
    txOriginalStatus: EverscaleAccountStateSelector
    txEndStatus: EverscaleAccountStateSelector
    txInMessageBounceFlag: BooleanSelector
    txAccount: StringSelector
    txAborted: BooleanSelector
    txDestroyed: BooleanSelector
    txOldHash: StringSelector
    txNewHash: StringSelector
    txOutMessagesCount: IntegerSelector
    txAccountFees: FloatSelector
    txExtInAndIhrInFees: FloatSelector
    txCreditFirst: BooleanSelector
    previousTxHash: StringSelector
    previousTxLogicalTime: BigIntegerSelector
  ): BigInt

  """
  Transaction Credit First
  """
  creditFirst: Int

  """
  Calendar date
  """
  date: Date

  """
  Transaction Destroyed
  """
  destroyed: Boolean

  """
  The end state of an account after a transaction
  """
  endStatus: String
  expression(get: String!): DecimalNumber

  """
  Tx Ext In And Ihr In Fees
  """
  extInAndIhrInFees: Float

  """
  Transaction Hash
  """
  hash: String

  """
  Number of block in the blockchains
  """
  height: BigInt

  """
  Internal Message bounce flag
  """
  inMessageBounceFlag: Boolean

  """
  Transaction Logical Time
  """
  logicalTime: BigInt
  maximum(
    of: EverscaleTransactionMeasurable!
    get: EverscaleTransactionMeasurable
  ): String
  minimum(
    of: EverscaleTransactionMeasurable!
    get: EverscaleTransactionMeasurable
  ): String

  """
  Transaction New Hash
  """
  newHash: String

  """
  Transaction Old Hash
  """
  oldHash: String

  """
  The initial state of account
  """
  originalStatus: String

  """
  Transaction Out Messages count
  """
  outMessagesCount: Int

  """
  Previous Block
  """
  previousBlock: BigInt

  """
  Transaction Out Messages count
  """
  previousTxHash: String

  """
  Transaction Previous Tx Logical Time
  """
  previousTxLogicalTime: BigInt

  """
  Sharded Block Information
  """
  shardedBlock(
    height: BlockSelector
    hash: HashSelector
    shard: StringIdSelector
    workchain: BigIntIdSelector
  ): EverscaleShardedBlockDimension

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transaction Type
  """
  type: String
}

"""
Information about transaction
"""
type EverscaleTransactionDimension {
  """
  Transaction Aborted
  """
  aborted: Boolean

  """
  Transaction Account
  """
  account: String

  """
  The end state of an account after a transaction
  """
  endStatus: String

  """
  Transaction Hash
  """
  hash: String

  """
  The initial state of account
  """
  originalStatus: String

  """
  Transaction Type
  """
  type: String
}

input EverscaleTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  blockHeight: BlockSelector
  blockShard: BigIntIdSelector
  blockWorkchain: BigIntIdSelector
  shardedHeight: BlockSelector
  shardedBlockHash: HashSelector
  shardedBlockShard: BigIntIdSelector
  shardedBlockWorkchain: BigIntIdSelector
  previousBlock: BlockSelector
  txHash: StringSelector
  txLogicalTime: IntegerSelector
  txType: IntegerSelector
  txOriginalStatus: EverscaleAccountStateSelector
  txEndStatus: EverscaleAccountStateSelector
  txInMessageBounceFlag: BooleanSelector
  txAccount: StringSelector
  txAborted: BooleanSelector
  txDestroyed: BooleanSelector
  txOldHash: StringSelector
  txNewHash: StringSelector
  txOutMessagesCount: IntegerSelector
  txAccountFees: FloatSelector
  txExtInAndIhrInFees: FloatSelector
  txCreditFirst: BooleanSelector
  previousTxHash: StringSelector
  previousTxLogicalTime: BigIntegerSelector
}

enum EverscaleTransactionMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Hash of the the block
  """
  hash

  """
  Number of block in the blockhains
  """
  height

  """
  Shard of block in the blockhains
  """
  shard

  """
  Workchain of block in the blockhains
  """
  workchain

  """
  Number of sharded block block in the blockhains
  """
  sharded_block

  """
  Hash of the the sharded block block
  """
  sharded_block_hash

  """
  Shard of sharded block block in the blockhains
  """
  sharded_block_shard

  """
  Workchain of sharded block block in the blockhains
  """
  sharded_block_workchain

  """
  Previous Transaction
  """
  previous_block

  """
  Tx Hash
  """
  tx_hash

  """
  Tx Type
  """
  tx_type

  """
  Tx Account
  """
  tx_account

  """
  Tx Old hash
  """
  tx_old_hash

  """
  Tx New Hash
  """
  tx_new_hash

  """
  Previous Tx Hash
  """
  previous_tx_hash

  """
  Previous Tx Logical Time
  """
  previous_tx_logical_time
}

enum EverscaleTransactionUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Unique Number of block in the blockchains
  """
  height

  """
  Unique Number of Shards in the blockchains
  """
  block_shard

  """
  Unique Number of workchains in the blockchains
  """
  block_workchain

  """
  Unique Number of sharded blocks in the blockchains
  """
  sharded_blocks

  """
  Unique Number of sharded block shards in the blockchains
  """
  sharded_block_shards

  """
  Unique Number of sharded block workchains in the blockchains
  """
  sharded_block_workchains

  """
  Unique Number of Transactions
  """
  txs
}

"""
Transfer in Everscale blockchain
"""
type EverscaleTransfer {
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txHash: StringSelector
    txType: IntegerSelector
    txAccount: StringSelector
    txAborted: StringSelector
    txOriginalStatus: EverscaleAccountStateSelector
    txEndStatus: EverscaleAccountStateSelector
    messageHash: HashSelector
    messageTypeName: EverscaleMessageTypeNameSelector
    messageDirection: EverscaleMessageDirectionSelector
    messageSender: AddressSelector
    messageReceiver: AddressSelector
    messageValue: FloatSelector
    currency: CurrencySelector
    transferSender: StringSelector
    transferReceiver: StringSelector
    entityId: BigIntIdSelector
    transferType: EverscaleTransferTypeSelector
  ): Float

  """
  Input value as decimal
  """
  amountDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txHash: StringSelector
    txType: IntegerSelector
    txAccount: StringSelector
    txAborted: StringSelector
    txOriginalStatus: EverscaleAccountStateSelector
    txEndStatus: EverscaleAccountStateSelector
    messageHash: HashSelector
    messageTypeName: EverscaleMessageTypeNameSelector
    messageDirection: EverscaleMessageDirectionSelector
    messageSender: AddressSelector
    messageReceiver: AddressSelector
    messageValue: FloatSelector
    currency: CurrencySelector
    transferSender: StringSelector
    transferReceiver: StringSelector
    entityId: BigIntIdSelector
    transferType: EverscaleTransferTypeSelector
  ): DecimalNumberAsDiv
  any(of: EverscaleTransferMeasurable!): String

  """
  Hash of the the block
  """
  blockHash: String

  """
  Shard number of block
  """
  blockShard: String

  """
  Proposer block hash
  """
  blockWorkchain: BigInt
  count(
    uniq: EverscaleTransferUniq
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txHash: StringSelector
    txType: IntegerSelector
    txAccount: StringSelector
    txAborted: StringSelector
    txOriginalStatus: EverscaleAccountStateSelector
    txEndStatus: EverscaleAccountStateSelector
    messageHash: HashSelector
    messageTypeName: EverscaleMessageTypeNameSelector
    messageDirection: EverscaleMessageDirectionSelector
    messageSender: AddressSelector
    messageReceiver: AddressSelector
    messageValue: FloatSelector
    currency: CurrencySelector
    transferSender: StringSelector
    transferReceiver: StringSelector
    entityId: BigIntIdSelector
    transferType: EverscaleTransferTypeSelector
  ): Int
  countBigInt(
    uniq: EverscaleTransferUniq
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    blockHeight: BlockSelector
    blockShard: BigIntIdSelector
    blockWorkchain: BigIntIdSelector
    shardedHeight: BlockSelector
    shardedBlockHash: HashSelector
    shardedBlockShard: BigIntIdSelector
    shardedBlockWorkchain: BigIntIdSelector
    previousBlock: BlockSelector
    txHash: StringSelector
    txType: IntegerSelector
    txAccount: StringSelector
    txAborted: StringSelector
    txOriginalStatus: EverscaleAccountStateSelector
    txEndStatus: EverscaleAccountStateSelector
    messageHash: HashSelector
    messageTypeName: EverscaleMessageTypeNameSelector
    messageDirection: EverscaleMessageDirectionSelector
    messageSender: AddressSelector
    messageReceiver: AddressSelector
    messageValue: FloatSelector
    currency: CurrencySelector
    transferSender: StringSelector
    transferReceiver: StringSelector
    entityId: BigIntIdSelector
    transferType: EverscaleTransferTypeSelector
  ): BigInt

  """
  Currency of transfer
  """
  currency: Currency

  """
  Calendar date
  """
  date: Date

  """
  NFT Id
  """
  entityId: BigInt!
  expression(get: String!): DecimalNumber

  """
  Number of block in the blockchains
  """
  height: BigInt
  maximum(
    of: EverscaleTransferMeasurable!
    get: EverscaleTransferMeasurable
  ): String

  """
  messages
  """
  messages(
    messageHash: HashSelector
    messageTypeName: EverscaleMessageTypeNameSelector
    messageDirection: EverscaleMessageDirectionSelector
    messageSender: AddressSelector
    messageReceiver: AddressSelector
    messageValue: FloatSelector
  ): EverscaleMessageDimension
  minimum(
    of: EverscaleTransferMeasurable!
    get: EverscaleTransferMeasurable
  ): String

  """
  Previous Block
  """
  previousBlock: BigInt

  """
  Transfer To
  """
  receiver: Address!

  """
  Transfer From
  """
  sender: Address!

  """
  Sharded Block Information
  """
  shardedBlock(
    height: BlockSelector
    hash: HashSelector
    shard: StringIdSelector
    workchain: BigIntIdSelector
  ): EverscaleShardedBlockDimension

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transactions
  """
  transactions(
    txHash: HashSelector
    txType: StringSelector
    txAccount: AddressSelector
    txAborted: BigIntIdSelector
  ): EverscaleTransactionDimension

  """
  Transfer type
  """
  transferType: String!
}

input EverscaleTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  blockHeight: BlockSelector
  blockShard: BigIntIdSelector
  blockWorkchain: BigIntIdSelector
  shardedHeight: BlockSelector
  shardedBlockHash: HashSelector
  shardedBlockShard: BigIntIdSelector
  shardedBlockWorkchain: BigIntIdSelector
  previousBlock: BlockSelector
  txHash: StringSelector
  txType: IntegerSelector
  txAccount: StringSelector
  txAborted: StringSelector
  txOriginalStatus: EverscaleAccountStateSelector
  txEndStatus: EverscaleAccountStateSelector
  messageHash: HashSelector
  messageTypeName: EverscaleMessageTypeNameSelector
  messageDirection: EverscaleMessageDirectionSelector
  messageSender: AddressSelector
  messageReceiver: AddressSelector
  messageValue: FloatSelector
  currency: CurrencySelector
  transferSender: StringSelector
  transferReceiver: StringSelector
  entityId: BigIntIdSelector
  transferType: EverscaleTransferTypeSelector
}

enum EverscaleTransferMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Hash of the the block
  """
  hash

  """
  Number of block in the blockhains
  """
  height

  """
  Shard of block in the blockhains
  """
  shard

  """
  Workchain of block in the blockhains
  """
  workchain

  """
  Number of sharded block block in the blockhains
  """
  sharded_block

  """
  Hash of the the sharded block block
  """
  sharded_block_hash

  """
  Shard of sharded block block in the blockhains
  """
  sharded_block_shard

  """
  Workchain of sharded block block in the blockhains
  """
  sharded_block_workchain

  """
  Previous Message
  """
  previous_block

  """
  Tx Hash
  """
  tx_hash

  """
  Tx Type
  """
  tx_type

  """
  Tx Account
  """
  tx_account

  """
  Tx Aborted
  """
  tx_aborted

  """
  Message Hash
  """
  message_hash

  """
  Message type name
  """
  message_type_name

  """
  Message direction
  """
  message_direction

  """
  Message sender
  """
  message_sender

  """
  Message receiver
  """
  message_receiver

  """
  Message value
  """
  message_value

  """
  Value
  """
  value

  """
  Currency Symbol
  """
  currency_symbol

  """
  Currency Address
  """
  currency_address

  """
  Currency Name
  """
  currency_name
}

enum EverscaleTransferTypeEnum {
  """
  Transaction transfer
  """
  transaction

  """
  Token Transfers
  """
  token_transfer

  """
  Token Mint
  """
  token_mint

  """
  Token Burn
  """
  token_burn
}

"""
Select by message type name
"""
input EverscaleTransferTypeSelector {
  """
  Transfer type name is
  """
  is: EverscaleTransferTypeEnum

  """
  Transfer type name not
  """
  not: EverscaleTransferTypeEnum

  """
  Transfer type name in the list
  """
  in: [EverscaleTransferTypeEnum!]

  """
  Transfer type name not in the list
  """
  notIn: [EverscaleTransferTypeEnum!]
}

enum EverscaleTransferUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Unique Number of block in the blockchains
  """
  height

  """
  Unique Number of Shards in the blockchains
  """
  block_shard

  """
  Unique Number of workchains in the blockchains
  """
  block_workchain

  """
  Unique Number of sharded blocks in the blockchains
  """
  sharded_blocks

  """
  Unique Number of sharded block shards in the blockchains
  """
  sharded_block_shards

  """
  Unique Number of sharded block workchains in the blockchains
  """
  sharded_block_workchains

  """
  Unique Number of transactions
  """
  txs

  """
  Unique Number of messages
  """
  messages

  """
  Unique Number of currencies
  """
  currencies

  """
  Unique Number of senders
  """
  senders

  """
  Unique Number of receivers
  """
  receivers
}

"""
Value Block information
"""
type EverscaleValueDimension {
  """
  Created
  """
  created: BigInt

  """
  Exported
  """
  exported: BigInt

  """
  Fees Collected
  """
  feesCollected: BigInt

  """
  Fees imported
  """
  feesImported: BigInt

  """
  From Previous Block
  """
  fromPreviousBlock: BigInt

  """
  Imported
  """
  imported: BigInt

  """
  Minted
  """
  minted: BigInt

  """
  Value Flow To Next Block
  """
  toNextBlock: BigInt
}

"""
Filecoin
"""
type Filecoin {
  """
  Basic information about address
  """
  address(address: [AddressSelectorIn!]!): [FilecoinAddressInfoWithBalance!]!

  """
  Filecoin Network Blocks
  """
  blocks(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    miner: [AddressSelector!]
    blockIndex: IntegerSelector
    any: [FilecoinBlockFilter!]
    options: QueryOptions
  ): [FilecoinBlock!]

  """
  Filecoin Network Calls
  """
  calls(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    amount: AmountSelector
    messageMethod: IntegerSelector
    any: [FilecoinCallFilter!]
    options: QueryOptions
  ): [FilecoinCalls!]

  """
  Money flow using Coinpath technology
  """
  coinpath(
    sender: AddressSelector
    receiver: AddressSelector
    initialAddress: AddressSelector
    initialDate: DateSelector
    initialTime: DateTimeSelector
    date: DateSelector
    time: DateTimeSelector
    depth: IntegerLimitedSelector
    options: CoinpathOptions
  ): [FilecoinCoinpath!]

  """
  Filecoin Network Messages ( blocks, transfers, ... )
  """
  messages(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    index: IntegerSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    success: Boolean
    amount: AmountSelector
    any: [FilecoinMessageFilter!]
    options: QueryOptions
  ): [FilecoinMessages!]

  """
  Filecoin Network Currency Transfers
  """
  transfers(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    amount: AmountSelector
    transferType: TransferTypeSelector
    messageMethod: IntegerSelector
    any: [FilecoinTransferFilter!]
    options: QueryOptions
  ): [FilecoinTransfers!]
}

"""
Blockchain address
"""
type FilecoinAddressInfoWithBalance {
  """
  Address
  """
  address: String

  """
  Annotations ( tags ), if exists
  """
  annotation: String

  """
  Wallet balance
  """
  balance(in: BaseCurrencyEnum): Float
}

"""
Block
"""
type FilecoinBlock {
  any(of: FilecoinBlocksMeasureable!): String
  blockSig: NameWithId
  blsAggregate: NameWithId
  count(
    uniq: FilecoinBlockUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    miner: [AddressSelector!]
    blockIndex: IntegerSelector
  ): Int
  countBigInt(
    uniq: FilecoinBlockUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    miner: [AddressSelector!]
    blockIndex: IntegerSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  electionProof: String
  expression(get: String!): DecimalNumber
  forkSignalling: BigInt

  """
  Block hash
  """
  hash(blockHash: [HashSelector!]): String!

  """
  Block round in blockchain
  """
  height(height: BlockSelector): Int!

  """
  Block index on height
  """
  index(blockIndex: IntegerSelector): Int
  maximum(
    of: FilecoinBlocksMeasureable!
    get: FilecoinBlocksMeasureable
  ): String
  messageCount(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    miner: [AddressSelector!]
    blockIndex: IntegerSelector
  ): Int
  messageCountBigInt(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    miner: [AddressSelector!]
    blockIndex: IntegerSelector
  ): BigInt
  messages: String

  """
  Miner
  """
  miner(miner: AddressSelector): Address
  minerTips(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    miner: [AddressSelector!]
    blockIndex: IntegerSelector
  ): Float
  minimum(
    of: FilecoinBlocksMeasureable!
    get: FilecoinBlocksMeasureable
  ): String
  parentMessageReceipts: String
  parentStateRoot: String
  parentWeight: BigInt
  reward(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    miner: [AddressSelector!]
    blockIndex: IntegerSelector
  ): Float
  ticket: String

  """
  Block timestamp
  """
  timestamp(time: DateTimeSelector): DateTime
  totalReward(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    miner: [AddressSelector!]
    blockIndex: IntegerSelector
  ): Float
  winCount(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    miner: [AddressSelector!]
    blockIndex: IntegerSelector
  ): Int
  winCountBigInt(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    miner: [AddressSelector!]
    blockIndex: IntegerSelector
  ): BigInt
  wincount: Int
}

input FilecoinBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  miner: [AddressSelector!]
  blockIndex: IntegerSelector
}

enum FilecoinBlocksMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Block hash
  """
  block_hash

  """
  Block Miner
  """
  miner
}

enum FilecoinBlockUniq {
  """
  Miner
  """
  miners

  """
  Unique date count
  """
  dates

  """
  Unique block height count
  """
  heights

  """
  Unique block count
  """
  blocks
}

input FilecoinCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  hash: HashSelector
  sender: AddressSelector
  receiver: AddressSelector
  method: IntegerSelector
  amount: AmountSelector
  messageMethod: IntegerSelector
}

"""
Calls in Filecoin blockchain
"""
type FilecoinCalls {
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    amount: AmountSelector
    messageMethod: IntegerSelector
  ): Float

  """
  Amount as decimal
  """
  amountDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    amount: AmountSelector
    messageMethod: IntegerSelector
  ): DecimalNumberAsDiv
  any(of: FilecoinCallsMeasureable!): String

  """
  Block where transfer Message is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Call hash
  """
  callHash: String

  """
  Call hash
  """
  callPath: String
  count(
    uniq: FilecoinMessagesUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    amount: AmountSelector
    messageMethod: IntegerSelector
  ): Int
  countBigInt(
    uniq: FilecoinMessagesUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    amount: AmountSelector
    messageMethod: IntegerSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  exitCode: BigInt
  expression(get: String!): DecimalNumber
  gas(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    index: IntegerSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    success: Boolean
    amount: AmountSelector
  ): Int
  gasFeeCap: BigInt
  gasLimit: BigInt
  gasPremium: Float

  """
  Message hash
  """
  hash(hash: HashSelector): String
  maximum(of: FilecoinCallsMeasureable!, get: FilecoinCallsMeasureable): String

  """
  Message Method
  """
  messageMethod(messageMethod: IntegerSelector): NameWithId

  """
  Method
  """
  method(method: IntegerSelector): NameWithId
  minedBlock: FilecoinMinedBlock
  minimum(of: FilecoinCallsMeasureable!, get: FilecoinCallsMeasureable): String
  nonce: BigInt

  """
  Message receiver
  """
  receiver(receiver: AddressSelector): AddressWithAccount
  returnValue: String

  """
  Message sender
  """
  sender(sender: AddressSelector): AddressWithAccount

  """
  Success
  """
  success(success: Boolean): Boolean
}

enum FilecoinCallsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Message hash
  """
  message_hash

  """
  Amount
  """
  amount

  """
  Gas value
  """
  gas_value

  """
  Gas limit
  """
  gas_limit

  """
  Gas used
  """
  gas
}

"""
Coinpath
"""
type FilecoinCoinpath {
  """
  Summary of transfered value
  """
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """
  Block where transaction is included
  """
  block: Block

  """
  Count of transfers
  """
  count: Int

  """
  Count of transfers
  """
  countBigInt: BigInt

  """
  Currency of transfer
  """
  currency: Currency

  """
  1-based hop depth of the graph
  """
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """
  Message of transfer happened
  """
  message: TransactionHashValue
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """
  Receiver address
  """
  receiver: Address

  """
  Sender address
  """
  sender: Address
}

input FilecoinMessageFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  hash: HashSelector
  index: IntegerSelector
  sender: AddressSelector
  receiver: AddressSelector
  method: IntegerSelector
  success: Boolean
  amount: AmountSelector
}

"""
Messages in Filecoin blockchain
"""
type FilecoinMessages {
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    index: IntegerSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    success: Boolean
    amount: AmountSelector
  ): Float

  """
  Amount as decimal
  """
  amountDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    index: IntegerSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    success: Boolean
    amount: AmountSelector
  ): DecimalNumberAsDiv
  any(of: FilecoinMessagesMeasureable!): String
  baseFeeBurn(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    index: IntegerSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    success: Boolean
    amount: AmountSelector
  ): Float
  baseFeeBurnDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    index: IntegerSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    success: Boolean
    amount: AmountSelector
  ): DecimalNumberAsDiv

  """
  Block where transfer Message is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block
  burned(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    index: IntegerSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    success: Boolean
    amount: AmountSelector
  ): Float
  burnedDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    index: IntegerSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    success: Boolean
    amount: AmountSelector
  ): DecimalNumberAsDiv
  count(
    uniq: FilecoinMessagesUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    index: IntegerSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    success: Boolean
    amount: AmountSelector
  ): Int
  countBigInt(
    uniq: FilecoinMessagesUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    index: IntegerSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    success: Boolean
    amount: AmountSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  exitCode: BigInt
  expression(get: String!): DecimalNumber
  gas(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    index: IntegerSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    success: Boolean
    amount: AmountSelector
  ): Int
  gasBigInt(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    index: IntegerSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    success: Boolean
    amount: AmountSelector
  ): BigInt
  gasFeeCap: BigInt
  gasLimit: BigInt
  gasPremium: Float

  """
  Message hash
  """
  hash(hash: HashSelector): String
  maximum(
    of: FilecoinMessagesMeasureable!
    get: FilecoinMessagesMeasureable
  ): String

  """
  Method
  """
  method(method: IntegerSelector): NameWithId
  minedBlock: FilecoinMinedBlock
  minerPenalty(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    index: IntegerSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    success: Boolean
    amount: AmountSelector
  ): Float
  minerPenaltyDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    index: IntegerSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    success: Boolean
    amount: AmountSelector
  ): DecimalNumberAsDiv
  minerTip(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    index: IntegerSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    success: Boolean
    amount: AmountSelector
  ): Float
  minerTipDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    index: IntegerSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    success: Boolean
    amount: AmountSelector
  ): DecimalNumberAsDiv
  minimum(
    of: FilecoinMessagesMeasureable!
    get: FilecoinMessagesMeasureable
  ): String
  nonce: BigInt
  overEstimationBurn(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    index: IntegerSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    success: Boolean
    amount: AmountSelector
  ): Float
  overEstimationBurnDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    index: IntegerSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    success: Boolean
    amount: AmountSelector
  ): DecimalNumberAsDiv

  """
  Message receiver
  """
  receiver(receiver: AddressSelector): AddressWithAccount
  refund(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    index: IntegerSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    success: Boolean
    amount: AmountSelector
  ): Float
  refundDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    index: IntegerSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    success: Boolean
    amount: AmountSelector
  ): DecimalNumberAsDiv
  returnValue: String

  """
  Message sender
  """
  sender(sender: AddressSelector): AddressWithAccount
  signature: String
  signatureType: String

  """
  Signed Message hash
  """
  signedHash: String

  """
  Success
  """
  success(success: Boolean): Boolean
  totalCost(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    index: IntegerSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    success: Boolean
    amount: AmountSelector
  ): Float
  totalCostDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    index: IntegerSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    success: Boolean
    amount: AmountSelector
  ): DecimalNumberAsDiv
}

enum FilecoinMessagesMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Message hash
  """
  message_hash

  """
  Amount
  """
  amount

  """
  Gas value
  """
  gas_value

  """
  Gas limit
  """
  gas_limit

  """
  Gas used
  """
  gas
}

enum FilecoinMessagesUniq {
  """
  Unique block heights
  """
  blocks

  """
  Unique date count
  """
  dates

  """
  Unique Message senders
  """
  senders

  """
  Unique Message receivers
  """
  receivers
}

"""
Filecoin Mined Block
"""
type FilecoinMinedBlock {
  """
  Hash
  """
  hash: String

  """
  Index on height
  """
  index: Int

  """
  Miner
  """
  miner: Address
}

enum FilecoinNetwork {
  """
  Filecoin Mainnet
  """
  filecoin
}

input FilecoinTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  hash: HashSelector
  sender: AddressSelector
  receiver: AddressSelector
  method: IntegerSelector
  amount: AmountSelector
  transferType: TransferTypeSelector
  messageMethod: IntegerSelector
}

"""
Transfers in Filecoin blockchain
"""
type FilecoinTransfers {
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    amount: AmountSelector
    transferType: TransferTypeSelector
    messageMethod: IntegerSelector
  ): Float

  """
  Amount as decimal
  """
  amountDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    amount: AmountSelector
    transferType: TransferTypeSelector
    messageMethod: IntegerSelector
  ): DecimalNumberAsDiv
  any(of: FilecoinTransfersMeasureable!): String

  """
  Block where transfer Transfer is included
  """
  block(height: BlockSelector, time: DateTimeSelector): BlockExtended

  """
  Call hash
  """
  callHash: String

  """
  Call hash
  """
  callPath: String
  count(
    uniq: FilecoinMessagesUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    amount: AmountSelector
    transferType: TransferTypeSelector
    messageMethod: IntegerSelector
  ): Int
  countBigInt(
    uniq: FilecoinMessagesUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    sender: AddressSelector
    receiver: AddressSelector
    method: IntegerSelector
    amount: AmountSelector
    transferType: TransferTypeSelector
    messageMethod: IntegerSelector
  ): BigInt

  """
  Currency of transfer
  """
  currency: Currency

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Message hash
  """
  hash(hash: HashSelector): String
  maximum(
    of: FilecoinTransfersMeasureable!
    get: FilecoinTransfersMeasureable
  ): String

  """
  Message Method
  """
  messageMethod(messageMethod: IntegerSelector): NameWithId

  """
  Method
  """
  method(method: IntegerSelector): NameWithId
  minimum(
    of: FilecoinTransfersMeasureable!
    get: FilecoinTransfersMeasureable
  ): String

  """
  Transfer receiver
  """
  receiver(receiver: AddressSelector): Address

  """
  Transfer sender
  """
  sender(sender: AddressSelector): Address

  """
  Transfer timestamp
  """
  timestamp(time: DateTimeSelector): DateTime

  """
  Type of transfer
  """
  transferType(transferType: TransferTypeSelector): FilecoinTransferType
}

enum FilecoinTransfersMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Block hash
  """
  block_hash

  """
  Message hash
  """
  message_hash

  """
  Amount
  """
  amount

  """
  Currency Symbol
  """
  currency_symbol

  """
  Currency Name
  """
  currency_name

  """
  Token Type
  """
  token_type

  """
  Token ID
  """
  token_id
}

enum FilecoinTransferType {
  """
  Send (transfer)
  """
  send

  """
  Miner Tip
  """
  miner

  """
  Reward
  """
  reward

  """
  Burn
  """
  burn

  """
  Rebalance
  """
  rebalance

  """
  Genesis
  """
  genesis
}

"""
Select by number
"""
input FloatSelector {
  """
  is
  """
  is: Float

  """
  not
  """
  not: Float

  """
  in the list
  """
  in: [Float!]

  """
  not in the list
  """
  notIn: [Float!]

  """
  greater than
  """
  gt: Float

  """
  less than
  """
  lt: Float

  """
  less or equal than
  """
  lteq: Float

  """
  greater or equal than
  """
  gteq: Float

  """
  in range
  """
  between: [Float!]
}

"""
Flow Chain
"""
type Flow {
  """
  Basic information about address
  """
  address(address: [AddressSelectorIn!]!): [FlowAddressInfoWithBalance!]!

  """
  The outermost portion of the transaction, which contains the payload and envelope signatures
  """
  arguments(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockId: HashSelector
    transactionId: HashSelector
    transactionStatusCode: IntegerSelector
    transactionIndexInCollection: IntegerSelector
    type: StringSelector
    value: StringSelector
    valueAsInt: IntegerSelector
    valueAsFix: IntegerSelector
    index: IntegerSelector
    any: [FlowArgumentFilter!]
    options: QueryOptions
  ): [FlowArgument!]

  """
  A block seal is an attestation that the execution result of a specific block has
                     been verified and approved by a quorum of verification nodes.
  """
  blockSeals(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockId: HashSelector
    blockSealId: HashSelector
    executionReceiptId: HashSelector
    index: StringSelector
    any: [FlowBlockSealFilter!]
    options: QueryOptions
  ): [FlowBlockSeal!]

  """
  Full block information.
  """
  blocks(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    id: HashSelector
    parentBlockId: HashSelector
    collectionsCount: IntegerSelector
    transactionsCount: IntegerSelector
    any: [FlowBlockFilter!]
    options: QueryOptions
  ): [FlowBlock!]

  """
  Money flow using Coinpath technology
  """
  coinpath(
    sender: AddressSelector
    receiver: AddressSelector
    currency: CurrencySelector
    initialAddress: AddressSelector
    initialDate: DateSelector
    initialTime: DateTimeSelector
    date: DateSelector
    time: DateTimeSelector
    depth: IntegerLimitedSelector
    options: CoinpathOptions
  ): [FlowCoinpath!]

  """
  A collection is a batch of transactions that have been includes in a block.
  """
  collections(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockId: HashSelector
    collectionId: HashSelector
    index: IntegerSelector
    transactionsCount: IntegerSelector
    any: [FlowCollectionFilter!]
    options: QueryOptions
  ): [FlowCollection!]

  """
  Event fields
  """
  eventFields(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockId: HashSelector
    transactionId: HashSelector
    transactionStatusCode: IntegerSelector
    transactionIndexInCollection: IntegerSelector
    smartContractAddress: StringSelector
    smartContractMethod: MethodSelector
    type: StringSelector
    eventIndex: IntegerSelector
    fieldAsInt: IntegerSelector
    fieldAsFix: IntegerSelector
    any: [FlowEventFieldFilter!]
    options: QueryOptions
  ): [FlowEventField!]

  """
  An event is emitted as the result of a transaction execution.
          Events are either user-defined events originating from a Cadence smart contract, or built-in Flow system events.
  """
  events(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockId: HashSelector
    transactionId: HashSelector
    transactionStatusCode: IntegerSelector
    transactionIndexInCollection: IntegerSelector
    index: IntegerSelector
    smartContractAddress: StringSelector
    smartContractMethod: MethodSelector
    type: StringSelector
    any: [FlowEventFilter!]
    options: QueryOptions
  ): [FlowEvent!]

  """
  Blockchain Transaction Inputs
  """
  inputs(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockId: HashSelector
    transactionId: HashSelector
    transactionStatusCode: IntegerSelector
    transactionIndexInCollection: IntegerSelector
    index: IntegerSelector
    smartContractAddress: StringSelector
    smartContractMethod: MethodSelector
    type: StringSelector
    eventIndex: IntegerSelector
    address: StringSelector
    entityId: BigIntIdSelector
    transferReason: FlowTransferReasonSelector
    currency: CurrencySelector
    any: [FlowInputFilter!]
    options: QueryOptions
  ): [FlowInput!]

  """
  Blockchain Transaction Outputs
  """
  outputs(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockId: HashSelector
    transactionId: HashSelector
    transactionStatusCode: IntegerSelector
    transactionIndexInCollection: IntegerSelector
    index: IntegerSelector
    smartContractAddress: StringSelector
    smartContractMethod: MethodSelector
    type: StringSelector
    eventIndex: IntegerSelector
    address: StringSelector
    entityId: BigIntIdSelector
    transferReason: FlowTransferReasonSelector
    currency: CurrencySelector
    any: [FlowOutputFilter!]
    options: QueryOptions
  ): [FlowOutput!]

  """
  List of transaction authorizers
  """
  transactionAuthorizers(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockId: HashSelector
    collectionId: HashSelector
    transactionId: HashSelector
    indexInCollection: IntegerSelector
    referenceBlockId: StringSelector
    gasLimit: IntegerSelector
    payer: AddressSelector
    proposer: AddressSelector
    proposalKeyId: IntegerSelector
    proposalKeySequenceNumber: IntegerSelector
    eventsCount: IntegerSelector
    statusCode: IntegerSelector
    authorizer: AddressSelector
    any: [FlowTransactionAuthorizerFilter!]
    options: QueryOptions
  ): [FlowTransactionAuthorizer!]

  """
  The outermost portion of the transaction, which contains the payload and envelope signatures
  """
  transactionEnvelopeSignatures(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockId: HashSelector
    collectionId: HashSelector
    transactionId: HashSelector
    indexInCollection: IntegerSelector
    referenceBlockId: StringSelector
    gasLimit: IntegerSelector
    payer: AddressSelector
    proposer: AddressSelector
    proposalKeyId: IntegerSelector
    proposalKeySequenceNumber: IntegerSelector
    eventsCount: IntegerSelector
    statusCode: IntegerSelector
    address: AddressSelector
    keyId: IntegerSelector
    signature: StringSelector
    any: [FlowTransactionEnvelopeSignatureFilter!]
    options: QueryOptions
  ): [FlowTransactionEnvelopeSignature!]

  """
  The transaction authorization envelope contains both the
                     transaction payload and the payload signatures.
  """
  transactionPayloadSignatures(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockId: HashSelector
    collectionId: HashSelector
    transactionId: HashSelector
    indexInCollection: IntegerSelector
    referenceBlockId: StringSelector
    gasLimit: IntegerSelector
    payer: AddressSelector
    proposer: AddressSelector
    proposalKeyId: IntegerSelector
    proposalKeySequenceNumber: IntegerSelector
    eventsCount: IntegerSelector
    statusCode: IntegerSelector
    address: AddressSelector
    keyId: IntegerSelector
    signature: StringSelector
    any: [FlowTransactionPayloadSignatureFilter!]
    options: QueryOptions
  ): [FlowTransactionPayloadSignature!]

  """
  A transaction represents a unit of computation that is submitted to the Flow network.
  """
  transactions(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockId: HashSelector
    collectionId: HashSelector
    transactionId: HashSelector
    indexInCollection: IntegerSelector
    referenceBlockId: StringSelector
    gasLimit: IntegerSelector
    payer: AddressSelector
    proposer: AddressSelector
    proposalKeyId: IntegerSelector
    proposalKeySequenceNumber: IntegerSelector
    eventsCount: IntegerSelector
    statusCode: IntegerSelector
    any: [FlowTransactionFilter!]
    options: QueryOptions
  ): [FlowTransaction!]
}

"""
Blockchain address
"""
type FlowAddressInfoWithBalance {
  """
  Address
  """
  address: String

  """
  Annotations ( tags ), if exists
  """
  annotation: String

  """
  FLOW currency balance
  """
  balance(in: BaseCurrencyEnum): Float
}

"""
Arguments in Flow blockchain
"""
type FlowArgument {
  any(of: FlowArgumentMeasureable!): String

  """
  Block information
  """
  block(height: BlockSelector, blockId: HashSelector): FlowBlockDimension!
  count(uniq: FlowArgumentUniq): Int
  countBigInt(uniq: FlowArgumentUniq): BigInt

  """
  The date this transaction was created
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Index of the argument inside transaction
  """
  index: Int!
  maximum(of: FlowArgumentMeasureable!, get: FlowArgumentMeasureable): String
  minimum(of: FlowArgumentMeasureable!, get: FlowArgumentMeasureable): String

  """
  The time this transaction was created
  """
  time: DateTime

  """
  Transaction information
  """
  transaction(
    transactionId: HashSelector
    transactionIndexInCollection: IntegerSelector
    transactionStatusCode: IntegerSelector
  ): FlowMinorTransactionDimension!

  """
  Type of field, e.g. UInt64, String, Bool, etc..
  """
  type: String!

  """
  Value
  """
  value: String!
  valueAsFix(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockId: HashSelector
    transactionId: HashSelector
    transactionStatusCode: IntegerSelector
    transactionIndexInCollection: IntegerSelector
    type: StringSelector
    value: StringSelector
    valueAsInt: IntegerSelector
    valueAsFix: IntegerSelector
    index: IntegerSelector
  ): Float

  """
  Value converted to integer
  """
  valueAsInt: Int!
}

input FlowArgumentFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: HashSelector
  transactionId: HashSelector
  transactionStatusCode: IntegerSelector
  transactionIndexInCollection: IntegerSelector
  type: StringSelector
  value: StringSelector
  valueAsInt: IntegerSelector
  valueAsFix: IntegerSelector
  index: IntegerSelector
}

enum FlowArgumentMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Number of block in the blockhains
  """
  height

  """
  Hash of the the block
  """
  block_id

  """
  ID transaction
  """
  transaction_id

  """
  Value
  """
  value

  """
  Type
  """
  type

  """
  Value with UFix64 type and converted to integer
  """
  value_as_fix
}

enum FlowArgumentUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique Number of block in the blockchains
  """
  height

  """
  Unique Number of transactions
  """
  transactions
}

"""
Block in Flow blockchain
"""
type FlowBlock {
  any(of: FlowBlockMeasureable!): String

  """
  BLS signatures of consensus nodes
  """
  blockSignatures: [String!]

  """
  Count of collections
  """
  collectionsCount: Int
  count(uniq: FlowBlockUniq): Int
  countBigInt(uniq: FlowBlockUniq): BigInt

  """
  The date this transaction was created
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Height of the block in the chain
  """
  height: BigInt

  """
  SHA3-256 hash of the entire block payload
  """
  id: String
  maximum(of: FlowBlockMeasureable!, get: FlowBlockMeasureable): String
  minimum(of: FlowBlockMeasureable!, get: FlowBlockMeasureable): String

  """
  ID of the previous block in the chain
  """
  parentBlockId: String

  """
  The time this transaction was created
  """
  time: DateTime

  """
  Count of transactions
  """
  transactionsCount: Int
}

type FlowBlockDimension {
  """
  Height of the block in the chain
  """
  height: BigInt

  """
  SHA3-256 hash of the entire block payload
  """
  id: String
}

input FlowBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  id: HashSelector
  parentBlockId: HashSelector
  collectionsCount: IntegerSelector
  transactionsCount: IntegerSelector
}

enum FlowBlockMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Height of the block in the chain
  """
  height

  """
  SHA3-256 hash of the entire block payload
  """
  id

  """
  ID of the previous block in the chain
  """
  parent_block_id

  """
  Count of collections
  """
  collections_count

  """
  Count of transactions
  """
  transactions_count
}

"""
Block seals in Flow blockchain
"""
type FlowBlockSeal {
  any(of: FlowBlockSealsMeasureable!): String

  """
  Block information
  """
  block(height: BlockSelector, blockId: HashSelector): FlowBlockDimension!
  count(uniq: FlowBlockSealUniq): Int
  countBigInt(uniq: FlowBlockSealUniq): BigInt

  """
  The date this transaction was created
  """
  date: Date

  """
  ID execution receipt being sealed
  """
  executionReceiptId: String

  """
  BLS signatures of verification nodes on the execution receipt contents
  """
  executionReceiptSignatures: [String!]
  expression(get: String!): DecimalNumber

  """
  Index inside block
  """
  index: Int
  maximum(
    of: FlowBlockSealsMeasureable!
    get: FlowBlockSealsMeasureable
  ): String
  minimum(
    of: FlowBlockSealsMeasureable!
    get: FlowBlockSealsMeasureable
  ): String

  """
  BLS signatures of verification nodes on the result approval contents
  """
  resultApprovalSignatures: [String!]

  """
  ID of the block being sealed
  """
  sealId: String

  """
  The time this transaction was created
  """
  time: DateTime
}

input FlowBlockSealFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: HashSelector
  blockSealId: HashSelector
  executionReceiptId: HashSelector
  index: StringSelector
}

enum FlowBlockSealsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Height of the block in the chain
  """
  height

  """
  SHA3-256 hash of the entire block payload
  """
  block_id

  """
  ID of the block being sealed
  """
  block_seal_id

  """
  ID execution receipt being sealed
  """
  execution_receipt_id
}

enum FlowBlockSealUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique Number of block in the blockchains
  """
  height

  """
  Unique number of sealed blocks
  """
  block_seal_id

  """
  ID execution receipt being sealed
  """
  execution_receipt_id
}

enum FlowBlockUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique Number of block in the blockchains
  """
  height
}

"""
FlowCoinpath
"""
type FlowCoinpath {
  """
  Summary of transfered value
  """
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """
  Block where transaction is included
  """
  block: Block

  """
  Count of transfers
  """
  count: Int

  """
  Count of transfers
  """
  countBigInt: BigInt

  """
  Currency of transfer
  """
  currency: Currency

  """
  1-based hop depth of the graph
  """
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """
  Receiver address
  """
  receiver: Address

  """
  Sender address
  """
  sender: Address

  """
  Transaction of transfer happened
  """
  transaction: FlowTransactionHashIndexValues
}

"""
Collections in Flow blockchain
"""
type FlowCollection {
  any(of: FlowCollectionsMeasureable!): String

  """
  Block information
  """
  block(height: BlockSelector, blockId: HashSelector): FlowBlockDimension!
  count(uniq: FlowCollectionUniq): Int
  countBigInt(uniq: FlowCollectionUniq): BigInt

  """
  The date this transaction was created
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  SHA3-256 hash of the collection contents
  """
  id: String

  """
  Index of collection inside block
  """
  index: Int
  maximum(
    of: FlowCollectionsMeasureable!
    get: FlowCollectionsMeasureable
  ): String
  minimum(
    of: FlowCollectionsMeasureable!
    get: FlowCollectionsMeasureable
  ): String

  """
  BLS signatures of the collection nodes guaranteeing the collection
  """
  signatures: [String!]

  """
  The time this transaction was created
  """
  time: DateTime

  """
  Count of transactions inside collection
  """
  transactionsCount: Int
}

input FlowCollectionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: HashSelector
  collectionId: HashSelector
  index: IntegerSelector
  transactionsCount: IntegerSelector
}

enum FlowCollectionsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Height of the block in the chain
  """
  height

  """
  SHA3-256 hash of the entire block payload
  """
  block_id

  """
  SHA3-256 hash of the collection contents
  """
  collection_id

  """
  Index of collection inside block
  """
  collection_index

  """
  Count of transactions inside collection
  """
  transactions_count
}

enum FlowCollectionUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique Number of block in the blockchains
  """
  height

  """
  SHA3-256 hash of the collection contents
  """
  collection_id

  """
  Index of collection inside block
  """
  collection_index
}

enum FlowDirection {
  """
  Inbound transfers
  """
  inbound

  """
  Outbound transfers
  """
  outbound
}

"""
Events in Flow blockchain
"""
type FlowEvent {
  any(of: FlowEventMeasureable!): String

  """
  Block information
  """
  block(height: BlockSelector, blockId: HashSelector): FlowBlockDimension!
  count(uniq: FlowEventUniq): Int
  countBigInt(uniq: FlowEventUniq): BigInt

  """
  The date this transaction was created
  """
  date: Date
  expression(get: String!): DecimalNumber
  index: Int!
  maximum(of: FlowEventMeasureable!, get: FlowEventMeasureable): String
  minimum(of: FlowEventMeasureable!, get: FlowEventMeasureable): String

  """
  Smart contract address
  """
  smartContractAddress: Address

  """
  Contract method invoked
  """
  smartContractMethod: Method

  """
  The time this transaction was created
  """
  time: DateTime

  """
  Transaction information
  """
  transaction(
    transactionId: HashSelector
    transactionIndexInCollection: IntegerSelector
    transactionStatusCode: IntegerSelector
  ): FlowMinorTransactionDimension!

  """
  Type of field, e.g. UInt64, String, Bool, etc..
  """
  type: String!
}

"""
EventFields in Flow blockchain
"""
type FlowEventField {
  any(of: FlowEventFieldMeasureable!): String

  """
  Block information
  """
  block(height: BlockSelector, blockId: HashSelector): FlowBlockDimension!
  count(uniq: FlowEventFieldUniq): Int
  countBigInt(uniq: FlowEventFieldUniq): BigInt

  """
  The date this transaction was created
  """
  date: Date

  """
  Index of event inside transaction
  """
  eventIndex: Int!
  expression(get: String!): DecimalNumber

  """
  Field
  """
  field: String!

  """
  Field as fix
  """
  fieldAsFix: String!

  """
  Field as fix
  """
  fieldAsInt: String!

  """
  Index of field inside event
  """
  index: String!
  maximum(
    of: FlowEventFieldMeasureable!
    get: FlowEventFieldMeasureable
  ): String
  minimum(
    of: FlowEventFieldMeasureable!
    get: FlowEventFieldMeasureable
  ): String

  """
  Smart contract address
  """
  smartContractAddress: Address

  """
  Contract method invoked
  """
  smartContractMethod: Method

  """
  The time this transaction was created
  """
  time: DateTime

  """
  Transaction information
  """
  transaction(
    transactionId: HashSelector
    transactionIndexInCollection: IntegerSelector
    transactionStatusCode: IntegerSelector
  ): FlowMinorTransactionDimension!

  """
  Type of field, e.g. UInt64, String, Bool, etc..
  """
  type: String!
}

input FlowEventFieldFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: HashSelector
  transactionId: HashSelector
  transactionStatusCode: IntegerSelector
  transactionIndexInCollection: IntegerSelector
  smartContractAddress: StringSelector
  smartContractMethod: MethodSelector
  type: StringSelector
  eventIndex: IntegerSelector
  fieldAsInt: IntegerSelector
  fieldAsFix: IntegerSelector
}

enum FlowEventFieldMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Number of block in the blockhains
  """
  height

  """
  Hash of the the block
  """
  block_id

  """
  ID transaction
  """
  tx_id

  """
  TX status code
  """
  tx_status_code

  """
  Index of transaction inside collection
  """
  tx_index_in_collection

  """
  Smart Contract
  """
  smart_contract

  """
  Smart Contract Method Signature
  """
  signature

  """
  Smart Contract Method Name
  """
  signature_name

  """
  Smart Contract Method Signature Hash
  """
  signature_hash
}

enum FlowEventFieldUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique Number of block in the blockchains
  """
  height

  """
  Unique Number of transactions
  """
  transactions

  """
  Unique Number of events
  """
  events

  """
  Unique Number of smart contract
  """
  smart_contracts

  """
  Unique Number of smart contract methods
  """
  smart_contract_methods
}

input FlowEventFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: HashSelector
  transactionId: HashSelector
  transactionStatusCode: IntegerSelector
  transactionIndexInCollection: IntegerSelector
  index: IntegerSelector
  smartContractAddress: StringSelector
  smartContractMethod: MethodSelector
  type: StringSelector
}

enum FlowEventMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Number of block in the blockhains
  """
  height

  """
  Hash of the the block
  """
  block_id

  """
  ID transaction
  """
  tx_id

  """
  TX status code
  """
  tx_status_code

  """
  Index of transaction inside collection
  """
  tx_index_in_collection

  """
  Smart Contract
  """
  smart_contract

  """
  Smart Contract Method Signature
  """
  signature

  """
  Smart Contract Method Name
  """
  signature_name

  """
  Smart Contract Method Signature Hash
  """
  signature_hash
}

enum FlowEventUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique Number of block in the blockchains
  """
  height

  """
  Unique Number of transactions
  """
  transactions

  """
  Unique Number of events
  """
  events

  """
  Unique Number of smart contract
  """
  smart_contracts

  """
  Unique Number of smart contract methods
  """
  smart_contract_methods
}

type FlowFullTransactionDimension {
  """
  Error message
  """
  errorMessage: String

  """
  Count of events inside transaction
  """
  eventsCount: Int

  """
  Gas Limit
  """
  gasLimit: BigInt

  """
  ID of the transaction
  """
  id: String

  """
  Transaction Index inside collection
  """
  indexInCollection: Int

  """
  The account paying for the transaction fees
  """
  payer: String

  """
  ID of proposal key on the proposal account
  """
  proposalKeyId: Int

  """
  Sequence number for the proposal key
  """
  proposalKeySequenceNumber: Int

  """
  The account that specifies a proposal key
  """
  proposer: String

  """
  Block ID used to determine transaction expiry
  """
  referenceBlockId: String

  """
  Status code of transaction where 0 is success and 1 is failure
  """
  statusCode: Int
}

"""
Inputs in Flow blockchain
"""
type FlowInput {
  """
  Address
  """
  address: Address!
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockId: HashSelector
    transactionId: HashSelector
    transactionStatusCode: IntegerSelector
    transactionIndexInCollection: IntegerSelector
    index: IntegerSelector
    smartContractAddress: StringSelector
    smartContractMethod: MethodSelector
    type: StringSelector
    eventIndex: IntegerSelector
    address: StringSelector
    entityId: BigIntIdSelector
    transferReason: FlowTransferReasonSelector
    currency: CurrencySelector
  ): Float

  """
  Input value as decimal
  """
  amountDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockId: HashSelector
    transactionId: HashSelector
    transactionStatusCode: IntegerSelector
    transactionIndexInCollection: IntegerSelector
    index: IntegerSelector
    smartContractAddress: StringSelector
    smartContractMethod: MethodSelector
    type: StringSelector
    eventIndex: IntegerSelector
    address: StringSelector
    entityId: BigIntIdSelector
    transferReason: FlowTransferReasonSelector
    currency: CurrencySelector
  ): DecimalNumberAsDiv
  any(of: FlowInputMeasureable!): String

  """
  Block information
  """
  block(height: BlockSelector, blockId: HashSelector): FlowBlockDimension!
  count(uniq: FlowInputUniq): Int
  countBigInt(
    uniq: FlowInputUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockId: HashSelector
    transactionId: HashSelector
    transactionStatusCode: IntegerSelector
    transactionIndexInCollection: IntegerSelector
    index: IntegerSelector
    smartContractAddress: StringSelector
    smartContractMethod: MethodSelector
    type: StringSelector
    eventIndex: IntegerSelector
    address: StringSelector
    entityId: BigIntIdSelector
    transferReason: FlowTransferReasonSelector
    currency: CurrencySelector
  ): BigInt

  """
  Currency of transfer
  """
  currency: Currency

  """
  The date this transaction was created
  """
  date: Date

  """
  NFT Id
  """
  entityId: BigInt!

  """
  Index of event inside transaction
  """
  eventIndex: Int!
  expression(get: String!): DecimalNumber
  maximum(of: FlowInputMeasureable!, get: FlowInputMeasureable): String
  minimum(of: FlowInputMeasureable!, get: FlowInputMeasureable): String

  """
  Smart contract address
  """
  smartContractAddress: Address

  """
  Contract method invoked
  """
  smartContractMethod: Method

  """
  The time this transaction was created
  """
  time: DateTime

  """
  Transaction information
  """
  transaction(
    transactionId: HashSelector
    transactionIndexInCollection: IntegerSelector
    transactionStatusCode: IntegerSelector
  ): FlowMinorTransactionDimension!

  """
  Transfer reason, e.g. nft_transfer, fungible_token_transfer, fee
  """
  transferReason: String!

  """
  Type of field, e.g. UInt64, String, Bool, etc..
  """
  type: String!
}

input FlowInputFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: HashSelector
  transactionId: HashSelector
  transactionStatusCode: IntegerSelector
  transactionIndexInCollection: IntegerSelector
  index: IntegerSelector
  smartContractAddress: StringSelector
  smartContractMethod: MethodSelector
  type: StringSelector
  eventIndex: IntegerSelector
  address: StringSelector
  entityId: BigIntIdSelector
  transferReason: FlowTransferReasonSelector
  currency: CurrencySelector
}

enum FlowInputMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Number of block in the blockhains
  """
  height

  """
  Hash of the the block
  """
  block_id

  """
  ID transaction
  """
  tx_id

  """
  TX status code
  """
  tx_status_code

  """
  Index of transaction inside collection
  """
  tx_index_in_collection

  """
  Smart Contract
  """
  smart_contract

  """
  Smart Contract Method Signature
  """
  signature

  """
  Smart Contract Method Name
  """
  signature_name

  """
  Smart Contract Method Hash
  """
  signature_hash

  """
  Type
  """
  type

  """
  Index of event inside transaction
  """
  event_index

  """
  Address
  """
  address

  """
  Amount
  """
  amount

  """
  Currency symbol
  """
  currency_symbol

  """
  Currency address
  """
  currency_address

  """
  Entity ID
  """
  entity_id
}

enum FlowInputUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique Number of block in the blockchains
  """
  height

  """
  Unique Number of transactions
  """
  transactions

  """
  Unique Number of events
  """
  events

  """
  Unique Number of smart contract
  """
  smart_contracts

  """
  Unique Number of smart contract methods
  """
  smart_contract_methods

  """
  Unique Number of types
  """
  types

  """
  Unique Number of symbol currencies
  """
  currencies
}

type FlowMinorTransactionDimension {
  """
  ID of the transaction
  """
  id: String

  """
  Transaction Index inside collection
  """
  indexInCollection: Int

  """
  Status code of transaction where 0 is success and 1 is failure
  """
  statusCode: Int
}

enum FlowNetwork {
  """
  Elrond mainnet
  """
  flow
}

"""
Outputs in Flow blockchain
"""
type FlowOutput {
  """
  Address
  """
  address: Address!
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockId: HashSelector
    transactionId: HashSelector
    transactionStatusCode: IntegerSelector
    transactionIndexInCollection: IntegerSelector
    index: IntegerSelector
    smartContractAddress: StringSelector
    smartContractMethod: MethodSelector
    type: StringSelector
    eventIndex: IntegerSelector
    address: StringSelector
    entityId: BigIntIdSelector
    transferReason: FlowTransferReasonSelector
    currency: CurrencySelector
  ): Float

  """
  Input value as decimal
  """
  amountDecimal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockId: HashSelector
    transactionId: HashSelector
    transactionStatusCode: IntegerSelector
    transactionIndexInCollection: IntegerSelector
    index: IntegerSelector
    smartContractAddress: StringSelector
    smartContractMethod: MethodSelector
    type: StringSelector
    eventIndex: IntegerSelector
    address: StringSelector
    entityId: BigIntIdSelector
    transferReason: FlowTransferReasonSelector
    currency: CurrencySelector
  ): DecimalNumberAsDiv
  any(of: FlowOutputMeasureable!): String

  """
  Block information
  """
  block(height: BlockSelector, blockId: HashSelector): FlowBlockDimension!
  count(uniq: FlowOutputUniq): Int
  countBigInt(
    uniq: FlowOutputUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockId: HashSelector
    transactionId: HashSelector
    transactionStatusCode: IntegerSelector
    transactionIndexInCollection: IntegerSelector
    index: IntegerSelector
    smartContractAddress: StringSelector
    smartContractMethod: MethodSelector
    type: StringSelector
    eventIndex: IntegerSelector
    address: StringSelector
    entityId: BigIntIdSelector
    transferReason: FlowTransferReasonSelector
    currency: CurrencySelector
  ): BigInt

  """
  Currency of transfer
  """
  currency: Currency

  """
  The date this transaction was created
  """
  date: Date

  """
  NFT Id
  """
  entityId: BigInt!

  """
  Index of event inside transaction
  """
  eventIndex: Int!
  expression(get: String!): DecimalNumber
  maximum(of: FlowOutputMeasureable!, get: FlowOutputMeasureable): String
  minimum(of: FlowOutputMeasureable!, get: FlowOutputMeasureable): String

  """
  Smart contract address
  """
  smartContractAddress: Address

  """
  Contract method invoked
  """
  smartContractMethod: Method

  """
  The time this transaction was created
  """
  time: DateTime

  """
  Transaction information
  """
  transaction(
    transactionId: HashSelector
    transactionIndexInCollection: IntegerSelector
    transactionStatusCode: IntegerSelector
  ): FlowMinorTransactionDimension!

  """
  Transfer reason, e.g. nft_transfer, fungible_token_transfer, fee
  """
  transferReason: String!

  """
  Type of field, e.g. UInt64, String, Bool, etc..
  """
  type: String!
}

input FlowOutputFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: HashSelector
  transactionId: HashSelector
  transactionStatusCode: IntegerSelector
  transactionIndexInCollection: IntegerSelector
  index: IntegerSelector
  smartContractAddress: StringSelector
  smartContractMethod: MethodSelector
  type: StringSelector
  eventIndex: IntegerSelector
  address: StringSelector
  entityId: BigIntIdSelector
  transferReason: FlowTransferReasonSelector
  currency: CurrencySelector
}

enum FlowOutputMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Number of block in the blockhains
  """
  height

  """
  Hash of the the block
  """
  block_id

  """
  ID transaction
  """
  tx_id

  """
  TX status code
  """
  tx_status_code

  """
  Index of transaction inside collection
  """
  tx_index_in_collection

  """
  Smart Contract
  """
  smart_contract

  """
  Smart Contract Method Signature
  """
  signature

  """
  Smart Contract Method Name
  """
  signature_name

  """
  Smart Contract Method Hash
  """
  signature_hash

  """
  Type
  """
  type

  """
  Index of event inside transaction
  """
  event_index

  """
  Address
  """
  address

  """
  Amount
  """
  amount

  """
  Currency symbol
  """
  currency_symbol

  """
  Currency address
  """
  currency_address

  """
  Entity ID
  """
  entity_id
}

enum FlowOutputUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique Number of block in the blockchains
  """
  height

  """
  Unique Number of transactions
  """
  transactions

  """
  Unique Number of events
  """
  events

  """
  Unique Number of smart contract
  """
  smart_contracts

  """
  Unique Number of smart contract methods
  """
  smart_contract_methods

  """
  Unique Number of types
  """
  types

  """
  Unique Number of symbol currencies
  """
  currencies
}

"""
Transactions in Flow  blockchain
"""
type FlowTransaction {
  any(of: FlowTransactionMeasureable!): String

  """
  Block information
  """
  block(height: BlockSelector, blockId: HashSelector): FlowBlockDimension!

  """
  SHA3-256 hash of the collection contents
  """
  collectionId: String
  count(uniq: FlowTransactionUniq): Int
  countBigInt(uniq: FlowTransactionUniq): BigInt

  """
  The date this transaction was created
  """
  date: Date

  """
  Error message
  """
  errorMessage: String

  """
  Count of events inside transaction
  """
  eventsCount: Int
  expression(get: String!): DecimalNumber

  """
  Gas Limit
  """
  gasLimit: BigInt

  """
  ID of the transaction
  """
  id: String

  """
  Transaction Index inside collection
  """
  indexInCollection: Int
  maximum(
    of: FlowTransactionMeasureable!
    get: FlowTransactionMeasureable
  ): String
  minimum(
    of: FlowTransactionMeasureable!
    get: FlowTransactionMeasureable
  ): String

  """
  The account paying for the transaction fees
  """
  payer: Address

  """
  ID of proposal key on the proposal account
  """
  proposalKeyId: Int

  """
  Sequence number for the proposal key
  """
  proposalKeySequenceNumber: Int

  """
  The account that specifies a proposal key
  """
  proposer: Address

  """
  Block ID used to determine transaction expiry
  """
  referenceBlockId: String

  """
  Raw source code for a Cadence script, encoded as UTF-8 bytes
  """
  script: String

  """
  Status code of transaction where 0 is success and 1 is failure
  """
  statusCode: Int

  """
  The time this transaction was created
  """
  time: DateTime
}

"""
TransactionAuthorizers in Flow blockchain
"""
type FlowTransactionAuthorizer {
  any(of: FlowTransactionAuthorizerMeasureable!): String

  """
  Account authorizing the transaction to mutate their state.
  """
  authorizer: Address

  """
  Block information
  """
  block(height: BlockSelector, blockId: HashSelector): FlowBlockDimension!

  """
  SHA3-256 hash of the collection contents
  """
  collectionId: String
  count(uniq: FlowTransactionAuthorizerUniq): Int
  countBigInt(uniq: FlowTransactionAuthorizerUniq): BigInt

  """
  The date this transaction was created
  """
  date: Date
  expression(get: String!): DecimalNumber
  maximum(
    of: FlowTransactionAuthorizerMeasureable!
    get: FlowTransactionAuthorizerMeasureable
  ): String
  minimum(
    of: FlowTransactionAuthorizerMeasureable!
    get: FlowTransactionAuthorizerMeasureable
  ): String

  """
  The time this transaction was created
  """
  time: DateTime

  """
  Information about transaction
  """
  transaction(
    transactionId: HashSelector
    indexInCollection: IntegerSelector
    referenceBlockId: HashSelector
    gasLimit: IntegerSelector
    payer: HashSelector
    proposer: HashSelector
    proposalKeyId: IntegerSelector
    proposalKeySequenceNumber: IntegerSelector
    eventsCount: IntegerSelector
    errorMessage: StringSelector
    statusCode: IntegerSelector
  ): FlowFullTransactionDimension!
}

input FlowTransactionAuthorizerFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: HashSelector
  collectionId: HashSelector
  transactionId: HashSelector
  indexInCollection: IntegerSelector
  referenceBlockId: StringSelector
  gasLimit: IntegerSelector
  payer: AddressSelector
  proposer: AddressSelector
  proposalKeyId: IntegerSelector
  proposalKeySequenceNumber: IntegerSelector
  eventsCount: IntegerSelector
  statusCode: IntegerSelector
  authorizer: AddressSelector
}

enum FlowTransactionAuthorizerMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Number of block in the blockhains
  """
  height

  """
  Hash of the the block
  """
  block_id

  """
  SHA3-256 hash of the collection contents
  """
  collection_id

  """
  Transaction ID
  """
  tx_id

  """
  Transaction index inside collection
  """
  tx_index_in_collection

  """
  Reference block hash
  """
  reference_block_id

  """
  Gas Limit
  """
  gas_limit

  """
  The account paying for the transaction fees
  """
  payer

  """
  The account that specifies a proposal key
  """
  proposer

  """
  Proposer Key ID
  """
  proposer_key_id

  """
  Proposer key sequence number
  """
  proposal_key_sequence_number

  """
  Count of events inside transactions
  """
  events_count

  """
  Error message in transaction
  """
  error_message

  """
  Status code of transaction
  """
  status_code

  """
  Account authorizing the transaction to mutate their state.
  """
  authorizer
}

enum FlowTransactionAuthorizerUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique Number of block in the blockchains
  """
  height

  """
  Unique Number of collection
  """
  collection_id

  """
  Transaction ID
  """
  tx_id

  """
  Transaction index inside collection
  """
  tx_index_in_collection

  """
  Reference block hash
  """
  reference_block_id

  """
  The account paying for the transaction fees
  """
  payers

  """
  The account that specifies a proposal key
  """
  proposers

  """
  Unique Number of authorizers
  """
  authorizers
}

"""
TransactionEnvelopeSignature in Flow blockchain
"""
type FlowTransactionEnvelopeSignature {
  """
  Address of the account for this signature
  """
  address: Address!
  any(of: FlowTransactionEnvelopeSignatureMeasureable!): String

  """
  Block information
  """
  block(height: BlockSelector, blockId: HashSelector): FlowBlockDimension!

  """
  SHA3-256 hash of the collection contents
  """
  collectionId: String!
  count(uniq: FlowTransactionEnvelopeSignatureUniq): Int
  countBigInt(uniq: FlowTransactionEnvelopeSignatureUniq): BigInt

  """
  The date this transaction was created
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  ID of the account key
  """
  keyId: Int!
  maximum(
    of: FlowTransactionEnvelopeSignatureMeasureable!
    get: FlowTransactionEnvelopeSignatureMeasureable
  ): String
  minimum(
    of: FlowTransactionEnvelopeSignatureMeasureable!
    get: FlowTransactionEnvelopeSignatureMeasureable
  ): String

  """
  Raw signature data
  """
  signature: String!

  """
  The time this transaction was created
  """
  time: DateTime

  """
  Information about transaction
  """
  transaction(
    transactionId: HashSelector
    indexInCollection: IntegerSelector
    referenceBlockId: HashSelector
    gasLimit: IntegerSelector
    payer: HashSelector
    proposer: HashSelector
    proposalKeyId: IntegerSelector
    proposalKeySequenceNumber: IntegerSelector
    eventsCount: IntegerSelector
    errorMessage: StringSelector
    statusCode: IntegerSelector
  ): FlowFullTransactionDimension!
}

input FlowTransactionEnvelopeSignatureFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: HashSelector
  collectionId: HashSelector
  transactionId: HashSelector
  indexInCollection: IntegerSelector
  referenceBlockId: StringSelector
  gasLimit: IntegerSelector
  payer: AddressSelector
  proposer: AddressSelector
  proposalKeyId: IntegerSelector
  proposalKeySequenceNumber: IntegerSelector
  eventsCount: IntegerSelector
  statusCode: IntegerSelector
  address: AddressSelector
  keyId: IntegerSelector
  signature: StringSelector
}

enum FlowTransactionEnvelopeSignatureMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Number of block in the blockhains
  """
  height

  """
  Hash of the the block
  """
  block_id

  """
  SHA3-256 hash of the collection contents
  """
  collection_id

  """
  Transaction ID
  """
  tx_id

  """
  Transaction index inside collection
  """
  tx_index_in_collection

  """
  Reference block hash
  """
  reference_block_id

  """
  Gas Limit
  """
  gas_limit

  """
  The account paying for the transaction fees
  """
  payer

  """
  The account that specifies a proposal key
  """
  proposer

  """
  Proposer Key ID
  """
  proposer_key_id

  """
  Proposer key sequence number
  """
  proposal_key_sequence_number

  """
  Count of events inside transactions
  """
  events_count

  """
  Error message in transaction
  """
  error_message

  """
  Status code of transaction
  """
  status_code

  """
  Address of the account for this signature
  """
  address

  """
  ID of account key
  """
  key_id

  """
  Raw signature data
  """
  signature
}

enum FlowTransactionEnvelopeSignatureUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique Number of block in the blockchains
  """
  height

  """
  Unique Number of collection
  """
  collection_id

  """
  Transaction ID
  """
  tx_id

  """
  Transaction index inside collection
  """
  tx_index_in_collection

  """
  Reference block hash
  """
  reference_block_id

  """
  The account paying for the transaction fees
  """
  payers

  """
  The account that specifies a proposal key
  """
  proposers

  """
  The address and key ID fields declare the account key that generated the signature
  """
  addresses
}

input FlowTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: HashSelector
  collectionId: HashSelector
  transactionId: HashSelector
  indexInCollection: IntegerSelector
  referenceBlockId: StringSelector
  gasLimit: IntegerSelector
  payer: AddressSelector
  proposer: AddressSelector
  proposalKeyId: IntegerSelector
  proposalKeySequenceNumber: IntegerSelector
  eventsCount: IntegerSelector
  statusCode: IntegerSelector
}

"""
Blockchain transaction
"""
type FlowTransactionHashIndexValues {
  """
  Hash hex representation
  """
  id: String!

  """
  Transaction value in input
  """
  valueIn: Float!

  """
  Transaction value in input
  """
  valueInDecimal: DecimalNumber!

  """
  Transaction value in output
  """
  valueOut: Float!

  """
  Transaction value in output
  """
  valueOutDecimal: DecimalNumber!
}

enum FlowTransactionMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Number of block in the blockhains
  """
  height

  """
  Hash of the the block
  """
  block_id

  """
  SHA3-256 hash of the collection contents
  """
  collection_id

  """
  Transaction ID
  """
  tx_id

  """
  Transaction index inside collection
  """
  tx_index_in_collection

  """
  Reference block hash
  """
  reference_block_id

  """
  Gas Limit
  """
  gas_limit

  """
  The account paying for the transaction fees
  """
  payer

  """
  The account that specifies a proposal key
  """
  proposer

  """
  Proposer Key ID
  """
  proposer_key_id

  """
  Proposer key sequence number
  """
  proposal_key_sequence_number

  """
  Count of events inside transactions
  """
  events_count

  """
  Error message in transaction
  """
  error_message

  """
  Status code of transaction
  """
  status_code
}

"""
TransactionPayloadSignature in Flow blockchain
"""
type FlowTransactionPayloadSignature {
  """
  Address of the account for this signature
  """
  address: Address!
  any(of: FlowTransactionPayloadSignatureMeasureable!): String

  """
  Block information
  """
  block(height: BlockSelector, blockId: HashSelector): FlowBlockDimension!

  """
  SHA3-256 hash of the collection contents
  """
  collectionId: String!
  count(uniq: FlowTransactionPayloadSignatureUniq): Int
  countBigInt(uniq: FlowTransactionPayloadSignatureUniq): BigInt

  """
  The date this transaction was created
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  ID of the account key
  """
  keyId: Int!
  maximum(
    of: FlowTransactionPayloadSignatureMeasureable!
    get: FlowTransactionPayloadSignatureMeasureable
  ): String
  minimum(
    of: FlowTransactionPayloadSignatureMeasureable!
    get: FlowTransactionPayloadSignatureMeasureable
  ): String

  """
  Raw signature data
  """
  signature: String!

  """
  The time this transaction was created
  """
  time: DateTime

  """
  Information about transaction
  """
  transaction(
    transactionId: HashSelector
    indexInCollection: IntegerSelector
    referenceBlockId: HashSelector
    gasLimit: IntegerSelector
    payer: HashSelector
    proposer: HashSelector
    proposalKeyId: IntegerSelector
    proposalKeySequenceNumber: IntegerSelector
    eventsCount: IntegerSelector
    errorMessage: StringSelector
    statusCode: IntegerSelector
  ): FlowFullTransactionDimension!
}

input FlowTransactionPayloadSignatureFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: HashSelector
  collectionId: HashSelector
  transactionId: HashSelector
  indexInCollection: IntegerSelector
  referenceBlockId: StringSelector
  gasLimit: IntegerSelector
  payer: AddressSelector
  proposer: AddressSelector
  proposalKeyId: IntegerSelector
  proposalKeySequenceNumber: IntegerSelector
  eventsCount: IntegerSelector
  statusCode: IntegerSelector
  address: AddressSelector
  keyId: IntegerSelector
  signature: StringSelector
}

enum FlowTransactionPayloadSignatureMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Number of block in the blockhains
  """
  height

  """
  Hash of the the block
  """
  block_id

  """
  SHA3-256 hash of the collection contents
  """
  collection_id

  """
  Transaction ID
  """
  tx_id

  """
  Transaction index inside collection
  """
  tx_index_in_collection

  """
  Reference block hash
  """
  reference_block_id

  """
  Gas Limit
  """
  gas_limit

  """
  The account paying for the transaction fees
  """
  payer

  """
  The account that specifies a proposal key
  """
  proposer

  """
  Proposer Key ID
  """
  proposer_key_id

  """
  Proposer key sequence number
  """
  proposal_key_sequence_number

  """
  Count of events inside transactions
  """
  events_count

  """
  Error message in transaction
  """
  error_message

  """
  Status code of transaction
  """
  status_code

  """
  Address of the account for this signature
  """
  address

  """
  ID of account key
  """
  key_id

  """
  Raw signature data
  """
  signature
}

enum FlowTransactionPayloadSignatureUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique Number of block in the blockchains
  """
  height

  """
  Unique Number of collection
  """
  collection_id

  """
  Transaction ID
  """
  tx_id

  """
  Transaction index inside collection
  """
  tx_index_in_collection

  """
  Reference block hash
  """
  reference_block_id

  """
  The account paying for the transaction fees
  """
  payers

  """
  The account that specifies a proposal key
  """
  proposers

  """
  The address and key ID fields declare the account key that generated the signature
  """
  addresses
}

enum FlowTransactionUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique Number of block in the blockchains
  """
  height

  """
  Unique Number of collection
  """
  collection_id

  """
  Transaction ID
  """
  tx_id

  """
  Transaction index inside collection
  """
  tx_index_in_collection

  """
  Reference block hash
  """
  reference_block_id

  """
  The account paying for the transaction fees
  """
  payers

  """
  The account that specifies a proposal key
  """
  proposers
}

enum FlowTransferReasonEnum {
  """
  Currency transfer
  """
  fungible_token_transfer

  """
  NFT Transfer
  """
  nft_transfer

  """
  Fee paid
  """
  fee
}

"""
Select by transfer reason
"""
input FlowTransferReasonSelector {
  """
  Reason is
  """
  is: FlowTransferReasonEnum

  """
  Reason not
  """
  not: FlowTransferReasonEnum

  """
  Reason in the list
  """
  in: [FlowTransferReasonEnum!]

  """
  Reason not in the list
  """
  notIn: [FlowTransferReasonEnum!]
}

"""
Select transactions by group
"""
input GroupSelector {
  """
  Transaction group is
  """
  is: String

  """
  Transaction group not
  """
  not: String

  """
  Transaction group in the list
  """
  in: [String!]

  """
  Transaction group not in the list
  """
  notIn: [String!]
}

"""
Harmony Chain
"""
type Harmony {
  """
  Arguments of Smart Contract Calls and Events
  """
  arguments(
    time: DateTimeSelector
    date: DateSelector
    ledger: BlockSelector
    blockHash: HashSelector
    nonce: BigIntIdSelector
    txIndex: BigIntegerSelector
    shardId: BigIntegerSelector
    toShardId: BigIntegerSelector
    sender: HashSelector
    receiver: HashSelector
    smartContractAddress: HashSelector
    smartContractId: IntegerSelector
    argument: StringSelector
    any: [HarmonyArgumentsFilter!]
    options: QueryOptions
  ): [HarmonyArguments!]

  """
  Harmony Blocks
  """
  blocks(
    date: DateSelector
    time: DateTimeSelector
    shardId: BigIntegerSelector
    epoch: BigIntegerSelector
    ledger: BlockSelector
    blockHash: HashSelector
    miner: HashSelector
    difficulty: HashSelector
    nonce: BigIntegerSelector
    viewId: HashSelector
    parentHash: HashSelector
    transactionCount: HashSelector
    size: BigIntegerSelector
    stakingTransactionsCount: HashSelector
    unclesCount: HashSelector
    any: [HarmonyBlocksFilter!]
    options: QueryOptions
  ): [HarmonyBlocks!]

  """
  Smart Contract Calls
  """
  smartContractCalls(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    nonce: BigIntIdSelector
    txIndex: BigIntegerSelector
    shardId: BigIntegerSelector
    toShardId: BigIntegerSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    external: Boolean
    success: Boolean
    any: [HarmonySmartContractCallsFilter!]
    options: QueryOptions
  ): [HarmonySmartContractCalls!]

  """
  Smart Contract Events
  """
  smartContractEvents(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    nonce: BigIntIdSelector
    txIndex: BigIntegerSelector
    shardId: BigIntegerSelector
    toShardId: BigIntegerSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    smartContractAddress: AddressSelector
    smartContractEvent: EventSelector
    any: [HarmonySmartContractEventsFilter!]
    options: QueryOptions
  ): [HarmonySmartContractEvents!]

  """
  Harmony Staking Transactions
  """
  stakingTransactions(
    date: DateSelector
    transactionHash: HashSelector
    ledger: BlockSelector
    shardId: BigIntIdSelector
    nonce: BigIntIdSelector
    transactionType: StakingTransactionsTypeSelector
    validatorAddress: HashSelector
    delegatorAddress: HashSelector
    success: Boolean
    status: Boolean
    any: [HarmonyStakingTransactionsFilter!]
    options: QueryOptions
  ): [HarmonyStakingTransactions!]

  """
  Harmony Transactions
  """
  transactions(
    date: DateSelector
    time: DateTimeSelector
    shardId: BigIntegerSelector
    toShardId: BigIntegerSelector
    epoch: BigIntegerSelector
    nonce: BigIntegerSelector
    transactionHash: StringSelector
    transactionIndex: HashSelector
    ledger: BigIntIdSelector
    creates: StringSelector
    sender: HashSelector
    receiver: HashSelector
    success: Boolean
    status: Boolean
    any: [HarmonyTransactionsFilter!]
    options: QueryOptions
  ): [HarmonyTransactions!]

  """
  Harmony Transfers
  """
  transfers(
    date: DateSelector
    time: DateTimeSelector
    ledger: BlockSelector
    blockHash: HashSelector
    transactionHash: HashSelector
    transactionIndex: IntegerSelector
    sender: HashSelector
    transferFrom: AddressSelector
    transferTo: AddressSelector
    status: Boolean
    success: Boolean
    currency: CurrencySelector
    entityId: IntIdSelector
    any: [HarmonyTransfersFilter!]
    options: QueryOptions
  ): [HarmonyTransfers!]
}

"""
Arguments of Smart Contract Calls and Events
"""
type HarmonyArguments {
  """
  Address
  """
  address: String
  any(of: HarmonyArgumentsMeasureable!): String

  """
  Argument Index
  """
  argIndex: String

  """
  Argument Type
  """
  argType: String

  """
  Argument
  """
  argument(argument: String): String

  """
  Transaction hash
  """
  blockHash(blockHash: HashSelector): String

  """
  Call Path
  """
  callPath: String
  count(uniq: HarmonyArgumentsUniq): Int

  """
  The date this transaction was created
  """
  date: Date

  """
  Epoch
  """
  epoch: BigInt
  expression(get: String!): DecimalNumber

  """
  Value
  """
  external: Int

  """
  Hash of the block where this transaction was in
  """
  ledger(ledger: BlockSelector): BigInt
  maximum(
    of: HarmonyArgumentsMeasureable!
    get: HarmonyArgumentsMeasureable
  ): String
  minimum(
    of: HarmonyArgumentsMeasureable!
    get: HarmonyArgumentsMeasureable
  ): String

  """
  The number of transactions made by the sender prior to this one.
  """
  nonce: BigInt

  """
  Number
  """
  number: String

  """
  Address of the receiver
  """
  receiver(receiver: HashSelector): String

  """
  Address of the sender
  """
  sender(sender: HashSelector): String

  """
  ShardID
  """
  shardId: BigInt

  """
  Signature ID
  """
  signatureId: BigInt

  """
  Address of the smart contract
  """
  smartContractAddress(smartContractAddress: HashSelector): String

  """
  Id of the smart contract
  """
  smartContractId(smartContractAddress: IntegerSelector): BigInt

  """
  The time this transaction was created
  """
  time: DateTime

  """
  To Shard ID
  """
  toShardId: BigInt

  """
  Value
  """
  value: String
}

input HarmonyArgumentsFilter {
  time: DateTimeSelector
  date: DateSelector
  ledger: BlockSelector
  blockHash: HashSelector
  nonce: BigIntIdSelector
  txIndex: BigIntegerSelector
  shardId: BigIntegerSelector
  toShardId: BigIntegerSelector
  sender: HashSelector
  receiver: HashSelector
  smartContractAddress: HashSelector
  smartContractId: IntegerSelector
  argument: StringSelector
}

enum HarmonyArgumentsMeasureable {
  """
  Time
  """
  time

  """
  Date
  """
  date

  """
  Block hash
  """
  block_hash

  """
  Address of the sender
  """
  sender

  """
  Address of  the receive
  """
  receiver

  """
  TX Index
  """
  tx_index

  """
  Epoch
  """
  epoch

  """
  Nonce
  """
  nonce

  """
  Shard ID
  """
  shard_id

  """
  TO Shard ID
  """
  to_shard_id

  """
  Address of the smart contract
  """
  smart_contract_address

  """
  Id of the smart contract
  """
  smart_contract_id

  """
  Signature
  """
  signature

  """
  Name of the signature
  """
  signature_name

  """
  Hash of the signature
  """
  signature_hash

  """
  Value
  """
  value

  """
  Address
  """
  address
}

enum HarmonyArgumentsUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique ledger count
  """
  ledger

  """
  Unique block hash count
  """
  block_hash

  """
  Unique smart contract address
  """
  smart_contract_address

  """
  Unique address of the sender
  """
  sender

  """
  Unique address of the receiver
  """
  receiver

  """
  Unique addresses
  """
  address
}

"""
Blocks in Harmony blockchain
"""
type HarmonyBlocks {
  any(of: HarmonyBlocksMeasureable!): String

  """
  Transaction hash
  """
  blockHash(blockHash: HashSelector): String
  count(uniq: HarmonyBlocksUniq): Int
  countBigInt(uniq: HarmonyBlocksUniq): BigInt

  """
  The date this transaction was created
  """
  date: Date

  """
  Difficulty
  """
  difficulty: String

  """
  Epoch
  """
  epoch: BigInt
  expression(get: String!): DecimalNumber

  """
  The “extra data” field of this block
  """
  extraData: String
  gasLimit(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    shardId: BigIntegerSelector
    epoch: BigIntegerSelector
    ledger: BlockSelector
    blockHash: HashSelector
    miner: HashSelector
    difficulty: HashSelector
    nonce: BigIntegerSelector
    viewId: HashSelector
    parentHash: HashSelector
    transactionCount: HashSelector
    size: BigIntegerSelector
    stakingTransactionsCount: HashSelector
    unclesCount: HashSelector
  ): Float
  gasUsed(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    shardId: BigIntegerSelector
    epoch: BigIntegerSelector
    ledger: BlockSelector
    blockHash: HashSelector
    miner: HashSelector
    difficulty: HashSelector
    nonce: BigIntegerSelector
    viewId: HashSelector
    parentHash: HashSelector
    transactionCount: HashSelector
    size: BigIntegerSelector
    stakingTransactionsCount: HashSelector
    unclesCount: HashSelector
  ): Float

  """
  Hash of the block where this transaction was in
  """
  ledger(ledger: BlockSelector): BigInt

  """
  The bloom filter for the logs of the block. null when its pending block
  """
  logsBloom: String
  maximum(of: HarmonyBlocksMeasureable!, get: HarmonyBlocksMeasureable): String

  """
  Transaction hash
  """
  miner(miner: HashSelector): String
  minimum(of: HarmonyBlocksMeasureable!, get: HarmonyBlocksMeasureable): String

  """
  Mix Hash
  """
  mixHash: String

  """
  Nonce
  """
  nonce: BigInt

  """
  Parent hash
  """
  parentHash(parentHash: HashSelector): String

  """
  Receipts Root
  """
  receiptsRoot: String

  """
  ShardID
  """
  shardId: BigInt

  """
  Integer the size of this block in bytes
  """
  size(size: HashSelector): BigInt

  """
  Staking Transaction Count
  """
  stakingTransactionsCount(stakingTransactionsCount: HashSelector): BigInt

  """
  The root of the final state trie of the block
  """
  stateRoot: String

  """
  The time this transaction was created
  """
  time: DateTime

  """
  Transaction Count
  """
  transactionCount(transactionCount: HashSelector): BigInt

  """
  The root of the transaction trie of the block
  """
  transactionsRoot: String

  """
  Count of ucles hashes
  """
  unclesCount(unclesCount: HashSelector): BigInt

  """
  View ID
  """
  viewId(viewId: HashSelector): String
}

input HarmonyBlocksFilter {
  date: DateSelector
  time: DateTimeSelector
  shardId: BigIntegerSelector
  epoch: BigIntegerSelector
  ledger: BlockSelector
  blockHash: HashSelector
  miner: HashSelector
  difficulty: HashSelector
  nonce: BigIntegerSelector
  viewId: HashSelector
  parentHash: HashSelector
  transactionCount: HashSelector
  size: BigIntegerSelector
  stakingTransactionsCount: HashSelector
  unclesCount: HashSelector
}

enum HarmonyBlocksMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Gas limit
  """
  gas_limit

  """
  Gas Used
  """
  gas_used

  """
  Block hash
  """
  block_hash

  """
  Parent hash
  """
  paret_hash

  """
  Transaction Count
  """
  transaction_count
}

enum HarmonyBlocksUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique ledger count
  """
  ledger

  """
  Unique block hash count
  """
  block_hash

  """
  Unique parent hash count
  """
  parent_hash

  """
  Unique miner count
  """
  miner

  """
  Unique mix hash count
  """
  mix_hash

  """
  Unique state root count
  """
  state_root

  """
  Unique receipts root count
  """
  receipts_root

  """
  Unique transactions root count
  """
  transactions_root
}

enum HarmonyEventsMeasureable {
  """
  Time
  """
  time

  """
  Date
  """
  date

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Nonce
  """
  nonce

  """
  Transaction Index
  """
  tx_index

  """
  Shard ID
  """
  shard_id

  """
  To Shard ID
  """
  to_shard_id

  """
  Action To
  """
  tx_to

  """
  Action From
  """
  tx_from

  """
  Smart Contract
  """
  smart_contract

  """
  Smart Contract Method Signature
  """
  signature

  """
  Smart Contract Method Signature Hash
  """
  signature_hash

  """
  Smart Contract Method Name
  """
  signature_name
}

enum HarmonyNetwork {
  """
  Harmony Mainnat
  """
  harmony

  """
  Harmony Testnet
  """
  harmony_testnet
}

"""
Smart Contract Calls
"""
type HarmonySmartContractCalls {
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    nonce: BigIntIdSelector
    txIndex: BigIntegerSelector
    shardId: BigIntegerSelector
    toShardId: BigIntegerSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    external: Boolean
    success: Boolean
  ): Float
  any(of: HarmonySmartContractCallsMeasureable!): String

  """
  Block in the blockchain
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Depth of the call. Empty string for external call, then counted as 0...N, and
  the next layer is added through '-'. For example 0-3-9.
  """
  callPath: String

  """
  Counts and other metrics
  """
  count(
    uniq: HarmonySmartContractCallsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    nonce: BigIntIdSelector
    txIndex: BigIntegerSelector
    shardId: BigIntegerSelector
    toShardId: BigIntegerSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    external: Boolean
    success: Boolean
  ): Int

  """
  Counts and other metrics
  """
  countBigInt(
    uniq: HarmonySmartContractCallsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    nonce: BigIntIdSelector
    txIndex: BigIntegerSelector
    shardId: BigIntegerSelector
    toShardId: BigIntegerSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    external: Boolean
    success: Boolean
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  External call executed explicitly by caller. Internal calls executed by smart contracts.
  """
  external(external: Boolean): Boolean
  gas(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    nonce: BigIntIdSelector
    txIndex: BigIntegerSelector
    shardId: BigIntegerSelector
    toShardId: BigIntegerSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    external: Boolean
    success: Boolean
  ): Int

  """
  Gas unit price
  """
  gasPrice(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    nonce: BigIntIdSelector
    txIndex: BigIntegerSelector
    shardId: BigIntegerSelector
    toShardId: BigIntegerSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    external: Boolean
    success: Boolean
  ): Float!
  gasValue(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    nonce: BigIntIdSelector
    txIndex: BigIntegerSelector
    shardId: BigIntegerSelector
    toShardId: BigIntegerSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    external: Boolean
    success: Boolean
  ): Float
  maximum(
    of: HarmonySmartContractCallsMeasureable!
    get: HarmonySmartContractCallsMeasureable
  ): String
  minimum(
    of: HarmonySmartContractCallsMeasureable!
    get: HarmonySmartContractCallsMeasureable
  ): String

  """
  Nonce
  """
  nonce(nonce: IntegerSelector): BigInt

  """
  ShardID
  """
  shardId: BigInt

  """
  Smart contract address
  """
  smartContractAddress: Address

  """
  Contract method invoked
  """
  smartContractMethod(smartContractMethod: MethodSelector): Method

  """
  True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
  """
  success(success: [Boolean!]): Boolean

  """
  ToShardID
  """
  toShardId: BigInt

  """
  Action from address
  """
  txFrom(txFrom: AddressSelector): Address

  """
  Transaction hash where transfer happened
  """
  txHash(txHash: HashSelector): String

  """
  Tx index
  """
  txIndex: BigInt

  """
  Transaction Sender
  """
  txSender(txSender: AddressSelector): Address

  """
  Action to address
  """
  txTo(txTo: AddressSelector): Address
}

input HarmonySmartContractCallsFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  nonce: BigIntIdSelector
  txIndex: BigIntegerSelector
  shardId: BigIntegerSelector
  toShardId: BigIntegerSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  smartContractAddress: AddressSelector
  smartContractMethod: MethodSelector
  external: Boolean
  success: Boolean
}

enum HarmonySmartContractCallsMeasureable {
  """
  Time
  """
  time

  """
  Date
  """
  date

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Nonce
  """
  nonce

  """
  Transaction Index
  """
  tx_index

  """
  Sender
  """
  sender

  """
  Receiver
  """
  receiver

  """
  Shard ID
  """
  shard_id

  """
  To Shard ID
  """
  to_shard_id

  """
  Action From
  """
  tx_from

  """
  Smart Contract
  """
  smart_contract

  """
  Smart Contract Method Name
  """
  signature_name

  """
  Smart Contract Method Signature
  """
  signature

  """
  Smart Contract Method Signature Hash
  """
  signature_hash

  """
  Call depth
  """
  call_path

  """
  Success
  """
  success

  """
  External
  """
  external
}

enum HarmonySmartContractCallsUniq {
  """
  Unique blocks
  """
  blocks

  """
  Unique date count
  """
  dates

  """
  Unique transactions count
  """
  txs

  """
  Unique transactions senders
  """
  tx_sender

  """
  Unique callers count
  """
  tx_to

  """
  Unique transaction senders
  """
  tx_from

  """
  Unique smart contracts count
  """
  smart_contracts

  """
  Unique smart contract methods count
  """
  smart_contract_methods
}

"""
Smart Contract Events
"""
type HarmonySmartContractEvents {
  any(of: HarmonyEventsMeasureable!): String

  """
  Block in the blockchain
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Counts and other metrics
  """
  count(uniq: SmartContractEventsUniq): Int

  """
  Counts and other metrics
  """
  countBigInt(uniq: SmartContractEventsUniq): BigInt

  """
  Calendar date
  """
  date: Date

  """
  Transaction hash where transfer happened
  """
  epoch(epoch: IntegerSelector): BigInt
  expression(get: String!): DecimalNumber
  maximum(of: HarmonyEventsMeasureable!, get: HarmonyEventsMeasureable): String
  minimum(of: HarmonyEventsMeasureable!, get: HarmonyEventsMeasureable): String

  """
  The number of transactions made by the sender prior to this one.
  """
  nonce(nonce: IntegerSelector): BigInt

  """
  ShardID
  """
  shardId: BigInt

  """
  Smart contract address
  """
  smartContractAddress: Address

  """
  Contract method invoked
  """
  smartContractEvent(smartContractEvent: EventSelector): Event

  """
  ToShardID
  """
  toShardId: BigInt

  """
  Action from address
  """
  txFrom(txFrom: AddressSelector): Address

  """
  Transaction hash where transfer happened
  """
  txHash(txHash: HashSelector): String

  """
  Tx index
  """
  txIndex: BigInt

  """
  Action to address
  """
  txTo(txTo: AddressSelector): Address
}

input HarmonySmartContractEventsFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  nonce: BigIntIdSelector
  txIndex: BigIntegerSelector
  shardId: BigIntegerSelector
  toShardId: BigIntegerSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  smartContractAddress: AddressSelector
  smartContractEvent: EventSelector
}

"""
StakingTransactions in Harmony blockchain
"""
type HarmonyStakingTransactions {
  any(of: HarmonyStakingTransactionsMeasureable!): String

  """
  Hash of block
  """
  blockHash: String
  count(uniq: HarmonyStakingTransactionsUniq): Int
  countBigInt(uniq: HarmonyStakingTransactionsUniq): BigInt

  """
  Data
  """
  data: String

  """
  The date this transaction was created
  """
  date: Date

  """
  Delegator Address
  """
  delegatorAddress(delegatorAddress: HashSelector): String

  """
  Epoch
  """
  epoch: BigInt
  expression(get: String!): DecimalNumber

  """
  Gas provided by the sender
  """
  gas: BigInt

  """
  Gas price provided by the sender
  """
  gasPrice: String
  gasValue(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    transactionHash: HashSelector
    ledger: BlockSelector
    shardId: BigIntIdSelector
    nonce: BigIntIdSelector
    transactionType: StakingTransactionsTypeSelector
    validatorAddress: HashSelector
    delegatorAddress: HashSelector
    success: Boolean
    status: Boolean
  ): Float

  """
  Hash of the block where this transaction was in
  """
  ledger(ledger: BlockSelector): BigInt
  maximum(
    of: HarmonyStakingTransactionsMeasureable!
    get: HarmonyStakingTransactionsMeasureable
  ): String
  minimum(
    of: HarmonyStakingTransactionsMeasureable!
    get: HarmonyStakingTransactionsMeasureable
  ): String

  """
  The number of transactions made by the sender prior to this one
  """
  nonce: BigInt

  """
  ShardID
  """
  shardId: BigInt

  """
  Status
  """
  status(status: Boolean): Boolean

  """
  Successful of not
  """
  success(success: Boolean): Boolean

  """
  The time this transaction was created
  """
  time: DateTime

  """
  Transaction hash
  """
  transactionHash(transactionHash: HashSelector): String

  """
  Transaction type
  """
  transactionType(transactionType: StakingTransactionsTypeSelector): String

  """
  Validator Address
  """
  validatorAddress(validatorAddress: HashSelector): String

  """
  Value transferred in ATTO
  """
  value: String
}

input HarmonyStakingTransactionsFilter {
  date: DateSelector
  transactionHash: HashSelector
  ledger: BlockSelector
  shardId: BigIntIdSelector
  nonce: BigIntIdSelector
  transactionType: StakingTransactionsTypeSelector
  validatorAddress: HashSelector
  delegatorAddress: HashSelector
  success: Boolean
  status: Boolean
}

enum HarmonyStakingTransactionsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Transaction Hash
  """
  transaction_hash

  """
  Gas price provided by the sender
  """
  gas_price

  """
  Validator Address
  """
  validator_address

  """
  Deligator Address
  """
  deligator_address

  """
  Value transferred in ATTO
  """
  value

  """
  Gas price provided by the sender
  """
  gasPrice

  """
  Gas provided by the sender
  """
  gas
}

enum HarmonyStakingTransactionsUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique block
  """
  ledger

  """
  Unique address validator
  """
  validator_address

  """
  Unique delegator validator
  """
  delegator_address

  """
  Unique smart contract addresses
  """
  smart_contract_address
}

"""
Transactions in Harmony blockchain
"""
type HarmonyTransactions {
  any(of: HarmonyTransactionsMeasureable!): String

  """
  Hash of the block
  """
  blockHash(blockHash: HashSelector): String
  count(uniq: HarmonyTransactionsUniq): Int
  countBigInt(uniq: HarmonyTransactionsUniq): BigInt

  """
  Transaction creates
  """
  creates(creates: HashSelector): String

  """
  Data
  """
  data: String

  """
  The date this transaction was created
  """
  date: Date

  """
  Epoch
  """
  epoch: BigInt
  expression(get: String!): DecimalNumber
  gas(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    shardId: BigIntegerSelector
    toShardId: BigIntegerSelector
    epoch: BigIntegerSelector
    nonce: BigIntegerSelector
    transactionHash: StringSelector
    transactionIndex: HashSelector
    ledger: BigIntIdSelector
    creates: StringSelector
    sender: HashSelector
    receiver: HashSelector
    success: Boolean
    status: Boolean
  ): Float

  """
  Gas price provided by the sender
  """
  gasPrice: String
  gasValue(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    shardId: BigIntegerSelector
    toShardId: BigIntegerSelector
    epoch: BigIntegerSelector
    nonce: BigIntegerSelector
    transactionHash: StringSelector
    transactionIndex: HashSelector
    ledger: BigIntIdSelector
    creates: StringSelector
    sender: HashSelector
    receiver: HashSelector
    success: Boolean
    status: Boolean
  ): Float

  """
  Hash of the block where this transaction was in
  """
  ledger(ledger: BlockSelector): BigInt
  maximum(
    of: HarmonyTransactionsMeasureable!
    get: HarmonyTransactionsMeasureable
  ): String
  minimum(
    of: HarmonyTransactionsMeasureable!
    get: HarmonyTransactionsMeasureable
  ): String

  """
  The number of transactions made by the sender prior to this one
  """
  nonce: BigInt

  """
  Address of the receiver
  """
  receiver(receiver: HashSelector): String

  """
  Address of the sender
  """
  sender(sender: HashSelector): String

  """
  ShardID
  """
  shardId: BigInt

  """
  Status
  """
  status(status: Boolean): Boolean

  """
  Successful of not
  """
  success(success: Boolean): Boolean

  """
  The time this transaction was created
  """
  time: DateTime

  """
  ToShardID
  """
  toShardId: BigInt

  """
  Integer of the transactions index position in the block. null when its pending.
  """
  transactionHash(transactionHash: HashSelector): String

  """
  Index of the transaction
  """
  transactionIndex(transactionIndex: HashSelector): Int

  """
  Value transferred in ATTO
  """
  value: String
}

input HarmonyTransactionsFilter {
  date: DateSelector
  time: DateTimeSelector
  shardId: BigIntegerSelector
  toShardId: BigIntegerSelector
  epoch: BigIntegerSelector
  nonce: BigIntegerSelector
  transactionHash: StringSelector
  transactionIndex: HashSelector
  ledger: BigIntIdSelector
  creates: StringSelector
  sender: HashSelector
  receiver: HashSelector
  success: Boolean
  status: Boolean
}

enum HarmonyTransactionsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Transaction Hash
  """
  transactionHash

  """
  Transaction Index
  """
  transactionIndex

  """
  Gas price provided by the sender
  """
  gas_price

  """
  Validator Address
  """
  sender

  """
  Deligator Address
  """
  receiver

  """
  Value transferred in ATTO
  """
  value

  """
  Gas price provided by the sender
  """
  gasPrice

  """
  Gas value provided by the sender
  """
  gasValue

  """
  Gas provided by the sender
  """
  gas

  """
  Shard ID
  """
  shardId

  """
  To Shard ID
  """
  toShardId

  """
  Status
  """
  status

  """
  Success
  """
  success
}

enum HarmonyTransactionsUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique block
  """
  ledger

  """
  Unique sender
  """
  sender

  """
  Unique receiver
  """
  receiver
}

"""
Transfers in Harmony blockchain
"""
type HarmonyTransfers {
  any(of: HarmonyTransfersMeasureable!): String

  """
  Hash of the block
  """
  blockHash(blockHash: HashSelector): String
  count(uniq: HarmonyTransfersUniq): Int
  countBigInt(uniq: HarmonyTransfersUniq): BigInt

  """
  Currency of transfer
  """
  currency(currency: CurrencySelector): Currency

  """
  Data
  """
  data: String

  """
  The date this transaction was created
  """
  date: Date

  """
  Entity
  """
  entityId: Int

  """
  Epoch
  """
  epoch: BigInt
  expression(get: String!): DecimalNumber

  """
  External
  """
  external(external: Boolean): Boolean

  """
  Gas provided by the sender
  """
  gas: BigInt

  """
  Gas price provided by the sender
  """
  gasPrice: String
  gasValue(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    ledger: BlockSelector
    blockHash: HashSelector
    transactionHash: HashSelector
    transactionIndex: IntegerSelector
    sender: HashSelector
    transferFrom: AddressSelector
    transferTo: AddressSelector
    status: Boolean
    success: Boolean
    currency: CurrencySelector
    entityId: IntIdSelector
  ): Float

  """
  Hash of the block where this transaction was in
  """
  ledger(ledger: BlockSelector): BigInt
  maximum(
    of: HarmonyTransfersMeasureable!
    get: HarmonyTransfersMeasureable
  ): String
  minimum(
    of: HarmonyTransfersMeasureable!
    get: HarmonyTransfersMeasureable
  ): String

  """
  The number of transactions made by the sender prior to this one
  """
  nonce: BigInt

  """
  ShardID
  """
  shardId: BigInt

  """
  Staking Tx Type
  """
  stakingTxType: String

  """
  Status
  """
  status(status: Boolean): Boolean

  """
  Successful of not
  """
  success(success: Boolean): Boolean

  """
  The time this transaction was created
  """
  time: DateTime

  """
  TO Shard ID
  """
  toShardId: BigInt

  """
  Integer of the transactions index position in the block. null when its pending.
  """
  transactionHash(transactionHash: HashSelector): String

  """
  Index of the transaction
  """
  transactionIndex(transactionIndex: HashSelector): Int

  """
  Address of the payer
  """
  transferFrom(transferFrom: HashSelector): Address

  """
  Address of the receiver
  """
  transferTo(transferTo: HashSelector): Address

  """
  Address of transaction sender
  """
  txSender: String

  """
  Address of transaction receiver
  """
  txTo: String

  """
  Value transferred in ATTO
  """
  value: String
}

input HarmonyTransfersFilter {
  date: DateSelector
  time: DateTimeSelector
  ledger: BlockSelector
  blockHash: HashSelector
  transactionHash: HashSelector
  transactionIndex: IntegerSelector
  sender: HashSelector
  transferFrom: AddressSelector
  transferTo: AddressSelector
  status: Boolean
  success: Boolean
  currency: CurrencySelector
  entityId: IntIdSelector
}

enum HarmonyTransfersMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  ledger

  """
  Block Hash
  """
  block_hash

  """
  Transaction Hash
  """
  transaction_hash

  """
  Gas price provided by the sender
  """
  gas_price

  """
  Validator Address
  """
  sender

  """
  Value transferred in ATTO
  """
  value

  """
  Gas value provided by the sender
  """
  gas_value

  """
  Gas provided by the sender
  """
  gas

  """
  Staking Tx Type
  """
  staking_tx_type

  """
  Currency symbol
  """
  currency_symbol

  """
  Token address
  """
  currency_address

  """
  Token ID
  """
  token_id

  """
  Token type
  """
  token_type

  """
  Token From
  """
  transfer_from

  """
  Token To
  """
  transfer_to

  """
  Tx Sender
  """
  tx_sender

  """
  Tx To
  """
  tx_to

  """
  Tx To
  """
  entity_id
}

enum HarmonyTransfersUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique block
  """
  ledger

  """
  Unique sender
  """
  sender

  """
  Unique transfer from
  """
  transfer_from

  """
  Unique transfer to
  """
  transfer_to
}

"""
Select by hash
"""
input HashSelector {
  """
  Hash is
  """
  is: String

  """
  Hash not
  """
  not: String

  """
  Hash in the list
  """
  in: [String!]

  """
  Hash not in the list
  """
  notIn: [String!]
}

"""
Hedera Chain
"""
type Hedera {
  """
  Basic information about address
  """
  address(address: [AddressSelectorIn!]!): [HederaAddressInfoWithBalance!]!

  """
  Blockchain Arguments
  """
  arguments(
    date: DateSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    smartContractEntity: StringSelector
    transactionHash: HashSelector
    result: HashSelector
    success: Boolean
    any: [HederaArgumentFilter!]
    options: QueryOptions
  ): [HederaArgument!]

  """
  Blockhain Calls
  """
  calls(
    date: DateSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    smartContractEntity: StringSelector
    transactionHash: HashSelector
    result: HashSelector
    callInput: HashSelector
    callResult: HashSelector
    success: Boolean
    any: [HederaCallFilter!]
    options: QueryOptions
  ): [HederaCall!]

  """
  Money flow using Coinpath technology
  """
  coinpath(
    sender: AddressSelector
    receiver: AddressSelector
    initialAddress: AddressSelector
    initialDate: DateSelector
    initialTime: DateTimeSelector
    date: DateSelector
    time: DateTimeSelector
    depth: IntegerLimitedSelector
    options: CoinpathOptions
  ): [HederaCoinpath!]

  """
  Blockhain Inputs
  """
  inputs(
    date: DateSelector
    transferEntity: StringSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    transactionHash: HashSelector
    result: HashSelector
    entityType: EntityTypeSelector
    success: Boolean
    amount: [AmountSelector!]
    any: [HederaInputFilter!]
    options: QueryOptions
  ): [HederaInput!]

  """
  Blockhain Messages
  """
  messages(
    date: DateSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    transactionHash: HashSelector
    transactionRunningHash: HashSelector
    result: HashSelector
    entityType: EntityTypeSelector
    success: Boolean
    any: [HederaMessageFilter!]
    options: QueryOptions
  ): [HederaMessage!]

  """
  Blockchain Outputs
  """
  outputs(
    date: DateSelector
    transferEntity: StringSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    transactionHash: HashSelector
    result: HashSelector
    entityType: EntityTypeSelector
    success: Boolean
    any: [HederaOutputFilter!]
    options: QueryOptions
  ): [HederaOutput!]

  """
  Blockchain Transactions
  """
  transactions(
    date: DateSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    transactionHash: HashSelector
    result: HashSelector
    entityType: EntityTypeSelector
    success: Boolean
    any: [HederaTransactionFilter!]
    options: QueryOptions
  ): [HederaTransaction!]
}

"""
Address detailed information for Hedera network
"""
type HederaAddressInfoWithBalance {
  """
  Address
  """
  address: String

  """
  Annotations ( tags ), if exists
  """
  annotation: String

  """
  Native currency balance
  """
  balance(in: BaseCurrencyEnum): Float

  """
  Token balances
  """
  tokenBalances: [HederaBalance!]
}

"""
Arguments in Hedera blockchain
"""
type HederaArgument {
  any(of: HederaArgumentsMeasureable!): String

  """
  Argument type
  """
  argtype: String

  """
  Argument
  """
  argument: String
  chargedTxFee: BigInt
  consensusTimestamp: Timestamp
  count(uniq: HederaArgumentsUniq): Int
  countBigInt(uniq: HederaArgumentsUniq): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Currency of transfer
  """
  feeCurrency: Currency
  initialBalance(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    smartContractEntity: StringSelector
    transactionHash: HashSelector
    result: HashSelector
    success: Boolean
  ): Float
  maxFee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    smartContractEntity: StringSelector
    transactionHash: HashSelector
    result: HashSelector
    success: Boolean
  ): Float
  maximum(
    of: HederaArgumentsMeasureable!
    get: HederaArgumentsMeasureable
  ): String
  memo: String
  minimum(
    of: HederaArgumentsMeasureable!
    get: HederaArgumentsMeasureable
  ): String

  """
  Used to reference a specific
        account of the node the transaction is being sent to
  """
  nodeAccount: Account

  """
  Used to
        reference a specific account in transactions
  """
  payerAccount: Account

  """
  Transaction result
  """
  result(result: HashSelector): TransactionResult

  """
  Smart contract
  """
  smartContractEntity: Account

  """
  Success
  """
  success(success: Boolean): Boolean
  transactionBytes: String
  transactionFee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    smartContractEntity: StringSelector
    transactionHash: HashSelector
    result: HashSelector
    success: Boolean
  ): Float

  """
  Transaction hash where transfer happened
  """
  transactionHash(transactionHash: HashSelector): String
  transactionValidDurationInSec: Int
  validStart(time: DateTimeSelector, nanoseconds: BigInt): Timestamp

  """
  Value
  """
  value: String
}

input HederaArgumentFilter {
  date: DateSelector
  nodeAccount: StringSelector
  payerAccount: StringSelector
  smartContractEntity: StringSelector
  transactionHash: HashSelector
  result: HashSelector
  success: Boolean
}

enum HederaArgumentsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Valid start
  """
  valid_start

  """
  Valid duration
  """
  valid_duration

  """
  Transaction Hash
  """
  transaction_hash

  """
  Max Fee
  """
  max_fee

  """
  Charged Fee
  """
  transaction_fee
}

enum HederaArgumentsUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique consensus time
  """
  consensus_times

  """
  Unique payer account
  """
  payer_account

  """
  Unique node account
  """
  node_account

  """
  Unique node account
  """
  smart_contract_entity

  """
  Unique initial balance
  """
  initial_balance
}

"""
Token Balance
"""
type HederaBalance {
  """
  Staking Balance
  """
  balance: Float

  """
  Token ID
  """
  tokenId: String
}

"""
Calls in Hedera blockchain
"""
type HederaCall {
  any(of: HederaCallsMeasureable!): String

  """
  Call input
  """
  callInput(callInput: HashSelector): String

  """
  Call input
  """
  callResult(callResult: HashSelector): String
  chargedTxFee: BigInt
  consensusTimestamp: Timestamp
  count(uniq: HederaCallsUniq): Int
  countBigInt(uniq: HederaCallsUniq): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Currency of transfer
  """
  feeCurrency: Currency
  gas(
    calculate: AmountAggregateFunction
    date: DateSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    smartContractEntity: StringSelector
    transactionHash: HashSelector
    result: HashSelector
    callInput: HashSelector
    callResult: HashSelector
    success: Boolean
  ): Int
  initialBalance(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    smartContractEntity: StringSelector
    transactionHash: HashSelector
    result: HashSelector
    success: Boolean
  ): Float
  maxFee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    smartContractEntity: StringSelector
    transactionHash: HashSelector
    result: HashSelector
    success: Boolean
  ): Float
  maximum(of: HederaCallsMeasureable!, get: HederaCallsMeasureable): String
  memo: String
  minimum(of: HederaCallsMeasureable!, get: HederaCallsMeasureable): String

  """
  Used to reference a specific
        account of the node the transaction is being sent to
  """
  nodeAccount: Account

  """
  Used to
        reference a specific account in transactions
  """
  payerAccount: Account

  """
  Transaction result
  """
  result(result: HashSelector): TransactionResult

  """
  Smart contract
  """
  smartContractEntity: Account

  """
  Success
  """
  success(success: Boolean): Boolean
  transactionBytes: String
  transactionFee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    smartContractEntity: StringSelector
    transactionHash: HashSelector
    result: HashSelector
    success: Boolean
  ): Float

  """
  Transaction hash where transfer happened
  """
  transactionHash(transactionHash: HashSelector): String
  transactionValidDurationInSec: Int
  validStart(time: DateTimeSelector, nanoseconds: BigInt): Timestamp
}

input HederaCallFilter {
  date: DateSelector
  nodeAccount: StringSelector
  payerAccount: StringSelector
  smartContractEntity: StringSelector
  transactionHash: HashSelector
  result: HashSelector
  callInput: HashSelector
  callResult: HashSelector
  success: Boolean
}

enum HederaCallsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Valid start
  """
  valid_start

  """
  Valid duration
  """
  valid_duration

  """
  Transaction Hash
  """
  transaction_hash

  """
  Max Fee
  """
  max_fee

  """
  Charged Fee
  """
  transaction_fee
}

enum HederaCallsUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique consensus time
  """
  consensus_times

  """
  Unique payer account
  """
  payer_account

  """
  Unique node account
  """
  node_account

  """
  Unique node account
  """
  smart_contract_entity

  """
  Unique initial balance
  """
  initial_balance
}

"""
Coinpath
"""
type HederaCoinpath {
  """
  Summary of transfered value
  """
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """
  Block where transaction is included
  """
  block: Block

  """
  Count of transfers
  """
  count: Int

  """
  Count of transfers
  """
  countBigInt: BigInt

  """
  1-based hop depth of the graph
  """
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """
  Receiver address
  """
  receiver: Address

  """
  Sender address
  """
  sender: Address

  """
  Attributes of transaction included in Coinpath result
  """
  transactions: [CoinpathEntry!]
}

"""
Currency selector in Hedera blockchain.
"""
input HederaCurrencySelector {
  """
  Currency is
  """
  is: String

  """
  Currency not
  """
  not: String

  """
  Currency in the list
  """
  in: [String!]

  """
  Currency not in the list
  """
  notIn: [String!]
}

"""
Inputs in Hedera blockchain
"""
type HederaInput {
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    transferEntity: StringSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    transactionHash: HashSelector
    result: HashSelector
    entityType: EntityTypeSelector
    success: Boolean
    amount: [AmountSelector!]
  ): Float
  any(of: HederaInputMeasureable!): String
  consensusTimestamp: Timestamp
  count(uniq: HederaInputsUniq): Int
  countBigInt(uniq: HederaInputsUniq): BigInt

  """
  Currency of transfer
  """
  currency(currency: HederaCurrencySelector): Currency

  """
  Calendar date
  """
  date: Date

  """
  Entity
  """
  entity(entityType: EntityTypeSelector): Entity
  expression(get: String!): DecimalNumber

  """
  Currency of transfer
  """
  feeCurrency: Currency
  initialBalance(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    transferEntity: StringSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    transactionHash: HashSelector
    result: HashSelector
    entityType: EntityTypeSelector
    success: Boolean
    amount: [AmountSelector!]
  ): Float
  maxFee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    transferEntity: StringSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    transactionHash: HashSelector
    result: HashSelector
    entityType: EntityTypeSelector
    success: Boolean
    amount: [AmountSelector!]
  ): Float
  maximum(of: HederaInputMeasureable!, get: HederaInputMeasureable): String
  memo: String
  minimum(of: HederaInputMeasureable!, get: HederaInputMeasureable): String

  """
  Used to reference a specific
        account of the node the transaction is being sent to
  """
  nodeAccount: Account

  """
  Used to
        reference a specific account in transactions
  """
  payerAccount: Account

  """
  Transaction result
  """
  result(result: HashSelector): TransactionResult

  """
  Success
  """
  success(success: Boolean): Boolean

  """
  Calendar time
  """
  time: DateTime
  transactionFee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    transferEntity: StringSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    transactionHash: HashSelector
    result: HashSelector
    entityType: EntityTypeSelector
    success: Boolean
    amount: [AmountSelector!]
  ): Float

  """
  Transaction hash where transfer happened
  """
  transactionHash(transactionHash: HashSelector): String
  transactionValidDurationInSec: Int

  """
  Transfer Account
  """
  transferEntity: Account
  validStart(time: DateTimeSelector, nanoseconds: BigInt): Timestamp
}

input HederaInputFilter {
  date: DateSelector
  transferEntity: StringSelector
  nodeAccount: StringSelector
  payerAccount: StringSelector
  transactionHash: HashSelector
  result: HashSelector
  entityType: EntityTypeSelector
  success: Boolean
  amount: [AmountSelector!]
}

enum HederaInputMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Valid start
  """
  valid_start

  """
  Valid duration
  """
  valid_duration

  """
  Transaction Hash
  """
  transaction_hash

  """
  Max Fee
  """
  max_fee

  """
  Charged Fee
  """
  transaction_fee

  """
  Amount
  """
  amount

  """
  Currency Symbol
  """
  currency_symbol

  """
  Currency Address
  """
  currency_address

  """
  Token Type
  """
  token_type

  """
  Token ID
  """
  token_id
}

enum HederaInputsUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique consensus time
  """
  consensus_times

  """
  Unique payer account
  """
  payer_account

  """
  Unique node account
  """
  node_account

  """
  Unique entity id
  """
  entity_id

  """
  Unique entity type
  """
  entity_type

  """
  Unique initial balance
  """
  initial_balance
}

"""
Messages in Hedera blockchain
"""
type HederaMessage {
  any(of: HederaMessageMeasureable!): String
  consensusTimestamp: Timestamp
  count(uniq: HederaMessagesUniq): Int
  countBigInt(uniq: HederaMessagesUniq): BigInt

  """
  Calendar date
  """
  date: Date

  """
  Entity
  """
  entity(entityType: EntityTypeSelector): Entity
  expression(get: String!): DecimalNumber

  """
  Currency of transfer
  """
  feeCurrency: Currency
  initialBalance(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    transactionHash: HashSelector
    transactionRunningHash: HashSelector
    result: HashSelector
    entityType: EntityTypeSelector
    success: Boolean
  ): Float
  maxFee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    transactionHash: HashSelector
    transactionRunningHash: HashSelector
    result: HashSelector
    entityType: EntityTypeSelector
    success: Boolean
  ): Float
  maximum(of: HederaMessageMeasureable!, get: HederaMessageMeasureable): String
  memo: String
  message: String
  minimum(of: HederaMessageMeasureable!, get: HederaMessageMeasureable): String

  """
  Used to reference a specific
        account of the node the transaction is being sent to
  """
  nodeAccount: Account

  """
  Used to
        reference a specific account in transactions
  """
  payerAccount: Account

  """
  Transaction result
  """
  result(result: HashSelector): TransactionResult

  """
  Success
  """
  success(success: Boolean): Boolean

  """
  Calendar date time
  """
  time: DateTime

  """
  Transaction running hash
  """
  topicRunningHash(topicRunningHash: StringSelector): String

  """
  Transaction running hash
  """
  topicSequenceNumber(topicSequenceNumber: HashSelector): String
  transactionFee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    transactionHash: HashSelector
    transactionRunningHash: HashSelector
    result: HashSelector
    entityType: EntityTypeSelector
    success: Boolean
  ): Float

  """
  Transaction hash where transfer happened
  """
  transactionHash(transactionHash: HashSelector): String
  transactionValidDurationInSec: Int
  validStart(time: DateTimeSelector, nanoseconds: BigInt): Timestamp
}

input HederaMessageFilter {
  date: DateSelector
  nodeAccount: StringSelector
  payerAccount: StringSelector
  transactionHash: HashSelector
  transactionRunningHash: HashSelector
  result: HashSelector
  entityType: EntityTypeSelector
  success: Boolean
}

enum HederaMessageMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Valid start
  """
  valid_start

  """
  Valid duration
  """
  valid_duration

  """
  Transaction Hash
  """
  transaction_hash

  """
  Max Fee
  """
  max_fee

  """
  Charged Fee
  """
  transaction_fee
}

enum HederaMessagesUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique consensus time
  """
  consensus_times

  """
  Unique payer account
  """
  payer_account

  """
  Unique node account
  """
  node_account

  """
  Unique entity id
  """
  entity_id

  """
  Unique entity type
  """
  entity_type

  """
  Unique initial balance
  """
  initial_balance
}

enum HederaNetwork {
  """
  The Hedera mainnet
  """
  hedera

  """
  The Hedera testnets
  """
  hedera_testnets
}

"""
Outputs in Hedera blockchain
"""
type HederaOutput {
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    transferEntity: StringSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    transactionHash: HashSelector
    result: HashSelector
    entityType: EntityTypeSelector
    success: Boolean
    amount: [AmountSelector!]
  ): Float
  any(of: HederaOutputMeasureable!): String
  consensusTimestamp: Timestamp
  count(uniq: HederaOutputUniq): Int
  countBigInt(uniq: HederaOutputUniq): BigInt

  """
  Currency of transfer
  """
  currency(currency: HederaCurrencySelector): Currency

  """
  Calendar date
  """
  date: Date

  """
  Entity
  """
  entity(entityType: EntityTypeSelector): Entity
  expression(get: String!): DecimalNumber

  """
  Currency of transfer
  """
  feeCurrency: Currency
  initialBalance(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    transferEntity: StringSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    transactionHash: HashSelector
    result: HashSelector
    entityType: EntityTypeSelector
    success: Boolean
  ): Float
  maxFee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    transferEntity: StringSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    transactionHash: HashSelector
    result: HashSelector
    entityType: EntityTypeSelector
    success: Boolean
  ): Float
  maximum(of: HederaOutputMeasureable!, get: HederaOutputMeasureable): String
  memo: String
  minimum(of: HederaOutputMeasureable!, get: HederaOutputMeasureable): String

  """
  Used to reference a specific
        account of the node the transaction is being sent to
  """
  nodeAccount: Account

  """
  Used to
        reference a specific account in transactions
  """
  payerAccount: Account

  """
  Transaction result
  """
  result(result: HashSelector): TransactionResult

  """
  Success
  """
  success(success: Boolean): Boolean

  """
  Calendar time
  """
  time: DateTime
  transactionFee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    transferEntity: StringSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    transactionHash: HashSelector
    result: HashSelector
    entityType: EntityTypeSelector
    success: Boolean
  ): Float

  """
  Transaction hash where transfer happened
  """
  transactionHash(transactionHash: HashSelector): String
  transactionValidDurationInSec: Int

  """
  Transfer Account
  """
  transferEntity: Account
  validStart(time: DateTimeSelector, nanoseconds: BigInt): Timestamp
}

input HederaOutputFilter {
  date: DateSelector
  transferEntity: StringSelector
  nodeAccount: StringSelector
  payerAccount: StringSelector
  transactionHash: HashSelector
  result: HashSelector
  entityType: EntityTypeSelector
  success: Boolean
}

enum HederaOutputMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Valid start
  """
  valid_start

  """
  Valid duration
  """
  valid_duration

  """
  Transaction Hash
  """
  transaction_hash

  """
  Max Fee
  """
  max_fee

  """
  Charged Fee
  """
  transaction_fee

  """
  Amount
  """
  amount

  """
  Currency Symbol
  """
  currency_symbol

  """
  Currency Address
  """
  currency_address

  """
  Token Type
  """
  token_type

  """
  Token ID
  """
  token_id
}

enum HederaOutputUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique consensus time
  """
  consensus_times

  """
  Unique Transfer entity
  """
  transfer_entity

  """
  Unique payer account
  """
  payer_account

  """
  Unique node account
  """
  node_account

  """
  Unique entity id
  """
  entity_id

  """
  Unique entity type
  """
  entity_type

  """
  Unique initial balance
  """
  initial_balance
}

"""
Transactions in Hedera blockchain
"""
type HederaTransaction {
  any(of: HederaTransactionMeasureable!): String
  consensusTimestamp: Timestamp
  count(uniq: HederaTransactionsUniq): Int
  countBigInt(uniq: HederaTransactionsUniq): BigInt

  """
  Calendar date
  """
  date: Date

  """
  Entity
  """
  entity(entityType: EntityTypeSelector): Entity
  expression(get: String!): DecimalNumber

  """
  Currency of transfer
  """
  feeCurrency: Currency
  initialBalance(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    transactionHash: HashSelector
    result: HashSelector
    entityType: EntityTypeSelector
    success: Boolean
  ): Float
  maxFee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    transactionHash: HashSelector
    result: HashSelector
    entityType: EntityTypeSelector
    success: Boolean
  ): Float
  maximum(
    of: HederaTransactionMeasureable!
    get: HederaTransactionMeasureable
  ): String
  memo: String
  minimum(
    of: HederaTransactionMeasureable!
    get: HederaTransactionMeasureable
  ): String

  """
  Used to reference a specific
        account of the node the transaction is being sent to
  """
  nodeAccount: Account

  """
  Used to
        reference a specific account in transactions
  """
  payerAccount: Account

  """
  Transaction result
  """
  result(result: HashSelector): TransactionResult

  """
  Success
  """
  success(success: Boolean): Boolean

  """
  Calendar time
  """
  time: DateTime
  transactionBytes: String
  transactionFee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    transactionHash: HashSelector
    result: HashSelector
    entityType: EntityTypeSelector
    success: Boolean
  ): Float

  """
  Transaction hash where transfer happened
  """
  transactionHash(transactionHash: HashSelector): String

  """
  Transaction Type
  """
  transactionType: String
  transactionValidDurationInSec: Int
  validStart(time: DateTimeSelector, nanoseconds: BigInt): Timestamp
}

input HederaTransactionFilter {
  date: DateSelector
  nodeAccount: StringSelector
  payerAccount: StringSelector
  transactionHash: HashSelector
  result: HashSelector
  entityType: EntityTypeSelector
  success: Boolean
}

enum HederaTransactionMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Valid start
  """
  valid_start

  """
  Valid duration
  """
  valid_duration

  """
  Transaction Hash
  """
  transaction_hash

  """
  Max Fee
  """
  max_fee

  """
  Charged Fee
  """
  transaction_fee
}

enum HederaTransactionsUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique consensus time
  """
  consensus_times

  """
  Unique transaction type
  """
  transaction_type

  """
  Unique payer account
  """
  payer_account

  """
  Unique node account
  """
  node_account

  """
  Unique entity id
  """
  entity_id

  """
  Unique entity type
  """
  entity_type

  """
  Unique initial balance
  """
  initial_balance
}

"""
Input Script Type of UTXO transaction input
"""
type InputScript {
  """
  Script annotation
  """
  annotation: String

  """
  Long script pattern
  """
  pattern: String!

  """
  Short script pattern
  """
  shortPattern: String!

  """
  Simple script pattern
  """
  simplePattern: String!

  """
  Script type
  """
  type: BitcoinInputScriptType
}

"""
Solana Instruction
"""
type Instruction {
  action: Action
  callPath: String
  external: Boolean
  program: Program
}

"""
Solana Instruction
"""
type InstructionWithExternals {
  action: Action
  callPath: String
  external: Boolean
  externalAction: Action
  externalProgram: Program
  program: Program
}

"""
Select limited upper number
"""
input IntegerLimitedSelector {
  """
  is
  """
  is: Int

  """
  in the list
  """
  in: [Int!]

  """
  less than
  """
  lt: Int

  """
  less or equal than
  """
  lteq: Int

  """
  in range
  """
  between: [Int!]
}

"""
Select by number
"""
input IntegerSelector {
  """
  is
  """
  is: Int

  """
  not
  """
  not: Int

  """
  in the list
  """
  in: [Int!]

  """
  not in the list
  """
  notIn: [Int!]

  """
  greater than
  """
  gt: Int

  """
  less than
  """
  lt: Int

  """
  less or equal than
  """
  lteq: Int

  """
  greater or equal than
  """
  gteq: Int

  """
  in range
  """
  between: [Int!]
}

"""
Select by ID
"""
input IntIdSelector {
  """
  ID is
  """
  is: Int

  """
  ID not
  """
  not: Int

  """
  ID in the list
  """
  in: [Int!]

  """
  ID not in the list
  """
  notIn: [Int!]

  """
  ID greater than
  """
  gt: Int

  """
  ID less than
  """
  lt: Int

  """
  ID less or equal than
  """
  lteq: Int

  """
  ID greater or equal than
  """
  gteq: Int

  """
  ID in range
  """
  between: [Int!]
}

"""
An ISO 8601-encoded date
"""
scalar ISO8601Date

"""
An ISO 8601-encoded datetime
"""
scalar ISO8601DateTime

"""
Libra
"""
type Libra {
  """
  Libra Network Blocks
  """
  blocks(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    version: IntegerSelector
    proposer: [AddressSelector!]
    metadata: StringSelector
    any: [LibraBlockFilter!]
    options: QueryOptions
  ): [LibraBlock!]

  """
  Money flow using Coinpath technology
  """
  coinpath(
    sender: AddressSelector
    receiver: AddressSelector
    currency: [LibraCurrencySelector!]
    initialAddress: AddressSelector
    initialDate: DateSelector
    initialTime: DateTimeSelector
    date: DateSelector
    time: DateTimeSelector
    depth: IntegerLimitedSelector
    options: CoinpathOptions
  ): [LibraCoinpath!]

  """
  Libra Network Currency Minting
  """
  mints(
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    version: IntegerSelector
    minter: AddressSelector
    currency: [LibraCurrencySelector!]
    amount: [AmountSelector!]
    any: [LibraMintFilter!]
    options: QueryOptions
  ): [LibraMints!]

  """
  Libra Network Transactions
  """
  transactions(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    version: IntegerSelector
    txSender: AddressSelector
    scriptType: ScriptTypeSelectorSelector
    success: Boolean
    gasCurrency: [LibraCurrencySelector!]
    scriptHash: StringSelector
    any: [LibraTransactionFilter!]
    options: QueryOptions
  ): [LibraTransactions!]

  """
  Libra Network Currency Transfers
  """
  transfers(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    version: IntegerSelector
    txSender: AddressSelector
    sender: AddressSelector
    receiver: AddressSelector
    currency: [LibraCurrencySelector!]
    gasCurrency: [LibraCurrencySelector!]
    amount: [AmountSelector!]
    scriptType: ScriptTypeSelectorSelector
    scriptHash: StringSelector
    any: [LibraTransferFilter!]
    options: QueryOptions
  ): [LibraTransfers!]
}

"""
Block
"""
type LibraBlock {
  any(of: LibraBlocksMeasureable!): String
  count(
    uniq: LibraBlockUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    version: IntegerSelector
    proposer: [AddressSelector!]
    metadata: StringSelector
  ): Int
  countBigInt(
    uniq: LibraBlockUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    version: IntegerSelector
    proposer: [AddressSelector!]
    metadata: StringSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber
  gasUsed(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    version: IntegerSelector
    proposer: [AddressSelector!]
    metadata: StringSelector
  ): Float

  """
  Block round in blockchain
  """
  height(height: BlockSelector): Int!

  """
  Key
  """
  key: String
  maximum(of: LibraBlocksMeasureable!, get: LibraBlocksMeasureable): String

  """
  Metadata
  """
  metadata(metadata: StringSelector): String
  minimum(of: LibraBlocksMeasureable!, get: LibraBlocksMeasureable): String

  """
  Proposer
  """
  proposer(proposer: AddressSelector): Address

  """
  Sequence number
  """
  sequenceNumber: Int

  """
  Status Name
  """
  statusName: String

  """
  Block timestamp
  """
  timestamp(time: DateTimeSelector): DateTime

  """
  Version of transaction for this block
  """
  version(version: IntegerSelector): Int!

  """
  Version hash of transaction for this block
  """
  versionHash: String!

  """
  VM Status
  """
  vmStatus: Int
}

input LibraBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  version: IntegerSelector
  proposer: [AddressSelector!]
  metadata: StringSelector
}

enum LibraBlocksMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block round
  """
  block

  """
  Version
  """
  version

  """
  Proposer
  """
  proposer

  """
  Gas Used
  """
  gas_used
}

enum LibraBlockUniq {
  """
  Proposer
  """
  proposer

  """
  Unique date count
  """
  dates
}

"""
Coinpath
"""
type LibraCoinpath {
  """
  Summary of transfered value
  """
  amount(in: BaseCurrencyEnum): Float
  any(of: LibraCoinpathMeasureable!): String

  """
  Block where transaction is included
  """
  block: Block

  """
  Count of transfers
  """
  count: Int

  """
  Count of transfers
  """
  countBigInt: BigInt

  """
  Currency of transfer
  """
  currency: Currency

  """
  1-based hop depth of the graph
  """
  depth: Int
  maximum(of: LibraCoinpathMeasureable!, get: LibraCoinpathMeasureable): String
  minimum(of: LibraCoinpathMeasureable!, get: LibraCoinpathMeasureable): String

  """
  Receiver address
  """
  receiver: Address

  """
  Sender address
  """
  sender: Address

  """
  Transaction of transfer happened
  """
  transaction: LibraTransactionValue
}

enum LibraCoinpathMeasureable {
  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Version
  """
  version

  """
  Sender
  """
  sender

  """
  Receiver
  """
  receiver

  """
  Depth
  """
  depth
}

"""
Currency selector in Libra blockchain.
Libra has native chain currency (LBR) and a number of others ( Coin1/Coin2 ) for Testnet.
Use name of currency for selection
"""
input LibraCurrencySelector {
  """
  Currency is
  """
  is: String

  """
  Currency not
  """
  not: String

  """
  Currency in the list
  """
  in: [String!]

  """
  Currency not in the list
  """
  notIn: [String!]
}

input LibraMintFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  version: IntegerSelector
  minter: AddressSelector
  currency: [LibraCurrencySelector!]
  amount: [AmountSelector!]
}

"""
Mints in Libra blockchain
"""
type LibraMints {
  amount(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    version: IntegerSelector
    minter: AddressSelector
    currency: [LibraCurrencySelector!]
    amount: [AmountSelector!]
  ): Float
  any(of: LibraMintsMeasureable!): String

  """
  Block where transfer transaction is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(
    uniq: LibraMintsUniq
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    version: IntegerSelector
    minter: AddressSelector
    currency: [LibraCurrencySelector!]
    amount: [AmountSelector!]
  ): Int
  countBigInt(
    uniq: LibraMintsUniq
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    version: IntegerSelector
    minter: AddressSelector
    currency: [LibraCurrencySelector!]
    amount: [AmountSelector!]
  ): BigInt

  """
  Currency of transfer
  """
  currency(currency: [LibraCurrencySelector!]): Currency

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber
  maximum(of: LibraMintsMeasureable!, get: LibraMintsMeasureable): String
  minimum(of: LibraMintsMeasureable!, get: LibraMintsMeasureable): String

  """
  Minter
  """
  minter(sender: AddressSelector): Address

  """
  Sequence number
  """
  sequenceNumber: Int

  """
  Status Name
  """
  statusName: String

  """
  Success
  """
  success(success: Boolean): Boolean

  """
  Mint timestamp
  """
  timestamp(time: DateTimeSelector): DateTime

  """
  Version of blockchain for this transaction
  """
  version(version: IntegerSelector): Int!

  """
  Version hash of blockchain for this transaction
  """
  versionHash: String!

  """
  VM Status
  """
  vmStatus: Int
}

enum LibraMintsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Version
  """
  version

  """
  Mint version hash
  """
  version_hash

  """
  Amount
  """
  amount

  """
  Minter
  """
  minter

  """
  Currency symbol
  """
  currency_symbol
}

enum LibraMintsUniq {
  """
  Unique blocks
  """
  blocks

  """
  Unique versions
  """
  versions

  """
  Unique date count
  """
  dates

  """
  Unique minters
  """
  minters

  """
  Unique currencies
  """
  currencies
}

input LibraTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  version: IntegerSelector
  txSender: AddressSelector
  scriptType: ScriptTypeSelectorSelector
  success: Boolean
  gasCurrency: [LibraCurrencySelector!]
  scriptHash: StringSelector
}

"""
Transactions in Libra blockchain
"""
type LibraTransactions {
  any(of: LibraTransactionsMeasureable!): String

  """
  Block where transfer transaction is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(
    uniq: LibraTransactionsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    version: IntegerSelector
    txSender: AddressSelector
    scriptType: ScriptTypeSelectorSelector
    success: Boolean
    gasCurrency: [LibraCurrencySelector!]
    scriptHash: StringSelector
  ): Int
  countBigInt(
    uniq: LibraTransactionsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    version: IntegerSelector
    txSender: AddressSelector
    scriptType: ScriptTypeSelectorSelector
    success: Boolean
    gasCurrency: [LibraCurrencySelector!]
    scriptHash: StringSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date

  """
  Expiration Time
  """
  expirationTime: DateTime
  expression(get: String!): DecimalNumber
  gas(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    version: IntegerSelector
    txSender: AddressSelector
    scriptType: ScriptTypeSelectorSelector
    success: Boolean
    gasCurrency: [LibraCurrencySelector!]
    scriptHash: StringSelector
  ): Int

  """
  Currency of gas
  """
  gasCurrency(gasCurrency: [LibraCurrencySelector!]): Currency

  """
  Gas unit price
  """
  gasPrice(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    version: IntegerSelector
    txSender: AddressSelector
    scriptType: ScriptTypeSelectorSelector
    success: Boolean
    gasCurrency: [LibraCurrencySelector!]
    scriptHash: StringSelector
  ): Float!
  gasValue(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    version: IntegerSelector
    txSender: AddressSelector
    scriptType: ScriptTypeSelectorSelector
    success: Boolean
    gasCurrency: [LibraCurrencySelector!]
    scriptHash: StringSelector
  ): Float

  """
  Max gas amount
  """
  maxGasAmount: Int
  maximum(
    of: LibraTransactionsMeasureable!
    get: LibraTransactionsMeasureable
  ): String
  minimum(
    of: LibraTransactionsMeasureable!
    get: LibraTransactionsMeasureable
  ): String

  """
  Public key
  """
  publicKey: String

  """
  Script Hash
  """
  scriptHash(scriptHash: StringSelector): String

  """
  Script Type
  """
  scriptType: ScriptTypeSelectorSelector

  """
  Transaction sender
  """
  sender(txSender: AddressSelector): Address

  """
  Sequence number
  """
  sequenceNumber: Int

  """
  Signature
  """
  signature: String

  """
  Signature scheme
  """
  signatureScheme: String

  """
  Status Name
  """
  statusName: String

  """
  Success
  """
  success(success: Boolean): Boolean

  """
  Transaction timestamp
  """
  timestamp(time: DateTimeSelector): DateTime

  """
  Version of blockchain for this transaction
  """
  version(version: IntegerSelector): Int!

  """
  Version hash of blockchain for this transaction
  """
  versionHash: String!

  """
  VM Status
  """
  vmStatus: Int
}

enum LibraTransactionsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Version
  """
  version

  """
  Transaction Sender
  """
  tx_sender

  """
  Script Hash
  """
  script_hash

  """
  Gas price
  """
  gas_price

  """
  Gas used
  """
  gas
}

enum LibraTransactionsUniq {
  """
  Unique blocks
  """
  blocks

  """
  Unique versions
  """
  versions

  """
  Unique date count
  """
  dates

  """
  Unique transaction senders
  """
  senders

  """
  Unique transaction script hashes
  """
  scripts
}

"""
Blockchain transaction with value
"""
type LibraTransactionValue {
  """
  Transaction value
  """
  value: Float!

  """
  Transaction version
  """
  version: Int!
}

input LibraTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  version: IntegerSelector
  txSender: AddressSelector
  sender: AddressSelector
  receiver: AddressSelector
  currency: [LibraCurrencySelector!]
  gasCurrency: [LibraCurrencySelector!]
  amount: [AmountSelector!]
  scriptType: ScriptTypeSelectorSelector
  scriptHash: StringSelector
}

"""
Transfers in Libra blockchain
"""
type LibraTransfers {
  amount(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    version: IntegerSelector
    txSender: AddressSelector
    sender: AddressSelector
    receiver: AddressSelector
    currency: [LibraCurrencySelector!]
    gasCurrency: [LibraCurrencySelector!]
    amount: [AmountSelector!]
    scriptType: ScriptTypeSelectorSelector
    scriptHash: StringSelector
  ): Float
  any(of: LibraTransfersMeasureable!): String

  """
  Block where transfer transaction is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(
    uniq: TransfersUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    version: IntegerSelector
    txSender: AddressSelector
    sender: AddressSelector
    receiver: AddressSelector
    currency: [LibraCurrencySelector!]
    gasCurrency: [LibraCurrencySelector!]
    amount: [AmountSelector!]
    scriptType: ScriptTypeSelectorSelector
    scriptHash: StringSelector
  ): Int
  countBigInt(
    uniq: TransfersUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    version: IntegerSelector
    txSender: AddressSelector
    sender: AddressSelector
    receiver: AddressSelector
    currency: [LibraCurrencySelector!]
    gasCurrency: [LibraCurrencySelector!]
    amount: [AmountSelector!]
    scriptType: ScriptTypeSelectorSelector
    scriptHash: StringSelector
  ): BigInt

  """
  Currency of transfer
  """
  currency(currency: [LibraCurrencySelector!]): Currency

  """
  Calendar date
  """
  date: Date

  """
  Expiration Time
  """
  expirationTime: DateTime
  expression(get: String!): DecimalNumber
  gas(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    version: IntegerSelector
    txSender: AddressSelector
    sender: AddressSelector
    receiver: AddressSelector
    currency: [LibraCurrencySelector!]
    gasCurrency: [LibraCurrencySelector!]
    amount: [AmountSelector!]
    scriptType: ScriptTypeSelectorSelector
    scriptHash: StringSelector
  ): Int

  """
  Currency of gas
  """
  gasCurrency(gasCurrency: [LibraCurrencySelector!]): Currency

  """
  Gas price
  """
  gasPrice: Float!
  gasValue(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    version: IntegerSelector
    txSender: AddressSelector
    sender: AddressSelector
    receiver: AddressSelector
    currency: [LibraCurrencySelector!]
    gasCurrency: [LibraCurrencySelector!]
    amount: [AmountSelector!]
    scriptType: ScriptTypeSelectorSelector
    scriptHash: StringSelector
  ): Float

  """
  Max gas amount
  """
  maxGasAmount: Int
  maximum(
    of: LibraTransfersMeasureable!
    get: LibraTransfersMeasureable
  ): String
  minimum(
    of: LibraTransfersMeasureable!
    get: LibraTransfersMeasureable
  ): String

  """
  Public key
  """
  publicKey: String

  """
  Transfer receiver
  """
  receiver(receiver: AddressSelector): Address

  """
  Script Hash
  """
  scriptHash(scriptHash: StringSelector): String

  """
  Script Type
  """
  scriptType: ScriptTypeSelectorSelector

  """
  Transfer sender
  """
  sender(sender: AddressSelector): Address

  """
  Sequence number
  """
  sequenceNumber: Int

  """
  Signature
  """
  signature: String

  """
  Signature scheme
  """
  signatureScheme: String

  """
  Status Name
  """
  statusName: String

  """
  Success
  """
  success(success: Boolean): Boolean

  """
  Transfer timestamp
  """
  timestamp(time: DateTimeSelector): DateTime

  """
  Transaction sender
  """
  txSender(txSender: AddressSelector): Address

  """
  Version of blockchain for this transaction
  """
  version(version: IntegerSelector): Int!

  """
  Version hash of blockchain for this transaction
  """
  versionHash: String!

  """
  VM Status
  """
  vmStatus: Int
}

enum LibraTransfersMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  height

  """
  Version
  """
  version

  """
  Version hash
  """
  version_hash

  """
  Amount
  """
  amount

  """
  Transfer Sender
  """
  tx_sender

  """
  Sender
  """
  sender

  """
  Receiver
  """
  receiver

  """
  Script Hash
  """
  script_hash

  """
  Currency symbol
  """
  currency_symbol

  """
  Gas value
  """
  gas_value

  """
  Gas price
  """
  gas_price

  """
  Gas used
  """
  gas
}

"""
Limit by definition
"""
input LimitByOption {
  """
  Take limit for each combination of the field
  """
  each: String!

  """
  Limit number of results
  """
  limit: Int

  """
  Offset of results, starting from 0
  """
  offset: Int
}

"""
Solana Log
"""
type Log {
  consumed: BigInt!
  instruction: String!
  logs: String!
  result: String!
  totalGas: BigInt!
}

"""
Blockchain message
"""
type MessageHash {
  """
  Message hash hex representation
  """
  messageHash: String!
}

"""
Smart contract method
"""
type Method {
  """
  Name
  """
  name: String

  """
  Signature
  """
  signature: String

  """
  Signature Hash
  """
  signatureHash: String!
}

"""
Smart contract method. In selector you can use the name, signature or hex hash
"""
input MethodSelector {
  """
  Method signature is
  """
  is: String

  """
  Method signature not
  """
  not: String

  """
  Method signature in the list
  """
  in: [String!]

  """
  Method signature not in the list
  """
  notIn: [String!]
}

"""
Query metric object
"""
type Metric {
  """
  Metric cost
  """
  cost: Float!

  """
  Metric divider
  """
  divider: BigInt!

  """
  Metric maximum
  """
  max: BigInt!

  """
  Metric maximum unit
  """
  maxUnit: Float!

  """
  Metric minimum
  """
  min: BigInt!

  """
  Metric minimum unit
  """
  minUnit: Float!

  """
  Metric name
  """
  name: String!

  """
  Metric price
  """
  price: Float!

  """
  Metric value
  """
  value: BigInt!

  """
  Metric value unit
  """
  valueUnit: Float!
}

"""
Query metrics
"""
type Metrics {
  """
  Graphql query ID
  """
  id: String!

  """
  Metrics
  """
  list: [Metric!]!

  """
  Points
  """
  points: Float!

  """
  SQL requests count
  """
  sqlRequestsCount: Int!
}

"""
Information about miniblock
"""
type MiniblockElrond {
  """
  Miniblock hash
  """
  hash: String

  """
  Hash of the receiver block
  """
  receiverBlockHash: String

  """
  Number of the receiver shard
  """
  receiverShard: String

  """
  Miniblock type
  """
  type: String
}

"""
Name with an identifier
"""
type NameWithId {
  """
  ID
  """
  id: Int

  """
  Name
  """
  name: String
}

enum Network {
  """
  Ethereum Mainnet
  """
  ethereum

  """
  Ethereum Classic
  """
  ethclassic

  """
  Ethereum PoW
  """
  ethpow

  """
  Ethereum Classic ( no reorg from block 10904146)
  """
  ethclassic_reorg

  """
  Binance DEX
  """
  binance

  """
  Celo Alfajores Testnet
  """
  celo_alfajores

  """
  Celo Baklava Testnet
  """
  celo_baklava

  """
  DEPRECATED. Use celo_mainnet
  """
  celo_rc1

  """
  Celo Mainnet
  """
  celo_mainnet

  """
  Bitcoin ( BTC )
  """
  bitcoin

  """
  Bitcoin Cash ( BCH )
  """
  bitcash

  """
  Bitcoin SV ( BSV )
  """
  bitcoinsv

  """
  Litecoin ( LTC )
  """
  litecoin

  """
  Dash ( DASH )
  """
  dash

  """
  Dogecoin ( DOGE )
  """
  dogecoin

  """
  Cardano ( ADA )
  """
  cardano

  """
  Zcash ( ZEC )
  """
  zcash

  """
  Algorand Mainnet (ALGO)
  """
  algorand

  """
  Algorand Testnet
  """
  algorand_testnet

  """
  Algorand Betanet
  """
  algorand_betanet

  """
  Conflux Oceanus
  """
  conflux_oceanus

  """
  Conflux Tethys
  """
  conflux_tethys

  """
  Conflux Hydra
  """
  conflux_hydra

  """
  Libra Testnet
  """
  libra_testnet

  """
  Diem Testnet
  """
  diem_testnet

  """
  EOS Mainnet
  """
  eos

  """
  TRON Mainnet
  """
  tron

  """
  Binance Smart Chain Mainnet
  """
  bsc

  """
  Binance Smart Chain Testnet
  """
  bsc_testnet

  """
  Goerli Ethereum Testnet
  """
  goerli

  """
  Beacon Chain Ethereum 2.0
  """
  eth2

  """
  Medalla Ethereum 2.0 Beacon Testnet
  """
  medalla

  """
  Filecoin Mainnet
  """
  filecoin

  """
  Hedera Hashgraph
  """
  hedera

  """
  Solana Mainnet
  """
  solana

  """
  Matic (Polygon) Mainnet
  """
  matic

  """
  Velas Mainnet
  """
  velas

  """
  Velas Testnet
  """
  velas_testnet

  """
  Klaytn Mainnet
  """
  klaytn

  """
  Elrond Mainnet
  """
  elrond

  """
  Flow Mainnet
  """
  flow

  """
  Avalanche C-chain
  """
  avalanche

  """
  Fantom Mainnet
  """
  fantom

  """
  Moonbeam Mainnet
  """
  moonbeam

  """
  Cronos Mainnet
  """
  cronos

  """
  Cosmos Hub
  """
  cosmoshub

  """
  Heimdall (Matic Verification Network)
  """
  heimdall

  """
  Crypto.org Mainnet
  """
  crypto_mainnet

  """
  Crypto.org Croeseid Testnet
  """
  crypto_testnet

  """
  Terra Mainnet
  """
  terra

  """
  Stellar Ledger
  """
  stellar

  """
  Ripple XRP Ledger
  """
  ripple

  """
  Harmony Mainnet
  """
  harmony

  """
  Harmony Testnet
  """
  harmony_testnet

  """
  Tezos
  """
  tezos

  """
  Everscale
  """
  everscale
}

"""
Blockchain operation
"""
type OperationIndexed {
  """
  Operation index
  """
  index: Int!

  """
  Operation name
  """
  name: String!
}

"""
Blockchain operation
"""
type OperationIndexedWithAccount {
  """
  Operation index
  """
  index: Int!

  """
  Operation name
  """
  name: String!

  """
  Operation account
  """
  sourceAccount: Address!
}

"""
Select order by ID
"""
input OrderIdSelector {
  """
  Order ID is
  """
  is: String

  """
  Order ID not
  """
  not: String

  """
  Order ID in the list
  """
  in: [String!]

  """
  Order ID not in the list
  """
  notIn: [String!]
}

"""
Select by order side
"""
input OrderSideSelector {
  """
  Order Side is
  """
  is: BinanceOrderSide

  """
  Order Side not
  """
  not: BinanceOrderSide

  """
  Order Side in the list
  """
  in: [BinanceOrderSide!]

  """
  Order Side not in the list
  """
  notIn: [BinanceOrderSide!]
}

"""
Select by order status
"""
input OrderStatusSelector {
  """
  Order Status is
  """
  is: BinanceOrderStatus

  """
  Order Status not
  """
  not: BinanceOrderStatus

  """
  Order Status in the list
  """
  in: [BinanceOrderStatus!]

  """
  Order Status not in the list
  """
  notIn: [BinanceOrderStatus!]
}

"""
Select by order time in force
"""
input OrderTimeInForceSelector {
  """
  Order TimeInForce is
  """
  is: BinanceOrderTimeInForce

  """
  Order TimeInForce not
  """
  not: BinanceOrderTimeInForce

  """
  Order TimeInForce in the list
  """
  in: [BinanceOrderTimeInForce!]

  """
  Order TimeInForce not in the list
  """
  notIn: [BinanceOrderTimeInForce!]
}

"""
Select by order type
"""
input OrderTypeSelector {
  """
  Order Type is
  """
  is: BinanceOrderType

  """
  Order Type not
  """
  not: BinanceOrderType

  """
  Order Type in the list
  """
  in: [BinanceOrderType!]

  """
  Order Type not in the list
  """
  notIn: [BinanceOrderType!]
}

"""
Select by output index ( o based )
"""
input OutputIndexSelector {
  """
  Output index is
  """
  is: Int

  """
  Output index not
  """
  not: Int

  """
  Output index in the list
  """
  in: [Int!]

  """
  Output index not in the list
  """
  notIn: [Int!]

  """
  Output index greater than
  """
  gt: Int

  """
  Output index less than
  """
  lt: Int

  """
  Output index less or equal than
  """
  lteq: Int

  """
  Output index greater or equal than
  """
  gteq: Int

  """
  Output index in range
  """
  between: [Int!]
}

"""
Output Script Type of UTXO transaction output
"""
type OutputScript {
  """
  Script annotation
  """
  annotation: String

  """
  Long script pattern
  """
  pattern: String!

  """
  Short script pattern
  """
  short: String!

  """
  Simple script pattern
  """
  simplePattern: String!

  """
  Script type
  """
  type: BitcoinOutputScriptType
}

enum PriceAggregateFunction {
  """
  Maximum
  """
  maximum

  """
  Minimum
  """
  minimum

  """
  Aggregated over interval
  """
  sum

  """
  Average
  """
  average

  """
  Median
  """
  median

  """
  Any value
  """
  any

  """
  Last value
  """
  anyLast
}

"""
Solana Program
"""
type Program {
  id: String!
  name: String!
  parsed: Boolean!
  parsedName: String!
}

enum Protocol {
  """
  Ethereum
  """
  ethereum

  """
  Conflux
  """
  conflux

  """
  Binance DEX
  """
  binance

  """
  Bitcoin
  """
  bitcoin

  """
  Algorand
  """
  algorand

  """
  Libra
  """
  libra

  """
  EOS
  """
  eos

  """
  Tron
  """
  tron

  """
  Filecoin
  """
  filecoin

  """
  Hedera Hashgraph
  """
  hedera

  """
  Solana
  """
  solana

  """
  Cardano
  """
  cardano

  """
  Elrond
  """
  elrond

  """
  Flow
  """
  flow

  """
  Cosmos
  """
  cosmos

  """
  Stellar Ledger
  """
  stellar

  """
  Ripple XRP Ledger
  """
  ripple

  """
  Harmony
  """
  harmony

  """
  Tezos
  """
  tezos

  """
  Everscale
  """
  everscale
}

"""
Blockchain Unified GraphQL API
"""
type Query {
  """
  Algorand Chains Dataset
  """
  algorand(network: AlgorandNetwork): Algorand

  """
  Binance DEX Chain Dataset
  """
  binance: Binance

  """
  Bitcoin and other UTXO Chains Dataset
  """
  bitcoin(network: BitcoinNetwork): Bitcoin

  """
  Cardano Chain Dataset
  """
  cardano(network: CardanoNetwork): Cardano

  """
  Conflux Chains Dataset
  """
  conflux(network: ConfluxNetwork): Conflux

  """
  Cosmos Dataset
  """
  cosmos(network: CosmosNetwork): Cosmos

  """
  Diem ( former Libra ) Testnet Dataset
  """
  diem(network: DiemNetwork): Libra

  """
  Elrond Dataset
  """
  elrond(network: ElrondNetwork): Elrond

  """
  EOS Mainnet Dataset
  """
  eos(network: EosNetwork): Eos

  """
  Ethereum Mainnet / Classic Chain Datasets
  """
  ethereum(network: EthereumNetwork): Ethereum

  """
  Ethereum v2.0 Beacon Chain Datasets
  """
  ethereum2(network: Ethereum2Network): Ethereum2

  """
  Everscale Dataset
  """
  everscale(network: EverscaleNetwork): Everscale

  """
  Filecoin Dataset
  """
  filecoin(network: FilecoinNetwork): Filecoin

  """
  Flow Dataset
  """
  flow(network: FlowNetwork): Flow

  """
  Harmony Dataset
  """
  harmony(network: HarmonyNetwork): Harmony

  """
  Hedera Dataset
  """
  hedera(network: HederaNetwork): Hedera

  """
  Query metrics
  """
  metrics(queryId: String!, options: SeedOptions): Metrics
    @deprecated(reason: "DEPRECATED! Please use utilities { metrics }")

  """
  Ripple Dataset
  """
  ripple(network: RippleNetwork): Ripple

  """
  Search by query string
  """
  search(string: String!, limit: Int, offset: Int, network: Network): [Result!]

  """
  Solana Dataset
  """
  solana(network: SolanaNetwork): Solana

  """
  Stellar Dataset
  """
  stellar(network: StellarNetwork): Stellar

  """
  Tezos Dataset
  """
  tezos(network: TezosNetwork): Tezos

  """
  Tron Mainnet Dataset
  """
  tron(network: TronNetwork): Tron

  """
  Utilities
  """
  utilities: Utilities
}

"""
Limits, Ordering, Constraints
"""
input QueryOptions {
  """
  Limit number of results
  """
  limit: Int

  """
  Limit number of results by specific field
  """
  limitBy: LimitByOption

  """
  Offset of results, starting from 0
  """
  offset: Int

  """
  Ordering field(s) for ascending
  """
  asc: [String!]

  """
  Ordering field(s) for descending
  """
  desc: [String!]

  """
  Converting field(s) to integer datatype and then ordering field(s) for descending
  """
  descByInteger: [String!]

  """
  Converting field(s) to integer datatype and then ordering field(s) for ascending
  """
  ascByInteger: [String!]
}

"""
Solana Receiver
"""
type Receiver {
  address: String!
  mintAccount: String!
  type: String!
}

"""
Search result item
"""
type Result {
  """
  Blockchain where result is found
  """
  network: BlockchainNetwork!

  """
  Subject in blockchain
  """
  subject: Subject!
}

"""
Select by reward type
"""
input RewardTypeSelector {
  """
  Type is
  """
  is: SolanaRewardType

  """
  Type not
  """
  not: SolanaRewardType

  """
  Type in the list
  """
  in: [SolanaRewardType!]

  """
  Type not in the list
  """
  notIn: [SolanaRewardType!]
}

"""
Ripple Chain
"""
type Ripple {
  """
  Ripple Account Roots
  """
  accountRoots(
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    domain: StringSelector
    sequence: BigIntIdSelector
    prevTxnId: StringSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    ownerCount: BigIntIdSelector
    transferRate: BigIntIdSelector
    prevBalance: FloatSelector
    balance: FloatSelector
    any: [RippleAccountRootFilter!]
    options: QueryOptions
  ): [RippleAccountRoot!]

  """
  Basic information about address
  """
  address(address: [AddressSelectorIn!]!): [RippleAddressInfo!]!

  """
  Blockchain Address Statistics
  """
  addressStats(
    address: AddressSelector!
    options: QueryOptions
  ): [RippleAddressStats!]

  """
  Ripple Balances
  """
  balances(
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    currencySymbol: CurrencySelector
    issuer: AddressSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    balance: FloatSelector
    prevBalance: FloatSelector
    any: [RippleBalanceFilter!]
    options: QueryOptions
  ): [RippleBalance!]

  """
  Ripple Blocks
  """
  blocks(
    date: DateSelector
    time: DateTimeSelector
    height: BigIntIdSelector
    hash: HashSelector
    accountHash: HashSelector
    transactionHash: HashSelector
    totalCoins: FloatSelector
    any: [RippleBlockFilter!]
    options: QueryOptions
  ): [RippleBlock!]

  """
  Ripple Checks
  """
  checks(
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    destination: StringSelector
    currencySymbol: CurrencySelector
    expiration: BigIntIdSelector
    invoiceId: StringSelector
    sourceTag: BigIntIdSelector
    destinationTag: BigIntIdSelector
    sequence: BigIntIdSelector
    prevTxnId: StringSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    sendMax: FloatSelector
    any: [RippleCheckFilter!]
    options: QueryOptions
  ): [RippleCheck!]

  """
  Money flow using Coinpath technology
  """
  coinpath(
    sender: AddressSelector
    receiver: AddressSelector
    currencyFrom: CurrencySelector
    currencyTo: CurrencySelector
    initialAddress: AddressSelector
    initialDate: DateSelector
    initialTime: DateTimeSelector
    date: DateSelector
    time: DateTimeSelector
    depth: IntegerLimitedSelector
    options: CoinpathOptions
  ): [RippleCoinpath!]

  """
  Ripple Escrows
  """
  escrows(
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    destination: StringSelector
    currencySymbol: CurrencySelector
    condition: StringSelector
    cancelAfter: BigIntIdSelector
    finishAfter: BigIntIdSelector
    sourceTag: BigIntIdSelector
    destinationTag: BigIntIdSelector
    prevTxnId: StringSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    amount: FloatSelector
    any: [RippleEscrowFilter!]
    options: QueryOptions
  ): [RippleEscrow!]

  """
  Ripple Offers
  """
  offers(
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    takerGetsCurrencySymbol: CurrencySelector
    takerPaysCurrencySymbol: CurrencySelector
    bookDirectory: StringSelector
    bookNode: StringSelector
    expiration: BigIntIdSelector
    sequence: BigIntIdSelector
    prevTxnId: BigIntIdSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    takerGetsAmount: FloatSelector
    takerPaysAmount: FloatSelector
    preTakerGetsAmount: FloatSelector
    preTakerPaysAmount: FloatSelector
    any: [RippleOfferFilter!]
    options: QueryOptions
  ): [RippleOffer!]

  """
  Ripple Payments
  """
  payments(
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    sender: AddressSelector
    receiver: AddressSelector
    amountCurrency: CurrencySelector
    amountIssuer: AddressSelector
    deliveredCurrency: CurrencySelector
    deliveredIssuer: AddressSelector
    sendMaxCurrency: CurrencySelector
    sendMaxIssuer: AddressSelector
    deliverMinCurrency: CurrencySelector
    deliverMinIssuer: AddressSelector
    tag: BigIntIdSelector
    invoice: StringSelector
    flags: BigIntIdSelector
    partial: BooleanSelector
    amount: FloatSelector
    deliveredAmount: FloatSelector
    sendMaxAmount: FloatSelector
    deliverMinAmount: FloatSelector
    any: [RipplePaymentFilter!]
    options: QueryOptions
  ): [RipplePayment!]

  """
  Ripple Ripple States
  """
  rippleStates(
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    lowAccount: AddressSelector
    highAccount: AddressSelector
    currencySymbol: CurrencySelector
    prevTxnId: StringSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    balance: FloatSelector
    prevBalance: FloatSelector
    any: [RippleRippleStateFilter!]
    options: QueryOptions
  ): [RippleRippleState!]

  """
  Ripple Transactions
  """
  transactions(
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    index: IntegerSelector
    hash: HashSelector
    sender: AddressSelector
    type: StringSelector
    memos: StringSelector
    sourceTag: BigIntIdSelector
    accountTxnId: AddressSelector
    sequence: BigIntIdSelector
    lastLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    result: StringSelector
    success: BooleanSelector
    fee: FloatSelector
    any: [RippleTransactionFilter!]
    options: QueryOptions
  ): [RippleTransaction!]

  """
  Ripple Transfers
  """
  transfers(
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    sender: AddressSelector
    receiver: AddressSelector
    currencyFromSymbol: CurrencySelector
    currencyToSymbol: CurrencySelector
    direction: StringSelector
    amountFrom: FloatSelector
    amountTo: FloatSelector
    any: [RippleTransferFilter!]
    options: QueryOptions
  ): [RippleTransfer!]
}

"""
Account root in Ripple blockchain
"""
type RippleAccountRoot {
  """
  Account
  """
  account: Address
  any(of: RippleAccountRootMeasurable!): String
  balance(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    domain: StringSelector
    sequence: BigIntIdSelector
    prevTxnId: StringSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    ownerCount: BigIntIdSelector
    transferRate: BigIntIdSelector
    prevBalance: FloatSelector
    balance: FloatSelector
  ): DecimalNumberAsDiv

  """
  Block
  """
  block: BigInt
  count(
    uniq: RippleAccountRootUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    domain: StringSelector
    sequence: BigIntIdSelector
    prevTxnId: StringSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    ownerCount: BigIntIdSelector
    transferRate: BigIntIdSelector
    prevBalance: FloatSelector
    balance: FloatSelector
  ): Int
  countBigInt(
    uniq: RippleAccountRootUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    domain: StringSelector
    sequence: BigIntIdSelector
    prevTxnId: StringSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    ownerCount: BigIntIdSelector
    transferRate: BigIntIdSelector
    prevBalance: FloatSelector
    balance: FloatSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date

  """
  Domain
  """
  domain: String
  expression(get: String!): DecimalNumber

  """
  Flags
  """
  flags: BigInt
  maximum(
    of: RippleAccountRootMeasurable!
    get: RippleAccountRootMeasurable
  ): String
  minimum(
    of: RippleAccountRootMeasurable!
    get: RippleAccountRootMeasurable
  ): String

  """
  Operation
  """
  operation: String
  ownerCount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    domain: StringSelector
    sequence: BigIntIdSelector
    prevTxnId: StringSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    ownerCount: BigIntIdSelector
    transferRate: BigIntIdSelector
    prevBalance: FloatSelector
    balance: FloatSelector
  ): BigInt
  prevBalance(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    domain: StringSelector
    sequence: BigIntIdSelector
    prevTxnId: StringSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    ownerCount: BigIntIdSelector
    transferRate: BigIntIdSelector
    prevBalance: FloatSelector
    balance: FloatSelector
  ): DecimalNumberAsDiv

  """
  Prev ledger sequence
  """
  prevLedgerSequence: BigInt

  """
  Prev txn
  """
  prevTxnId: String

  """
  Sequence
  """
  sequence: BigInt

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transaction
  """
  transaction: RippleTransactionDimension
  transferRate(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    domain: StringSelector
    sequence: BigIntIdSelector
    prevTxnId: StringSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    ownerCount: BigIntIdSelector
    transferRate: BigIntIdSelector
    prevBalance: FloatSelector
    balance: FloatSelector
  ): BigInt
}

input RippleAccountRootFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  transactionType: StringSelector
  operation: StringSelector
  account: AddressSelector
  domain: StringSelector
  sequence: BigIntIdSelector
  prevTxnId: StringSelector
  prevLedgerSequence: BigIntIdSelector
  flags: BigIntIdSelector
  ownerCount: BigIntIdSelector
  transferRate: BigIntIdSelector
  prevBalance: FloatSelector
  balance: FloatSelector
}

enum RippleAccountRootMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction index
  """
  transactionIndex

  """
  Transaction hash
  """
  transactionHash

  """
  Transaction sender
  """
  transactionSender

  """
  Transaction type
  """
  transactionType

  """
  Operation
  """
  operation

  """
  Account
  """
  account

  """
  Prev balance
  """
  prevBalance

  """
  Balance
  """
  balance

  """
  Domain
  """
  domain

  """
  Owner count
  """
  ownerCount

  """
  Transfer rate
  """
  transferRate

  """
  Sequence
  """
  sequence

  """
  Prev txn
  """
  prevTxnId

  """
  Prev ledger sequence
  """
  prevLedgerSequence

  """
  Flags
  """
  flags
}

enum RippleAccountRootUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Uniq blocks count
  """
  blocks

  """
  Uniq transaction indices count
  """
  transactionIndices

  """
  Uniq transaction hashes count
  """
  transactionHashes

  """
  Uniq transaction senders count
  """
  transactionSenders

  """
  Uniq transaction types count
  """
  transactionTypes

  """
  Uniq operations count
  """
  operations

  """
  Uniq accounts count
  """
  accounts

  """
  Uniq domains count
  """
  domains

  """
  Uniq sequences count
  """
  sequences

  """
  Uniq prev txn ids count
  """
  prevTxnIds

  """
  Uniq prev ledger sequences count
  """
  prevLedgerSequences

  """
  Uniq flags count
  """
  flags
}

"""
Address detailed information for Ripple network
"""
type RippleAddressInfo {
  """
  Address
  """
  address: String

  """
  Annotations ( tags ), if exists
  """
  annotation: String

  """
  XRP balance
  """
  balance(in: BaseCurrencyEnum): Float

  """
  Token Balances
  """
  tokenBalances: [RippleTokenBalances!]
}

"""
Counts and aggregates for the address, transfer count,
                  amount, number of distinct currencies,
                  times of the first and the last transactions
"""
type RippleAddressStat {
  """
  Address
  """
  address: Address

  """
  Balance
  """
  balance: BigInt

  """
  Days with received
  """
  daysWithReceived: BigInt

  """
  Days with sent
  """
  daysWithSent: BigInt

  """
  Days with transactions
  """
  daysWithTransactions: BigInt

  """
  Days with transfers
  """
  daysWithTransfers: BigInt

  """
  First transfer at
  """
  firstTransferAt: DateTime

  """
  First tx at
  """
  firstTxAt: DateTime

  """
  Last transfer at
  """
  lastTransferAt: DateTime

  """
  Last tx at
  """
  lastTxAt: DateTime

  """
  Receive Amount
  """
  receiveAmount: BigInt

  """
  Receive from Count
  """
  receiveFromCount: BigInt

  """
  Receive from currencies
  """
  receiveFromCurrencies: BigInt

  """
  Receive tx Count
  """
  receiveTxCount: BigInt

  """
  Send Amount
  """
  sendAmount: BigInt

  """
  Send to count
  """
  sendToCount: BigInt

  """
  Send to currencies
  """
  sendToCurrencies: BigInt

  """
  Send tx count
  """
  sendTxCount: BigInt
}

"""
AddressStat
"""
type RippleAddressStats {
  """
  Address With Statistics
  """
  address: RippleAddressStat
}

"""
Balance in Ripple blockchain
"""
type RippleBalance {
  """
  Account
  """
  account: Address
  any(of: RippleBalanceMeasurable!): String
  balance(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    currencySymbol: CurrencySelector
    issuer: AddressSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    balance: FloatSelector
    prevBalance: FloatSelector
  ): Float

  """
  Block
  """
  block: BigInt
  count(
    uniq: RippleBalanceUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    currencySymbol: CurrencySelector
    issuer: AddressSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    balance: FloatSelector
    prevBalance: FloatSelector
  ): Int
  countBigInt(
    uniq: RippleBalanceUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    currencySymbol: CurrencySelector
    issuer: AddressSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    balance: FloatSelector
    prevBalance: FloatSelector
  ): BigInt

  """
  Currency
  """
  currency: Currency

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Flags
  """
  flags: BigInt

  """
  Issuer
  """
  issuer: Address
  maximum(of: RippleBalanceMeasurable!, get: RippleBalanceMeasurable): String
  minimum(of: RippleBalanceMeasurable!, get: RippleBalanceMeasurable): String

  """
  Operation
  """
  operation: String
  prevBalance(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    currencySymbol: CurrencySelector
    issuer: AddressSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    balance: FloatSelector
    prevBalance: FloatSelector
  ): Float

  """
  Prev ledger sequence
  """
  prevLedgerSequence: BigInt

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transaction
  """
  transaction: RippleTransactionDimension
}

input RippleBalanceFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  transactionType: StringSelector
  operation: StringSelector
  account: AddressSelector
  currencySymbol: CurrencySelector
  issuer: AddressSelector
  prevLedgerSequence: BigIntIdSelector
  flags: BigIntIdSelector
  balance: FloatSelector
  prevBalance: FloatSelector
}

enum RippleBalanceMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction index
  """
  transactionIndex

  """
  Transaction hash
  """
  transactionHash

  """
  Transaction sender
  """
  transactionSender

  """
  Transaction type
  """
  transactionType

  """
  Operation
  """
  operation

  """
  Account
  """
  account

  """
  Currency name
  """
  currencyName

  """
  Currency symbol
  """
  currencySymbol

  """
  Issuer
  """
  issuer

  """
  Prev balance
  """
  prevBalance

  """
  Balance
  """
  balance

  """
  Prev ledger sequence
  """
  prevLedgerSequence

  """
  Flags
  """
  flags
}

enum RippleBalanceUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Uniq blocks count
  """
  blocks

  """
  Uniq transaction indices count
  """
  transactionIndices

  """
  Uniq transaction hashes count
  """
  transactionHashes

  """
  Uniq transaction senders count
  """
  transactionSenders

  """
  Uniq transaction types count
  """
  transactionTypes

  """
  Uniq operations count
  """
  operations

  """
  Uniq accounts count
  """
  accounts

  """
  Uniq currency names count
  """
  currencyNames

  """
  Uniq currency symbols count
  """
  currencySymbols

  """
  Uniq issuers count
  """
  issuers

  """
  Uniq prev ledger sequences count
  """
  prevLedgerSequences

  """
  Uniq flags count
  """
  flags
}

"""
Block in Ripple blockchain
"""
type RippleBlock {
  """
  Account hash
  """
  accountHash: String
  any(of: RippleBlockMeasurable!): String
  count(
    uniq: RippleBlockUniq
    date: DateSelector
    time: DateTimeSelector
    height: BigIntIdSelector
    hash: HashSelector
    accountHash: HashSelector
    transactionHash: HashSelector
    totalCoins: FloatSelector
  ): Int
  countBigInt(
    uniq: RippleBlockUniq
    date: DateSelector
    time: DateTimeSelector
    height: BigIntIdSelector
    hash: HashSelector
    accountHash: HashSelector
    transactionHash: HashSelector
    totalCoins: FloatSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Block hash
  """
  hash: String

  """
  Block number (height) in blockchain
  """
  height: BigInt
  maximum(of: RippleBlockMeasurable!, get: RippleBlockMeasurable): String
  minimum(of: RippleBlockMeasurable!, get: RippleBlockMeasurable): String

  """
  Timestamp
  """
  timestamp: DateTime
  totalCoins(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BigIntIdSelector
    hash: HashSelector
    accountHash: HashSelector
    transactionHash: HashSelector
    totalCoins: FloatSelector
  ): DecimalNumberAsDiv

  """
  Transaction hash
  """
  transactionHash: String
}

input RippleBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BigIntIdSelector
  hash: HashSelector
  accountHash: HashSelector
  transactionHash: HashSelector
  totalCoins: FloatSelector
}

enum RippleBlockMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Hash
  """
  hash

  """
  Total coins
  """
  totalCoins

  """
  Account hash
  """
  accountHash

  """
  Transaction hash
  """
  transactionHash
}

enum RippleBlockUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq blocks count
  """
  blocks

  """
  Uniq hashes count
  """
  hashes

  """
  Uniq account hashes count
  """
  accountHashes

  """
  Uniq transaction hashes count
  """
  transactionHashes
}

"""
Check in Ripple blockchain
"""
type RippleCheck {
  """
  Account
  """
  account: Address
  any(of: RippleCheckMeasurable!): String

  """
  Block
  """
  block: BigInt
  count(
    uniq: RippleCheckUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    destination: StringSelector
    currencySymbol: CurrencySelector
    expiration: BigIntIdSelector
    invoiceId: StringSelector
    sourceTag: BigIntIdSelector
    destinationTag: BigIntIdSelector
    sequence: BigIntIdSelector
    prevTxnId: StringSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    sendMax: FloatSelector
  ): Int
  countBigInt(
    uniq: RippleCheckUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    destination: StringSelector
    currencySymbol: CurrencySelector
    expiration: BigIntIdSelector
    invoiceId: StringSelector
    sourceTag: BigIntIdSelector
    destinationTag: BigIntIdSelector
    sequence: BigIntIdSelector
    prevTxnId: StringSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    sendMax: FloatSelector
  ): BigInt

  """
  Currency
  """
  currency: Currency

  """
  Calendar date
  """
  date: Date

  """
  Destination
  """
  destination: Address

  """
  Destination tag
  """
  destinationTag: BigInt

  """
  Expiration
  """
  expiration: BigInt
  expression(get: String!): DecimalNumber

  """
  Flags
  """
  flags: BigInt

  """
  Invoice
  """
  invoiceId: String
  maximum(of: RippleCheckMeasurable!, get: RippleCheckMeasurable): String
  minimum(of: RippleCheckMeasurable!, get: RippleCheckMeasurable): String

  """
  Operation
  """
  operation: String

  """
  Prev ledger sequence
  """
  prevLedgerSequence: BigInt

  """
  Prev txn
  """
  prevTxnId: String
  sendMax(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    destination: StringSelector
    currencySymbol: CurrencySelector
    expiration: BigIntIdSelector
    invoiceId: StringSelector
    sourceTag: BigIntIdSelector
    destinationTag: BigIntIdSelector
    sequence: BigIntIdSelector
    prevTxnId: StringSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    sendMax: FloatSelector
  ): Float

  """
  Sequence
  """
  sequence: BigInt

  """
  Source tag
  """
  sourceTag: BigInt

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transaction
  """
  transaction: RippleTransactionDimension
}

input RippleCheckFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  transactionType: StringSelector
  operation: StringSelector
  account: AddressSelector
  destination: StringSelector
  currencySymbol: CurrencySelector
  expiration: BigIntIdSelector
  invoiceId: StringSelector
  sourceTag: BigIntIdSelector
  destinationTag: BigIntIdSelector
  sequence: BigIntIdSelector
  prevTxnId: StringSelector
  prevLedgerSequence: BigIntIdSelector
  flags: BigIntIdSelector
  sendMax: FloatSelector
}

enum RippleCheckMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction index
  """
  transactionIndex

  """
  Transaction hash
  """
  transactionHash

  """
  Transaction sender
  """
  transactionSender

  """
  Transaction type
  """
  transactionType

  """
  Operation
  """
  operation

  """
  Account
  """
  account

  """
  Destination
  """
  destination

  """
  Currency name
  """
  currencyName

  """
  Currency symbol
  """
  currencySymbol

  """
  Send max
  """
  sendMax

  """
  Expiration
  """
  expiration

  """
  Invoice
  """
  invoiceId

  """
  Source tag
  """
  sourceTag

  """
  Destination tag
  """
  destinationTag

  """
  Sequence
  """
  sequence

  """
  Prev txn
  """
  prevTxnId

  """
  Prev ledger sequence
  """
  prevLedgerSequence

  """
  Flags
  """
  flags
}

enum RippleCheckUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Uniq blocks count
  """
  blocks

  """
  Uniq transaction indices count
  """
  transactionIndices

  """
  Uniq transaction hashes count
  """
  transactionHashes

  """
  Uniq transaction senders count
  """
  transactionSenders

  """
  Uniq transaction types count
  """
  transactionTypes

  """
  Uniq operations count
  """
  operations

  """
  Uniq accounts count
  """
  accounts

  """
  Uniq destinations count
  """
  destinations

  """
  Uniq currency names count
  """
  currencyNames

  """
  Uniq currency symbols count
  """
  currencySymbols

  """
  Uniq expirations count
  """
  expirations

  """
  Uniq invoice ids count
  """
  invoiceIds

  """
  Uniq source tags count
  """
  sourceTags

  """
  Uniq destination tags count
  """
  destinationTags

  """
  Uniq sequences count
  """
  sequences

  """
  Uniq prev txn ids count
  """
  prevTxnIds

  """
  Uniq prev ledger sequences count
  """
  prevLedgerSequences

  """
  Uniq flags count
  """
  flags
}

"""
Ripple Coinpath
"""
type RippleCoinpath {
  """
  Summary of transfered value from
  """
  amountFrom(in: BaseCurrencyEnum): Float

  """
  Summary of transfered value to
  """
  amountTo(in: BaseCurrencyEnum): Float
  any(of: RippleCoinpathMeasureable!): String

  """
  Block where transaction is included
  """
  block: Block

  """
  Count of transfers
  """
  count: Int

  """
  Count of transfers
  """
  countBigInt: BigInt

  """
  Currency From of transfer
  """
  currencyFrom: Currency

  """
  Currency To of transfer
  """
  currencyTo: Currency

  """
  1-based hop depth of the graph
  """
  depth: Int
  maximum(
    of: RippleCoinpathMeasureable!
    get: RippleCoinpathMeasureable
  ): String
  minimum(
    of: RippleCoinpathMeasureable!
    get: RippleCoinpathMeasureable
  ): String

  """
  Operation
  """
  operation: String

  """
  Receiver address
  """
  receiver: StellarCoinpathAddress

  """
  Sender address
  """
  sender: StellarCoinpathAddress

  """
  Transaction of transfer happened
  """
  transaction: StellarTransactionCoinpathDimension
}

enum RippleCoinpathMeasureable {
  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Version
  """
  tx_hash

  """
  Sender
  """
  sender

  """
  Receiver
  """
  receiver

  """
  Depth
  """
  depth
}

"""
Escrow in Ripple blockchain
"""
type RippleEscrow {
  """
  Account
  """
  account: Address
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    destination: StringSelector
    currencySymbol: CurrencySelector
    condition: StringSelector
    cancelAfter: BigIntIdSelector
    finishAfter: BigIntIdSelector
    sourceTag: BigIntIdSelector
    destinationTag: BigIntIdSelector
    prevTxnId: StringSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    amount: FloatSelector
  ): Float
  any(of: RippleEscrowMeasurable!): String

  """
  Block
  """
  block: BigInt

  """
  Cancel after
  """
  cancelAfter: BigInt

  """
  Condition
  """
  condition: String
  count(
    uniq: RippleEscrowUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    destination: StringSelector
    currencySymbol: CurrencySelector
    condition: StringSelector
    cancelAfter: BigIntIdSelector
    finishAfter: BigIntIdSelector
    sourceTag: BigIntIdSelector
    destinationTag: BigIntIdSelector
    prevTxnId: StringSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    amount: FloatSelector
  ): Int
  countBigInt(
    uniq: RippleEscrowUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    destination: StringSelector
    currencySymbol: CurrencySelector
    condition: StringSelector
    cancelAfter: BigIntIdSelector
    finishAfter: BigIntIdSelector
    sourceTag: BigIntIdSelector
    destinationTag: BigIntIdSelector
    prevTxnId: StringSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    amount: FloatSelector
  ): BigInt

  """
  Currency
  """
  currency: Currency

  """
  Calendar date
  """
  date: Date

  """
  Destination
  """
  destination: Address

  """
  Destination tag
  """
  destinationTag: BigInt
  expression(get: String!): DecimalNumber

  """
  Finish after
  """
  finishAfter: BigInt

  """
  Flags
  """
  flags: BigInt
  maximum(of: RippleEscrowMeasurable!, get: RippleEscrowMeasurable): String
  minimum(of: RippleEscrowMeasurable!, get: RippleEscrowMeasurable): String

  """
  Operation
  """
  operation: String

  """
  Prev ledger sequence
  """
  prevLedgerSequence: BigInt

  """
  Prev txn
  """
  prevTxnId: String

  """
  Source tag
  """
  sourceTag: BigInt

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transaction
  """
  transaction: RippleTransactionDimension
}

input RippleEscrowFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  transactionType: StringSelector
  operation: StringSelector
  account: AddressSelector
  destination: StringSelector
  currencySymbol: CurrencySelector
  condition: StringSelector
  cancelAfter: BigIntIdSelector
  finishAfter: BigIntIdSelector
  sourceTag: BigIntIdSelector
  destinationTag: BigIntIdSelector
  prevTxnId: StringSelector
  prevLedgerSequence: BigIntIdSelector
  flags: BigIntIdSelector
  amount: FloatSelector
}

enum RippleEscrowMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction index
  """
  transactionIndex

  """
  Transaction hash
  """
  transactionHash

  """
  Transaction sender
  """
  transactionSender

  """
  Transaction type
  """
  transactionType

  """
  Operation
  """
  operation

  """
  Account
  """
  account

  """
  Destination
  """
  destination

  """
  Currency name
  """
  currencyName

  """
  Currency symbol
  """
  currencySymbol

  """
  Amount
  """
  amount

  """
  Condition
  """
  condition

  """
  Cancel after
  """
  cancelAfter

  """
  Finish after
  """
  finishAfter

  """
  Source tag
  """
  sourceTag

  """
  Destination tag
  """
  destinationTag

  """
  Prev txn
  """
  prevTxnId

  """
  Prev ledger sequence
  """
  prevLedgerSequence

  """
  Flags
  """
  flags
}

enum RippleEscrowUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Uniq blocks count
  """
  blocks

  """
  Uniq transaction indices count
  """
  transactionIndices

  """
  Uniq transaction hashes count
  """
  transactionHashes

  """
  Uniq transaction senders count
  """
  transactionSenders

  """
  Uniq transaction types count
  """
  transactionTypes

  """
  Uniq operations count
  """
  operations

  """
  Uniq accounts count
  """
  accounts

  """
  Uniq destinations count
  """
  destinations

  """
  Uniq currency names count
  """
  currencyNames

  """
  Uniq currency symbols count
  """
  currencySymbols

  """
  Uniq conditions count
  """
  conditions

  """
  Uniq cancel afters count
  """
  cancelAfters

  """
  Uniq finish afters count
  """
  finishAfters

  """
  Uniq source tags count
  """
  sourceTags

  """
  Uniq destination tags count
  """
  destinationTags

  """
  Uniq prev txn ids count
  """
  prevTxnIds

  """
  Uniq prev ledger sequences count
  """
  prevLedgerSequences

  """
  Uniq flags count
  """
  flags
}

enum RippleNetwork {
  """
  Ripple XRP Ledger
  """
  ripple
}

"""
Offer in Ripple blockchain
"""
type RippleOffer {
  """
  Account
  """
  account: Address
  any(of: RippleOfferMeasurable!): String

  """
  Block
  """
  block: BigInt

  """
  Book directory
  """
  bookDirectory: String

  """
  Book node
  """
  bookNode: String
  count(
    uniq: RippleOfferUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    takerGetsCurrencySymbol: CurrencySelector
    takerPaysCurrencySymbol: CurrencySelector
    bookDirectory: StringSelector
    bookNode: StringSelector
    expiration: BigIntIdSelector
    sequence: BigIntIdSelector
    prevTxnId: BigIntIdSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    takerGetsAmount: FloatSelector
    takerPaysAmount: FloatSelector
    preTakerGetsAmount: FloatSelector
    preTakerPaysAmount: FloatSelector
  ): Int
  countBigInt(
    uniq: RippleOfferUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    takerGetsCurrencySymbol: CurrencySelector
    takerPaysCurrencySymbol: CurrencySelector
    bookDirectory: StringSelector
    bookNode: StringSelector
    expiration: BigIntIdSelector
    sequence: BigIntIdSelector
    prevTxnId: BigIntIdSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    takerGetsAmount: FloatSelector
    takerPaysAmount: FloatSelector
    preTakerGetsAmount: FloatSelector
    preTakerPaysAmount: FloatSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date

  """
  Expiration
  """
  expiration: BigInt
  expression(get: String!): DecimalNumber

  """
  Flags
  """
  flags: BigInt
  maximum(of: RippleOfferMeasurable!, get: RippleOfferMeasurable): String
  minimum(of: RippleOfferMeasurable!, get: RippleOfferMeasurable): String

  """
  Operation
  """
  operation: String
  preTakerGetsAmount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    takerGetsCurrencySymbol: CurrencySelector
    takerPaysCurrencySymbol: CurrencySelector
    bookDirectory: StringSelector
    bookNode: StringSelector
    expiration: BigIntIdSelector
    sequence: BigIntIdSelector
    prevTxnId: BigIntIdSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    takerGetsAmount: FloatSelector
    takerPaysAmount: FloatSelector
    preTakerGetsAmount: FloatSelector
    preTakerPaysAmount: FloatSelector
  ): Float
  preTakerPaysAmount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    takerGetsCurrencySymbol: CurrencySelector
    takerPaysCurrencySymbol: CurrencySelector
    bookDirectory: StringSelector
    bookNode: StringSelector
    expiration: BigIntIdSelector
    sequence: BigIntIdSelector
    prevTxnId: BigIntIdSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    takerGetsAmount: FloatSelector
    takerPaysAmount: FloatSelector
    preTakerGetsAmount: FloatSelector
    preTakerPaysAmount: FloatSelector
  ): Float

  """
  Prev ledger sequence
  """
  prevLedgerSequence: BigInt

  """
  Prev txn
  """
  prevTxnId: String

  """
  Sequence
  """
  sequence: BigInt
  takerGetsAmount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    takerGetsCurrencySymbol: CurrencySelector
    takerPaysCurrencySymbol: CurrencySelector
    bookDirectory: StringSelector
    bookNode: StringSelector
    expiration: BigIntIdSelector
    sequence: BigIntIdSelector
    prevTxnId: BigIntIdSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    takerGetsAmount: FloatSelector
    takerPaysAmount: FloatSelector
    preTakerGetsAmount: FloatSelector
    preTakerPaysAmount: FloatSelector
  ): Float

  """
  Taker gets currency
  """
  takerGetsCurrency: Currency
  takerPaysAmount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    account: AddressSelector
    takerGetsCurrencySymbol: CurrencySelector
    takerPaysCurrencySymbol: CurrencySelector
    bookDirectory: StringSelector
    bookNode: StringSelector
    expiration: BigIntIdSelector
    sequence: BigIntIdSelector
    prevTxnId: BigIntIdSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    takerGetsAmount: FloatSelector
    takerPaysAmount: FloatSelector
    preTakerGetsAmount: FloatSelector
    preTakerPaysAmount: FloatSelector
  ): Float

  """
  Taker pays currency
  """
  takerPaysCurrency: Currency

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transaction
  """
  transaction: RippleTransactionDimension
}

input RippleOfferFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  transactionType: StringSelector
  operation: StringSelector
  account: AddressSelector
  takerGetsCurrencySymbol: CurrencySelector
  takerPaysCurrencySymbol: CurrencySelector
  bookDirectory: StringSelector
  bookNode: StringSelector
  expiration: BigIntIdSelector
  sequence: BigIntIdSelector
  prevTxnId: BigIntIdSelector
  prevLedgerSequence: BigIntIdSelector
  flags: BigIntIdSelector
  takerGetsAmount: FloatSelector
  takerPaysAmount: FloatSelector
  preTakerGetsAmount: FloatSelector
  preTakerPaysAmount: FloatSelector
}

enum RippleOfferMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction index
  """
  transactionIndex

  """
  Transaction hash
  """
  transactionHash

  """
  Transaction sender
  """
  transactionSender

  """
  Transaction type
  """
  transactionType

  """
  Operation
  """
  operation

  """
  Account
  """
  account

  """
  Taker gets currency name
  """
  takerGetsCurrencyName

  """
  Taker gets currency symbol
  """
  takerGetsCurrencySymbol

  """
  Taker pays currency name
  """
  takerPaysCurrencyName

  """
  Taker pays currency symbol
  """
  takerPaysCurrencySymbol

  """
  Taker gets amount
  """
  takerGetsAmount

  """
  Taker pays amount
  """
  takerPaysAmount

  """
  Pre taker gets amount
  """
  preTakerGetsAmount

  """
  Pre taker pays amount
  """
  preTakerPaysAmount

  """
  Book directory
  """
  bookDirectory

  """
  Book node
  """
  bookNode

  """
  Expiration
  """
  expiration

  """
  Sequence
  """
  sequence

  """
  Prev txn
  """
  prevTxnId

  """
  Prev ledger sequence
  """
  prevLedgerSequence

  """
  Flags
  """
  flags
}

enum RippleOfferUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Uniq blocks count
  """
  blocks

  """
  Uniq transaction indices count
  """
  transactionIndices

  """
  Uniq transaction hashes count
  """
  transactionHashes

  """
  Uniq transaction senders count
  """
  transactionSenders

  """
  Uniq transaction types count
  """
  transactionTypes

  """
  Uniq operations count
  """
  operations

  """
  Uniq accounts count
  """
  accounts

  """
  Uniq taker gets currency names count
  """
  takerGetsCurrencyNames

  """
  Uniq taker gets currency symbols count
  """
  takerGetsCurrencySymbols

  """
  Uniq taker pays currency names count
  """
  takerPaysCurrencyNames

  """
  Uniq taker pays currency symbols count
  """
  takerPaysCurrencySymbols

  """
  Uniq book directories count
  """
  bookDirectories

  """
  Uniq book nodes count
  """
  bookNodes

  """
  Uniq expirations count
  """
  expirations

  """
  Uniq sequences count
  """
  sequences

  """
  Uniq prev txn ids count
  """
  prevTxnIds

  """
  Uniq prev ledger sequences count
  """
  prevLedgerSequences

  """
  Uniq flags count
  """
  flags
}

"""
Payment in Ripple blockchain
"""
type RipplePayment {
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    sender: AddressSelector
    receiver: AddressSelector
    amountCurrency: CurrencySelector
    amountIssuer: AddressSelector
    deliveredCurrency: CurrencySelector
    deliveredIssuer: AddressSelector
    sendMaxCurrency: CurrencySelector
    sendMaxIssuer: AddressSelector
    deliverMinCurrency: CurrencySelector
    deliverMinIssuer: AddressSelector
    tag: BigIntIdSelector
    invoice: StringSelector
    flags: BigIntIdSelector
    partial: BooleanSelector
    amount: FloatSelector
    deliveredAmount: FloatSelector
    sendMaxAmount: FloatSelector
    deliverMinAmount: FloatSelector
  ): Float

  """
  Amount currency
  """
  amountCurrency: Currency

  """
  Amount issuer
  """
  amountIssuer: Address
  any(of: RipplePaymentMeasurable!): String

  """
  Block
  """
  block: BigInt
  count(
    uniq: RipplePaymentUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    sender: AddressSelector
    receiver: AddressSelector
    amountCurrency: CurrencySelector
    amountIssuer: AddressSelector
    deliveredCurrency: CurrencySelector
    deliveredIssuer: AddressSelector
    sendMaxCurrency: CurrencySelector
    sendMaxIssuer: AddressSelector
    deliverMinCurrency: CurrencySelector
    deliverMinIssuer: AddressSelector
    tag: BigIntIdSelector
    invoice: StringSelector
    flags: BigIntIdSelector
    partial: BooleanSelector
    amount: FloatSelector
    deliveredAmount: FloatSelector
    sendMaxAmount: FloatSelector
    deliverMinAmount: FloatSelector
  ): Int
  countBigInt(
    uniq: RipplePaymentUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    sender: AddressSelector
    receiver: AddressSelector
    amountCurrency: CurrencySelector
    amountIssuer: AddressSelector
    deliveredCurrency: CurrencySelector
    deliveredIssuer: AddressSelector
    sendMaxCurrency: CurrencySelector
    sendMaxIssuer: AddressSelector
    deliverMinCurrency: CurrencySelector
    deliverMinIssuer: AddressSelector
    tag: BigIntIdSelector
    invoice: StringSelector
    flags: BigIntIdSelector
    partial: BooleanSelector
    amount: FloatSelector
    deliveredAmount: FloatSelector
    sendMaxAmount: FloatSelector
    deliverMinAmount: FloatSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  deliverMinAmount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    sender: AddressSelector
    receiver: AddressSelector
    amountCurrency: CurrencySelector
    amountIssuer: AddressSelector
    deliveredCurrency: CurrencySelector
    deliveredIssuer: AddressSelector
    sendMaxCurrency: CurrencySelector
    sendMaxIssuer: AddressSelector
    deliverMinCurrency: CurrencySelector
    deliverMinIssuer: AddressSelector
    tag: BigIntIdSelector
    invoice: StringSelector
    flags: BigIntIdSelector
    partial: BooleanSelector
    amount: FloatSelector
    deliveredAmount: FloatSelector
    sendMaxAmount: FloatSelector
    deliverMinAmount: FloatSelector
  ): Float

  """
  Deliver min currency
  """
  deliverMinCurrency: Currency

  """
  Deliver min issuer
  """
  deliverMinIssuer: Address
  deliveredAmount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    sender: AddressSelector
    receiver: AddressSelector
    amountCurrency: CurrencySelector
    amountIssuer: AddressSelector
    deliveredCurrency: CurrencySelector
    deliveredIssuer: AddressSelector
    sendMaxCurrency: CurrencySelector
    sendMaxIssuer: AddressSelector
    deliverMinCurrency: CurrencySelector
    deliverMinIssuer: AddressSelector
    tag: BigIntIdSelector
    invoice: StringSelector
    flags: BigIntIdSelector
    partial: BooleanSelector
    amount: FloatSelector
    deliveredAmount: FloatSelector
    sendMaxAmount: FloatSelector
    deliverMinAmount: FloatSelector
  ): Float

  """
  Delivered currency
  """
  deliveredCurrency: Currency

  """
  Delivered issuer
  """
  deliveredIssuer: Address
  expression(get: String!): DecimalNumber

  """
  Flags
  """
  flags: BigInt

  """
  Invoice
  """
  invoice: String
  maximum(of: RipplePaymentMeasurable!, get: RipplePaymentMeasurable): String
  minimum(of: RipplePaymentMeasurable!, get: RipplePaymentMeasurable): String

  """
  Partial
  """
  partial: Boolean

  """
  Receiver
  """
  receiver: Address
  sendMaxAmount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    sender: AddressSelector
    receiver: AddressSelector
    amountCurrency: CurrencySelector
    amountIssuer: AddressSelector
    deliveredCurrency: CurrencySelector
    deliveredIssuer: AddressSelector
    sendMaxCurrency: CurrencySelector
    sendMaxIssuer: AddressSelector
    deliverMinCurrency: CurrencySelector
    deliverMinIssuer: AddressSelector
    tag: BigIntIdSelector
    invoice: StringSelector
    flags: BigIntIdSelector
    partial: BooleanSelector
    amount: FloatSelector
    deliveredAmount: FloatSelector
    sendMaxAmount: FloatSelector
    deliverMinAmount: FloatSelector
  ): Float

  """
  Send max currency
  """
  sendMaxCurrency: Currency

  """
  Send max issuer
  """
  sendMaxIssuer: Address

  """
  Sender
  """
  sender: Address

  """
  Tag
  """
  tag: BigInt

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transaction
  """
  transaction: RippleTransactionHashIndexDimension
}

input RipplePaymentFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  sender: AddressSelector
  receiver: AddressSelector
  amountCurrency: CurrencySelector
  amountIssuer: AddressSelector
  deliveredCurrency: CurrencySelector
  deliveredIssuer: AddressSelector
  sendMaxCurrency: CurrencySelector
  sendMaxIssuer: AddressSelector
  deliverMinCurrency: CurrencySelector
  deliverMinIssuer: AddressSelector
  tag: BigIntIdSelector
  invoice: StringSelector
  flags: BigIntIdSelector
  partial: BooleanSelector
  amount: FloatSelector
  deliveredAmount: FloatSelector
  sendMaxAmount: FloatSelector
  deliverMinAmount: FloatSelector
}

enum RipplePaymentMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction index
  """
  transactionIndex

  """
  Transaction hash
  """
  transactionHash

  """
  Sender
  """
  sender

  """
  Receiver
  """
  receiver

  """
  Amount currency name
  """
  amountCurrencyName

  """
  Amount currency symbol
  """
  amountCurrencySymbol

  """
  Amount issuer
  """
  amountIssuer

  """
  Amount
  """
  amount

  """
  Delivered currency name
  """
  deliveredCurrencyName

  """
  Delivered currency symbol
  """
  deliveredCurrencySymbol

  """
  Delivered issuer
  """
  deliveredIssuer

  """
  Delivered amount
  """
  deliveredAmount

  """
  Send max currency name
  """
  sendMaxCurrencyName

  """
  Send max currency symbol
  """
  sendMaxCurrencySymbol

  """
  Send max issuer
  """
  sendMaxIssuer

  """
  Send max amount
  """
  sendMaxAmount

  """
  Deliver min currency name
  """
  deliverMinCurrencyName

  """
  Deliver min currency symbol
  """
  deliverMinCurrencySymbol

  """
  Deliver min issuer
  """
  deliverMinIssuer

  """
  Deliver min amount
  """
  deliverMinAmount

  """
  Tag
  """
  tag

  """
  Invoice
  """
  invoice

  """
  Flags
  """
  flags

  """
  Partial
  """
  partial
}

enum RipplePaymentUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq time count
  """
  time

  """
  Uniq blocks count
  """
  blocks

  """
  Uniq transaction indices count
  """
  transactionIndices

  """
  Uniq transaction hashes count
  """
  transactionHashes

  """
  Uniq senders count
  """
  senders

  """
  Uniq receivers count
  """
  receivers

  """
  Uniq amount currency names count
  """
  amountCurrencyNames

  """
  Uniq amount currency symbols count
  """
  amountCurrencySymbols

  """
  Uniq amount issuers count
  """
  amountIssuers

  """
  Uniq delivered currency names count
  """
  deliveredCurrencyNames

  """
  Uniq delivered currency symbols count
  """
  deliveredCurrencySymbols

  """
  Uniq delivered issuers count
  """
  deliveredIssuers

  """
  Uniq send max currency names count
  """
  sendMaxCurrencyNames

  """
  Uniq send max currency symbols count
  """
  sendMaxCurrencySymbols

  """
  Uniq send max issuers count
  """
  sendMaxIssuers

  """
  Uniq deliver min currency names count
  """
  deliverMinCurrencyNames

  """
  Uniq deliver min currency symbols count
  """
  deliverMinCurrencySymbols

  """
  Uniq deliver min issuers count
  """
  deliverMinIssuers

  """
  Uniq tags count
  """
  tags

  """
  Uniq invoices count
  """
  invoices

  """
  Uniq flags count
  """
  flags
}

"""
Ripple state in Ripple blockchain
"""
type RippleRippleState {
  any(of: RippleRippleStateMeasurable!): String
  balance(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    lowAccount: AddressSelector
    highAccount: AddressSelector
    currencySymbol: CurrencySelector
    prevTxnId: StringSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    balance: FloatSelector
    prevBalance: FloatSelector
  ): Float

  """
  Block
  """
  block: BigInt
  count(
    uniq: RippleRippleStateUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    lowAccount: AddressSelector
    highAccount: AddressSelector
    currencySymbol: CurrencySelector
    prevTxnId: StringSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    balance: FloatSelector
    prevBalance: FloatSelector
  ): Int
  countBigInt(
    uniq: RippleRippleStateUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    lowAccount: AddressSelector
    highAccount: AddressSelector
    currencySymbol: CurrencySelector
    prevTxnId: StringSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    balance: FloatSelector
    prevBalance: FloatSelector
  ): BigInt

  """
  Currency
  """
  currency: Currency

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Flags
  """
  flags: BigInt

  """
  High account
  """
  highAccount: Address

  """
  Low account
  """
  lowAccount: Address
  maximum(
    of: RippleRippleStateMeasurable!
    get: RippleRippleStateMeasurable
  ): String
  minimum(
    of: RippleRippleStateMeasurable!
    get: RippleRippleStateMeasurable
  ): String

  """
  Operation
  """
  operation: String
  prevBalance(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    operation: StringSelector
    lowAccount: AddressSelector
    highAccount: AddressSelector
    currencySymbol: CurrencySelector
    prevTxnId: StringSelector
    prevLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    balance: FloatSelector
    prevBalance: FloatSelector
  ): Float

  """
  Prev ledger sequence
  """
  prevLedgerSequence: BigInt

  """
  Prev txn
  """
  prevTxnId: String

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transaction
  """
  transaction: RippleTransactionDimension
}

input RippleRippleStateFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  transactionType: StringSelector
  operation: StringSelector
  lowAccount: AddressSelector
  highAccount: AddressSelector
  currencySymbol: CurrencySelector
  prevTxnId: StringSelector
  prevLedgerSequence: BigIntIdSelector
  flags: BigIntIdSelector
  balance: FloatSelector
  prevBalance: FloatSelector
}

enum RippleRippleStateMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction index
  """
  transactionIndex

  """
  Transaction hash
  """
  transactionHash

  """
  Transaction sender
  """
  transactionSender

  """
  Transaction type
  """
  transactionType

  """
  Operation
  """
  operation

  """
  Low account
  """
  lowAccount

  """
  High account
  """
  highAccount

  """
  Currency name
  """
  currencyName

  """
  Currency symbol
  """
  currencySymbol

  """
  Balance
  """
  balance

  """
  Pre balance
  """
  prevBalance

  """
  Prev txn
  """
  prevTxnId

  """
  Prev ledger sequence
  """
  prevLedgerSequence

  """
  Flags
  """
  flags
}

enum RippleRippleStateUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Uniq blocks count
  """
  blocks

  """
  Uniq transaction indices count
  """
  transactionIndices

  """
  Uniq transaction hashes count
  """
  transactionHashes

  """
  Uniq transaction senders count
  """
  transactionSenders

  """
  Uniq transaction types count
  """
  transactionTypes

  """
  Uniq operations count
  """
  operations

  """
  Uniq low accounts count
  """
  lowAccounts

  """
  Uniq high accounts count
  """
  highAccounts

  """
  Uniq currency names count
  """
  currencyNames

  """
  Uniq currency symbols count
  """
  currencySymbols

  """
  Uniq prev txn ids count
  """
  prevTxnIds

  """
  Uniq prev ledger sequences count
  """
  prevLedgerSequences

  """
  Uniq flags count
  """
  flags
}

"""
Token Balance
"""
type RippleTokenBalances {
  """
  The unique Address of the counterparty to this trust line.
  """
  account: String

  """
  Balance
  """
  balance: Float

  """
  Currency
  """
  currency: String
}

"""
Transaction in Ripple blockchain
"""
type RippleTransaction {
  """
  Account txn id
  """
  accountTxnId: String
  any(of: RippleTransactionMeasurable!): String

  """
  Block
  """
  block: BigInt
  count(
    uniq: RippleTransactionUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    index: IntegerSelector
    hash: HashSelector
    sender: AddressSelector
    type: StringSelector
    memos: StringSelector
    sourceTag: BigIntIdSelector
    accountTxnId: AddressSelector
    sequence: BigIntIdSelector
    lastLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    result: StringSelector
    success: BooleanSelector
    fee: FloatSelector
  ): Int
  countBigInt(
    uniq: RippleTransactionUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    index: IntegerSelector
    hash: HashSelector
    sender: AddressSelector
    type: StringSelector
    memos: StringSelector
    sourceTag: BigIntIdSelector
    accountTxnId: AddressSelector
    sequence: BigIntIdSelector
    lastLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    result: StringSelector
    success: BooleanSelector
    fee: FloatSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber
  fee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    index: IntegerSelector
    hash: HashSelector
    sender: AddressSelector
    type: StringSelector
    memos: StringSelector
    sourceTag: BigIntIdSelector
    accountTxnId: AddressSelector
    sequence: BigIntIdSelector
    lastLedgerSequence: BigIntIdSelector
    flags: BigIntIdSelector
    result: StringSelector
    success: BooleanSelector
    fee: FloatSelector
  ): DecimalNumberAsDiv

  """
  Flags
  """
  flags: BigInt

  """
  Hash
  """
  hash: String

  """
  Index
  """
  index: Int

  """
  Last ledger sequence
  """
  lastLedgerSequence: BigInt
  maximum(
    of: RippleTransactionMeasurable!
    get: RippleTransactionMeasurable
  ): String

  """
  Memos
  """
  memos: String
  minimum(
    of: RippleTransactionMeasurable!
    get: RippleTransactionMeasurable
  ): String

  """
  Result
  """
  result: String

  """
  Sender
  """
  sender: Address

  """
  Sequence
  """
  sequence: BigInt

  """
  Source tag
  """
  sourceTag: BigInt

  """
  Success
  """
  success: Boolean

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Tx signers
  """
  txSigners: String

  """
  Type
  """
  type: String
}

"""
Ripple transaction
"""
type RippleTransactionDimension {
  """
  Hash hex representation
  """
  hash: String!

  """
  Transaction index in block
  """
  index: Int!

  """
  Transaction sender
  """
  sender: String

  """
  Transaction type
  """
  type: String
}

input RippleTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  index: IntegerSelector
  hash: HashSelector
  sender: AddressSelector
  type: StringSelector
  memos: StringSelector
  sourceTag: BigIntIdSelector
  accountTxnId: AddressSelector
  sequence: BigIntIdSelector
  lastLedgerSequence: BigIntIdSelector
  flags: BigIntIdSelector
  result: StringSelector
  success: BooleanSelector
  fee: FloatSelector
}

"""
Ripple transaction with hash and index
"""
type RippleTransactionHashIndexDimension {
  """
  Hash hex representation
  """
  hash: String!

  """
  Transaction index in block
  """
  index: Int!
}

enum RippleTransactionMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Index
  """
  index

  """
  Hash
  """
  hash

  """
  Sender
  """
  sender

  """
  Type
  """
  type

  """
  Fee
  """
  fee

  """
  Memos
  """
  memos

  """
  Source tag
  """
  sourceTag

  """
  Account txn id
  """
  accountTxnId

  """
  Sequence
  """
  sequence

  """
  Last ledger sequence
  """
  lastLedgerSequence

  """
  Flags
  """
  flags

  """
  Result
  """
  result

  """
  Success
  """
  success
}

enum RippleTransactionUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq blocks count
  """
  blocks

  """
  Uniq indices count
  """
  indices

  """
  Uniq hashes count
  """
  hashes

  """
  Uniq senders count
  """
  senders

  """
  Uniq types count
  """
  types

  """
  Uniq source tags count
  """
  sourceTags

  """
  Uniq account txn id bins count
  """
  accountTxnIds

  """
  Uniq sequences count
  """
  sequences

  """
  Uniq last ledger sequences count
  """
  lastLedgerSequences

  """
  Uniq flags count
  """
  flags

  """
  Uniq results count
  """
  results
}

"""
Transfer in Ripple blockchain
"""
type RippleTransfer {
  amountFrom(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    sender: AddressSelector
    receiver: AddressSelector
    currencyFromSymbol: CurrencySelector
    currencyToSymbol: CurrencySelector
    direction: StringSelector
    amountFrom: FloatSelector
    amountTo: FloatSelector
  ): Float
  amountTo(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    sender: AddressSelector
    receiver: AddressSelector
    currencyFromSymbol: CurrencySelector
    currencyToSymbol: CurrencySelector
    direction: StringSelector
    amountFrom: FloatSelector
    amountTo: FloatSelector
  ): Float
  any(of: RippleTransferMeasurable!): String

  """
  Block
  """
  block: BigInt
  count(
    uniq: RippleTransferUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    sender: AddressSelector
    receiver: AddressSelector
    currencyFromSymbol: CurrencySelector
    currencyToSymbol: CurrencySelector
    direction: StringSelector
    amountFrom: FloatSelector
    amountTo: FloatSelector
  ): Int
  countBigInt(
    uniq: RippleTransferUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    transactionType: StringSelector
    sender: AddressSelector
    receiver: AddressSelector
    currencyFromSymbol: CurrencySelector
    currencyToSymbol: CurrencySelector
    direction: StringSelector
    amountFrom: FloatSelector
    amountTo: FloatSelector
  ): BigInt

  """
  Currency from
  """
  currencyFrom: Currency

  """
  Currency to
  """
  currencyTo: Currency

  """
  Calendar date
  """
  date: Date

  """
  Direction
  """
  direction: String
  expression(get: String!): DecimalNumber
  maximum(of: RippleTransferMeasurable!, get: RippleTransferMeasurable): String
  minimum(of: RippleTransferMeasurable!, get: RippleTransferMeasurable): String

  """
  Receiver
  """
  receiver: Address

  """
  Sender
  """
  sender: Address

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transaction
  """
  transaction: RippleTransactionDimension
}

input RippleTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  transactionType: StringSelector
  sender: AddressSelector
  receiver: AddressSelector
  currencyFromSymbol: CurrencySelector
  currencyToSymbol: CurrencySelector
  direction: StringSelector
  amountFrom: FloatSelector
  amountTo: FloatSelector
}

enum RippleTransferMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction index
  """
  transactionIndex

  """
  Transaction hash
  """
  transactionHash

  """
  Transaction sender
  """
  transactionSender

  """
  Transaction type
  """
  transactionType

  """
  Sender
  """
  sender

  """
  Receiver
  """
  receiver

  """
  Currency from name
  """
  currencyFromName

  """
  Currency to name
  """
  currencyToName

  """
  Currency from symbol
  """
  currencyFromSymbol

  """
  Currency to symbol
  """
  currencyToSymbol

  """
  Amount from
  """
  amountFrom

  """
  Amount to
  """
  amountTo

  """
  Direction
  """
  direction
}

enum RippleTransferUniq {
  """
  Uniq times count
  """
  times

  """
  Uniq dates count
  """
  dates

  """
  Uniq blocks count
  """
  blocks

  """
  Uniq transaction indices count
  """
  transactionIndices

  """
  Uniq transaction hashes count
  """
  transactionHashes

  """
  Uniq transaction senders count
  """
  transactionSenders

  """
  Uniq transaction types count
  """
  transactionTypes

  """
  Uniq senders count
  """
  senders

  """
  Uniq receivers count
  """
  receivers

  """
  Uniq currencies from name count
  """
  currencyFromNames

  """
  Uniq currencies to name count
  """
  currencyToNames

  """
  Uniq currencies from symbol count
  """
  currencyFromSymbols

  """
  Uniq currencies to symbol count
  """
  currencyToSymbols

  """
  Uniq directions count
  """
  directions
}

"""
Smart contract crypto currency ( token, coin, currency )
"""
type ScCurrency {
  """
  Decimals
  """
  decimals: Int!

  """
  Currency name
  """
  name: String

  """
  Currency symbol
  """
  symbol: String!

  """
  Token Type
  """
  tokenType: String
}

enum ScriptTypeSelectorSelector {
  """
  Unknown Transaction
  """
  unknown_transaction

  """
  Peer-to-peer
  """
  peer_to_peer_transaction
}

input SeedOptions {
  """
  Invalidating cache seed
  """
  seed: Int
}

"""
Solana Sender
"""
type Sender {
  address: String!
  mintAccount: String!
  type: String!
}

"""
Smart contract method or event
"""
union Signature = Event | Method

enum SignatureTypeSelector {
  """
  Smart contract method
  """
  Function

  """
  Smart contract event
  """
  Event
}

"""
Blockchain smart contract
"""
type SmartContract {
  """
  String address representation
  """
  address: String

  """
  Annotations ( tags ), if exists
  """
  annotation: String

  """
  Smart Contract Type
  """
  contractType: SmartContractType!

  """
  Smart Contract Protocol Type
  """
  protocol: String
}

enum SmartContractArgumentsUniq {
  """
  Unique signatures count
  """
  signatures

  """
  Unique values
  """
  values

  """
  Calls or events
  """
  calls

  """
  Unique transactions count
  """
  txs

  """
  Unique transaction senders
  """
  senders

  """
  Unique callers count
  """
  callers

  """
  Unique smart contracts count
  """
  smart_contracts

  """
  Unique blocks
  """
  blocks

  """
  Unique date count
  """
  dates
}

enum SmartContractCallsUniq {
  """
  Calls
  """
  calls

  """
  Unique transactions count
  """
  txs

  """
  Unique transaction senders
  """
  senders

  """
  Unique callers count
  """
  callers

  """
  Unique smart contracts count
  """
  smart_contracts

  """
  Unique smart contract methods count
  """
  smart_contract_methods

  """
  Unique blocks
  """
  blocks

  """
  Unique date count
  """
  dates
}

enum SmartContractEventsUniq {
  """
  Unique blocks
  """
  blocks

  """
  Unique date count
  """
  dates

  """
  Unique transactions count
  """
  txs

  """
  Unique callers count
  """
  tx_to

  """
  Unique transaction senders
  """
  tx_from

  """
  Unique smart contracts count
  """
  smart_contracts

  """
  Unique smart contract methods count
  """
  smart_contract_methods

  """
  Shard ID
  """
  shard_id

  """
  To Shard ID
  """
  to_shard_id
}

"""
Blockchain smart contract
"""
type SmartContractInfo {
  """
  Smart Contract Type
  """
  contractType: SmartContractType

  """
  Token implemented in this smart contract
  """
  currency: ScCurrency

  """
  Smart Contract Protocol Type
  """
  protocolType: String
}

type SmartContractReadonlyAttribute {
  """
  Value as address if applicable
  """
  address: EthereumAddressInfo

  """
  Method name
  """
  name: String!

  """
  Method return type
  """
  type: String!

  """
  Method return value
  """
  value: String!
}

enum SmartContractType {
  """
  Not A Smart contract
  """
  None

  """
  General Purpose Smart contract
  """
  Generic

  """
  Smart contract for token derivatives
  """
  MarginPositionToken

  """
  Multi signature wallet
  """
  Multisig

  """
  Token
  """
  Token

  """
  Token Sale
  """
  TokenSale

  """
  Decentralized exchange
  """
  DEX

  """
  Transaction Execution Approval Language
  """
  TEAL
}

"""
Selector of smart contract type
"""
input SmartContractTypeSelector {
  """
  Smart Contract type is
  """
  is: SmartContractType

  """
  Smart Contract type not
  """
  not: SmartContractType

  """
  Smart Contract type in the list
  """
  in: [SmartContractType!]

  """
  Smart Contract type not in the list
  """
  notIn: [SmartContractType!]
}

"""
Solana Chain
"""
type Solana {
  """
  Basic information about address
  """
  address(address: [AddressSelectorIn!]!): [SolanaAddressInfoWithBalance!]!

  """
  BlockRewards of Smart Contract Calls and Events
  """
  blockRewards(
    date: DateSelector
    blockHash: HashSelector
    height: BlockSelector
    previousBlockHash: HashSelector
    reward: AmountSelector
    parentSlot: IntegerSelector
    postBalance: AmountSelector
    account: StringSelector
    rewardType: RewardTypeSelector
    any: [SolanaBlockRewardFilter!]
    options: QueryOptions
  ): [SolanaBlockReward!]

  """
  Solana Blocks
  """
  blocks(
    date: DateSelector
    blockHash: HashSelector
    height: BlockSelector
    previousBlockHash: HashSelector
    parentSlot: IntegerSelector
    transactionCount: IntegerSelector
    rewards: AmountSelector
    any: [SolanaBlockFilter!]
    options: QueryOptions
  ): [SolanaBlock!]

  """
  Money flow using Coinpath technology
  """
  coinpath(
    sender: AddressSelector
    receiver: AddressSelector
    currency: CurrencySelector
    initialAddress: AddressSelector
    initialDate: DateSelector
    initialTime: DateTimeSelector
    date: DateSelector
    time: DateTimeSelector
    depth: IntegerLimitedSelector
    options: CoinpathOptions
  ): [SolanaCoinpath!]

  """
  Each instruction specifies a single program, a subset of the transaction`s accounts
          that should be passed to the program.
  """
  instructionAccounts(
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    height: BlockSelector
    previousBlockHash: HashSelector
    transactionIndex: IntegerSelector
    signature: StringSelector
    feePayer: HashSelector
    success: BooleanSelector
    programId: StringSelector
    parsedProgramName: StringSelector
    parsed: IntegerSelector
    parsedActionName: StringSelector
    parsedType: StringSelector
    external: IntegerSelector
    callPath: StringSelector
    fee: IntegerSelector
    account: StringSelector
    accountType: StringSelector
    accountOwner: StringSelector
    accountIndex: IntegerSelector
    any: [SolanaInstructionAccountFilter!]
    options: QueryOptions
  ): [SolanaInstructionAccount!]

  """
  Each instruction specifies a single program, a subset of the transaction`s accounts
          that should be passed to the program.
  """
  instructions(
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    height: BlockSelector
    previousBlockHash: HashSelector
    transactionIndex: IntegerSelector
    signature: StringSelector
    feePayer: HashSelector
    success: BooleanSelector
    programId: StringSelector
    parsedProgramName: StringSelector
    parsed: IntegerSelector
    externalParsed: IntegerSelector
    externalProgramId: StringSelector
    externalParsedProgramName: StringSelector
    parsedActionName: StringSelector
    externalParsedActionName: StringSelector
    parsedType: StringSelector
    externalParsedType: StringSelector
    external: IntegerSelector
    callPath: StringSelector
    fee: IntegerSelector
    any: [SolanaInstructionFilter!]
    options: QueryOptions
  ): [SolanaInstruction!]

  """
  Solana Transaction
  """
  transactions(
    date: DateSelector
    blockHash: HashSelector
    height: BlockSelector
    previousBlockHash: HashSelector
    recentBlockHash: HashSelector
    parentSlot: BlockSelector
    instructionsCount: IntegerSelector
    innerInstructionsCount: IntegerSelector
    accountsCount: IntegerSelector
    transactionIndex: IntegerSelector
    signature: HashSelector
    feePayer: HashSelector
    success: BooleanSelector
    fee: IntegerSelector
    signer: HashSelector
    transactionFee: AmountSelector
    any: [SolanaTransactionFilter!]
    options: QueryOptions
  ): [SolanaTransaction!]

  """
  Currency transfers from/to addresses in crypto currencies
  """
  transfers(
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    height: BlockSelector
    previousBlockHash: HashSelector
    recentBlockHash: HashSelector
    transactionIndex: IntegerSelector
    signature: HashSelector
    feePayer: HashSelector
    signer: HashSelector
    success: BooleanSelector
    programId: StringSelector
    parsedProgramName: StringSelector
    externalProgramId: StringSelector
    externalParsedProgramName: StringSelector
    parsed: IntegerSelector
    externalParsed: IntegerSelector
    parsedActionName: StringSelector
    externalParsedActionName: StringSelector
    parsedType: StringSelector
    externalParsedType: StringSelector
    external: StringSelector
    callPath: StringSelector
    senderAddress: StringSelector
    senderMintAddress: StringSelector
    senderType: StringSelector
    receiverAddress: StringSelector
    receiverMintAddress: StringSelector
    receiverType: StringSelector
    transferType: SolanaTransferTypeSelector
    amount: [AmountSelector!]
    tokenAccount: [StringSelector!]
    currency: [SolanaCurrencySelector!]
    any: [SolanaTransferFilter!]
    options: QueryOptions
  ): [SolanaTransfer!]
}

"""
Solana Account
"""
type SolanaAccount {
  index: Int!
  name: String!
  owner: String!
  type: String!
}

"""
Blockchain address
"""
type SolanaAddressInfoWithBalance {
  """
  Address
  """
  address: String

  """
  Annotations ( tags ), if exists
  """
  annotation: String

  """
  Current address balance
  """
  balance(in: BaseCurrencyEnum): Float

  """
  Smart Contract if exists on the address
  """
  smartContract: SmartContractInfo
}

"""
Block in Solana  blockchain
"""
type SolanaBlock {
  any(of: SolanaBlockMeasureable!): String

  """
  Hash of the the block
  """
  blockHash(blockHash: HashSelector): String
  count(uniq: SolanaBlockUniq): Int
  countBigInt(uniq: SolanaBlockUniq): BigInt

  """
  The date this transaction was created
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Number of block in the blockchains
  """
  height(height: BlockSelector): BigInt
  maximum(of: SolanaBlockMeasureable!, get: SolanaBlockMeasureable): String
  minimum(of: SolanaBlockMeasureable!, get: SolanaBlockMeasureable): String

  """
  The slot index of this block`s parent
  """
  parentSlot(parentSlot: IntegerSelector): BigInt

  """
  The block hash of this block`s parent
  """
  previousBlockHash(previousBlockHash: HashSelector): String
  rewards(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    blockHash: HashSelector
    height: BlockSelector
    previousBlockHash: HashSelector
    parentSlot: IntegerSelector
    transactionCount: IntegerSelector
    rewards: AmountSelector
  ): Float

  """
  The time this transaction was created
  """
  time: DateTime

  """
  Count of transactions in this block
  """
  transactionCount(transactionCount: IntegerSelector): Int
}

input SolanaBlockFilter {
  date: DateSelector
  blockHash: HashSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  parentSlot: IntegerSelector
  transactionCount: IntegerSelector
  rewards: AmountSelector
}

"""
Solana Block Info
"""
type SolanaBlockInfo {
  """
  Hash hex representation
  """
  hash: String!

  """
  Block number (height) in blockchain
  """
  height: Int!
  parentSlot: BigInt
  previousBlockHash: String

  """
  Block timestamp
  """
  timestamp: DateTime
}

enum SolanaBlockMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Hash of the the block
  """
  block_hash

  """
  Number of block in the blockhains
  """
  height

  """
  The block hash of this block`s parent
  """
  previous_block_hash

  """
  Number of reward lamports credited or debited by the account
  """
  rewards

  """
  The slot index of this block`s parent
  """
  parent_slot

  """
  Count of transactions in this block
  """
  transaction_count
}

"""
BlockReward in Solana  blockchain
"""
type SolanaBlockReward {
  """
  Account
  """
  account(account: HashSelector): String
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    blockHash: HashSelector
    height: BlockSelector
    previousBlockHash: HashSelector
    reward: AmountSelector
    parentSlot: IntegerSelector
    postBalance: AmountSelector
    account: StringSelector
    rewardType: RewardTypeSelector
  ): Float
  any(of: SolanaBlockRewardMeasureable!): String

  """
  Block where  transaction is included
  """
  block(
    height: BlockSelector
    hash: HashSelector
    time: DateTimeSelector
    previousBlockHash: HashSelector
    parentSlot: StringSelector
  ): SolanaBlockInfo
  count(uniq: SolanaBlockRewardUniq): Int
  countBigInt(uniq: SolanaBlockRewardUniq): BigInt

  """
  Currency of transfer
  """
  currency: Currency

  """
  The date this transaction was created
  """
  date: Date
  expression(get: String!): DecimalNumber
  maximum(
    of: SolanaBlockRewardMeasureable!
    get: SolanaBlockRewardMeasureable
  ): String
  minimum(
    of: SolanaBlockRewardMeasureable!
    get: SolanaBlockRewardMeasureable
  ): String
  postBalance(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    blockHash: HashSelector
    height: BlockSelector
    previousBlockHash: HashSelector
    reward: AmountSelector
    parentSlot: IntegerSelector
    postBalance: AmountSelector
    account: StringSelector
    rewardType: RewardTypeSelector
  ): Float

  """
  Type of reward
  """
  rewardType(rewardType: RewardTypeSelector): String

  """
  The time this transaction was created
  """
  time: DateTime
}

input SolanaBlockRewardFilter {
  date: DateSelector
  blockHash: HashSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  reward: AmountSelector
  parentSlot: IntegerSelector
  postBalance: AmountSelector
  account: StringSelector
  rewardType: RewardTypeSelector
}

enum SolanaBlockRewardMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Hash of the the block
  """
  block_hash

  """
  Number of block in the blockhains
  """
  height

  """
  The block hash of this block`s parent
  """
  previous_block_hash

  """
  Number of reward lamports credited or debited by the account
  """
  amount

  """
  The slot index of this block`s parent
  """
  parent_slot

  """
  Account balances after the transaction was processed
  """
  post_balance

  """
  Account
  """
  account
}

enum SolanaBlockRewardUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique hash of the the block
  """
  block_hash

  """
  Unique accounts
  """
  account

  """
  Unique currencies
  """
  currencies
}

enum SolanaBlockUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique Number of block in the blockchains
  """
  height
}

"""
Solana Coinpath
"""
type SolanaCoinpath {
  """
  Summary of transfered value
  """
  amount(in: BaseCurrencyEnum): Float
  any(of: SolanaCoinpathMeasureable!): String

  """
  Block where transaction is included
  """
  block: Block

  """
  Count of transfers
  """
  count: Int

  """
  Count of transfers
  """
  countBigInt: BigInt

  """
  Currency of transfer
  """
  currency: Currency

  """
  1-based hop depth of the graph
  """
  depth: Int
  maximum(
    of: SolanaCoinpathMeasureable!
    get: SolanaCoinpathMeasureable
  ): String
  minimum(
    of: SolanaCoinpathMeasureable!
    get: SolanaCoinpathMeasureable
  ): String

  """
  Receiver address
  """
  receiver: Address

  """
  Sender address
  """
  sender: Address

  """
  Transaction of transfer happened
  """
  signature: SolanaSignatureValueDimension
}

enum SolanaCoinpathMeasureable {
  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Signature
  """
  signature

  """
  Sender
  """
  sender

  """
  Receiver
  """
  receiver

  """
  Depth
  """
  depth
}

"""
Crypto currency ( token, coin, currency )
"""
type SolanaCryptoCurrency {
  """
  Token Smart Contract Address
  """
  address: String

  """
  Decimals
  """
  decimals: Int!

  """
  Currency name
  """
  name: String

  """
  Currency symbol
  """
  symbol: String!

  """
  Token ID
  """
  tokenId: String

  """
  Token Type
  """
  tokenType: String
}

"""
Currency is defined by a mint address. Solana coin defined as 'SOL'. You can use
filter bby symbol, bbut it only works if there is just one token with that symbol
"""
input SolanaCurrencySelector {
  """
  Currency is
  """
  is: String

  """
  Currency not
  """
  not: String

  """
  Currency in the list
  """
  in: [String!]

  """
  Currency not in the list
  """
  notIn: [String!]
}

"""
Instruction in Solana  blockchain
"""
type SolanaInstruction {
  """
  Accounts count
  """
  accountsCount: Int

  """
  Action
  """
  action(parsedActionName: StringSelector, parsedType: StringSelector): Action
  any(of: SolanaInstructionMeasureable!): String

  """
  Block where  transaction is included
  """
  block(
    height: BlockSelector
    blockHash: HashSelector
    time: DateTimeSelector
  ): SolanaBlockInfo

  """
  Call Path
  """
  callPath(callPath: StringSelector): String
  count(uniq: SolanaInstructionUniq): Int
  countBigInt(uniq: SolanaInstructionUniq): BigInt

  """
  Instruction Data
  """
  data(dataBase58: StringSelector, dataHex: StringSelector): Data

  """
  The date this transaction was created
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  External
  """
  external(external: BooleanSelector): Boolean

  """
  External Action
  """
  externalAction(
    externalParsedActionName: StringSelector
    externalParsedType: StringSelector
  ): Action

  """
  External Program
  """
  externalProgram(
    externalProgramId: StringSelector
    externalProgramName: StringSelector
    externalParsedProgramName: StringSelector
  ): Program
  log: Log
  maximum(
    of: SolanaInstructionMeasureable!
    get: SolanaInstructionMeasureable
  ): String
  minimum(
    of: SolanaInstructionMeasureable!
    get: SolanaInstructionMeasureable
  ): String

  """
  Program
  """
  program(
    programId: StringSelector
    programName: StringSelector
    parsedProgramName: StringSelector
  ): Program

  """
  Transaction where instruction is included
  """
  transaction(signature: HashSelector): SolanaTransactionInfo
}

"""
InstructionAccount in Solana  blockchain
"""
type SolanaInstructionAccount {
  """
  Information about account
  """
  account(
    accountName: StringSelector
    accountOwner: StringSelector
    accountType: StringSelector
    accountIndex: IntegerSelector
  ): SolanaAccount
  any(of: SolanaInstructionAccountMeasureable!): String

  """
  Block where transfer transaction is included
  """
  block(
    height: BlockSelector
    blockHash: HashSelector
    time: DateTimeSelector
  ): SolanaBlockInfo
  count(uniq: SolanaInstructionAccountUniq): Int
  countBigInt(uniq: SolanaInstructionAccountUniq): BigInt

  """
  The date this transaction was created
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Instruction
  """
  instruction: Instruction
  maximum(
    of: SolanaInstructionAccountMeasureable!
    get: SolanaInstructionAccountMeasureable
  ): String
  minimum(
    of: SolanaInstructionAccountMeasureable!
    get: SolanaInstructionAccountMeasureable
  ): String

  """
  Transaction
  """
  transaction(
    transactionIndex: IntegerSelector
    signature: HashSelector
  ): SolanaTransactionInfo
}

input SolanaInstructionAccountFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  transactionIndex: IntegerSelector
  signature: StringSelector
  feePayer: HashSelector
  success: BooleanSelector
  programId: StringSelector
  parsedProgramName: StringSelector
  parsed: IntegerSelector
  parsedActionName: StringSelector
  parsedType: StringSelector
  external: IntegerSelector
  callPath: StringSelector
  fee: IntegerSelector
  account: StringSelector
  accountType: StringSelector
  accountOwner: StringSelector
  accountIndex: IntegerSelector
}

enum SolanaInstructionAccountMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Hash of the the block
  """
  block_hash

  """
  Number of block in the blockhains
  """
  height

  """
  The block hash of this block`s parent
  """
  previous_block_hash

  """
  Transaction Hash
  """
  signature
}

enum SolanaInstructionAccountUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Number of block in the blockchains
  """
  height

  """
  Transaction Hash
  """
  signature

  """
  Account name
  """
  account_name
}

input SolanaInstructionFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  transactionIndex: IntegerSelector
  signature: StringSelector
  feePayer: HashSelector
  success: BooleanSelector
  programId: StringSelector
  parsedProgramName: StringSelector
  parsed: IntegerSelector
  externalParsed: IntegerSelector
  externalProgramId: StringSelector
  externalParsedProgramName: StringSelector
  parsedActionName: StringSelector
  externalParsedActionName: StringSelector
  parsedType: StringSelector
  externalParsedType: StringSelector
  external: IntegerSelector
  callPath: StringSelector
  fee: IntegerSelector
}

enum SolanaInstructionMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Hash of the the block
  """
  block_hash

  """
  Number of block in the blockhains
  """
  height

  """
  The block hash of this block`s parent
  """
  previous_block_hash

  """
  Transaction Hash
  """
  signature

  """
  Transaction Fee
  """
  fee
}

enum SolanaInstructionUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Number of block in the blockchains
  """
  height

  """
  Transaction Hash
  """
  signature
}

enum SolanaNetwork {
  """
  Solana Mainnat
  """
  solana
}

enum SolanaRewardType {
  """
  fee type
  """
  Fee

  """
  rent type
  """
  Rent

  """
  voing type
  """
  Voting

  """
  staking type
  """
  Staking
}

"""
Blockchain transaction with value
"""
type SolanaSignatureValueDimension {
  """
  Transaction hash
  """
  hash: String!

  """
  Transaction value
  """
  value: Float!
}

"""
Transaction in Solana  blockchain
"""
type SolanaTransaction {
  """
  Count of inner instructions
  """
  accountsCount(accountsCount: IntegerSelector): Int
  any(of: SolanaTransactionMeasureable!): String

  """
  Block where  transaction is included
  """
  block(
    height: BlockSelector
    hash: HashSelector
    time: DateTimeSelector
  ): SolanaBlockInfo
  count(uniq: SolanaTransactionUniq): Int
  countBigInt(uniq: SolanaTransactionUniq): BigInt

  """
  The date this transaction was created
  """
  date: Date

  """
  Error
  """
  error(error: StringSelector): String
  expression(get: String!): DecimalNumber

  """
  Fee Payer
  """
  feePayer(feePayer: HashSelector): String

  """
  Count of inner instructions
  """
  innerInstructionsCount(innerInstructionsCount: IntegerSelector): Int

  """
  Count of instructions
  """
  instructionsCount(instructionsCount: IntegerSelector): Int
  maximum(
    of: SolanaTransactionMeasureable!
    get: SolanaTransactionMeasureable
  ): String
  minimum(
    of: SolanaTransactionMeasureable!
    get: SolanaTransactionMeasureable
  ): String

  """
  Recent blockhash prevents duplication and to give transactions lifetimes
  """
  recentBlockHash(recentBlockHash: HashSelector): String

  """
  Transaction Hash
  """
  signature(signature: HashSelector): String

  """
  Accounts` public keys
  """
  signer(signer: HashSelector): String

  """
  Successed or failed
  """
  success(success: BooleanSelector): Boolean
  transactionFee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    blockHash: HashSelector
    height: BlockSelector
    previousBlockHash: HashSelector
    recentBlockHash: HashSelector
    parentSlot: BlockSelector
    instructionsCount: IntegerSelector
    innerInstructionsCount: IntegerSelector
    accountsCount: IntegerSelector
    transactionIndex: IntegerSelector
    signature: HashSelector
    feePayer: HashSelector
    success: BooleanSelector
    fee: IntegerSelector
    signer: HashSelector
    transactionFee: AmountSelector
  ): Float

  """
  Transaction Index
  """
  transactionIndex(transactionIndex: IntegerSelector): Int
}

input SolanaTransactionFilter {
  date: DateSelector
  blockHash: HashSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  recentBlockHash: HashSelector
  parentSlot: BlockSelector
  instructionsCount: IntegerSelector
  innerInstructionsCount: IntegerSelector
  accountsCount: IntegerSelector
  transactionIndex: IntegerSelector
  signature: HashSelector
  feePayer: HashSelector
  success: BooleanSelector
  fee: IntegerSelector
  signer: HashSelector
  transactionFee: AmountSelector
}

"""
Solana Transaction Info
"""
type SolanaTransactionInfo {
  feePayer: String
  signature: String
  success: Boolean
  transactionIndex: BigInt
}

"""
Solana Transaction Info Extended
"""
type SolanaTransactionInfoExt {
  accountsCount: Int
  error: String
  fee: Float
  feePayer: String
  innerInstructionsCount: Int
  instructionsCount: Int
  recentBlockHash: String
  signature: String
  signer: String
  success: Boolean
  transactionIndex: BigInt
}

enum SolanaTransactionMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Hash of the the block
  """
  block_hash

  """
  Number of block in the blockhains
  """
  height

  """
  The block hash of this block`s parent
  """
  previous_block_hash

  """
  The slot index of this block`s parent
  """
  parent_slot

  """
  Transaction Hash
  """
  signature

  """
  Transaction Fee
  """
  fee

  """
  Transaction Fee
  """
  transaction_fee
}

enum SolanaTransactionUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Number of block in the blockchains
  """
  height

  """
  Transaction Hash
  """
  signature

  """
  Accounts` public key
  """
  signer
}

"""
Currency transfers from/to addresses in crypto currencies
"""
type SolanaTransfer {
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    height: BlockSelector
    previousBlockHash: HashSelector
    recentBlockHash: HashSelector
    transactionIndex: IntegerSelector
    signature: HashSelector
    feePayer: HashSelector
    signer: HashSelector
    success: BooleanSelector
    programId: StringSelector
    parsedProgramName: StringSelector
    externalProgramId: StringSelector
    externalParsedProgramName: StringSelector
    parsed: IntegerSelector
    externalParsed: IntegerSelector
    parsedActionName: StringSelector
    externalParsedActionName: StringSelector
    parsedType: StringSelector
    externalParsedType: StringSelector
    external: StringSelector
    callPath: StringSelector
    senderAddress: StringSelector
    senderMintAddress: StringSelector
    senderType: StringSelector
    receiverAddress: StringSelector
    receiverMintAddress: StringSelector
    receiverType: StringSelector
    transferType: SolanaTransferTypeSelector
    amount: [AmountSelector!]
    tokenAccount: [StringSelector!]
    currency: [SolanaCurrencySelector!]
  ): Float
  any(of: SolanaTransferMeasureable!): String

  """
  Block where transfer transaction is included
  """
  block(
    height: BlockSelector
    hash: HashSelector
    time: DateTimeSelector
  ): SolanaBlockInfo
  count(
    uniq: SolanaTransferUniq
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    height: BlockSelector
    previousBlockHash: HashSelector
    recentBlockHash: HashSelector
    transactionIndex: IntegerSelector
    signature: HashSelector
    feePayer: HashSelector
    signer: HashSelector
    success: BooleanSelector
    programId: StringSelector
    parsedProgramName: StringSelector
    externalProgramId: StringSelector
    externalParsedProgramName: StringSelector
    parsed: IntegerSelector
    externalParsed: IntegerSelector
    parsedActionName: StringSelector
    externalParsedActionName: StringSelector
    parsedType: StringSelector
    externalParsedType: StringSelector
    external: StringSelector
    callPath: StringSelector
    senderAddress: StringSelector
    senderMintAddress: StringSelector
    senderType: StringSelector
    receiverAddress: StringSelector
    receiverMintAddress: StringSelector
    receiverType: StringSelector
    transferType: SolanaTransferTypeSelector
    amount: [AmountSelector!]
    tokenAccount: [StringSelector!]
    currency: [SolanaCurrencySelector!]
  ): Int
  countBigInt(
    uniq: SolanaTransferUniq
    date: DateSelector
    time: DateTimeSelector
    blockHash: HashSelector
    height: BlockSelector
    previousBlockHash: HashSelector
    recentBlockHash: HashSelector
    transactionIndex: IntegerSelector
    signature: HashSelector
    feePayer: HashSelector
    signer: HashSelector
    success: BooleanSelector
    programId: StringSelector
    parsedProgramName: StringSelector
    externalProgramId: StringSelector
    externalParsedProgramName: StringSelector
    parsed: IntegerSelector
    externalParsed: IntegerSelector
    parsedActionName: StringSelector
    externalParsedActionName: StringSelector
    parsedType: StringSelector
    externalParsedType: StringSelector
    external: StringSelector
    callPath: StringSelector
    senderAddress: StringSelector
    senderMintAddress: StringSelector
    senderType: StringSelector
    receiverAddress: StringSelector
    receiverMintAddress: StringSelector
    receiverType: StringSelector
    transferType: SolanaTransferTypeSelector
    amount: [AmountSelector!]
    tokenAccount: [StringSelector!]
    currency: [SolanaCurrencySelector!]
  ): BigInt

  """
  Currency of transfer
  """
  currency: SolanaCryptoCurrency

  """
  The date this transaction was created
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Instruction where transfer is included
  """
  instruction: InstructionWithExternals
  maximum(
    of: SolanaTransferMeasureable!
    get: SolanaTransferMeasureable
  ): String
  minimum(
    of: SolanaTransferMeasureable!
    get: SolanaTransferMeasureable
  ): String

  """
  Receiver
  """
  receiver: Receiver

  """
  Sender
  """
  sender: Sender

  """
  Transaction where transfer is included
  """
  transaction(signature: HashSelector): SolanaTransactionInfoExt

  """
  Transfer Type
  """
  transferType(transferType: SolanaTransferTypeSelector): String
}

input SolanaTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  recentBlockHash: HashSelector
  transactionIndex: IntegerSelector
  signature: HashSelector
  feePayer: HashSelector
  signer: HashSelector
  success: BooleanSelector
  programId: StringSelector
  parsedProgramName: StringSelector
  externalProgramId: StringSelector
  externalParsedProgramName: StringSelector
  parsed: IntegerSelector
  externalParsed: IntegerSelector
  parsedActionName: StringSelector
  externalParsedActionName: StringSelector
  parsedType: StringSelector
  externalParsedType: StringSelector
  external: StringSelector
  callPath: StringSelector
  senderAddress: StringSelector
  senderMintAddress: StringSelector
  senderType: StringSelector
  receiverAddress: StringSelector
  receiverMintAddress: StringSelector
  receiverType: StringSelector
  transferType: SolanaTransferTypeSelector
  amount: [AmountSelector!]
  tokenAccount: [StringSelector!]
  currency: [SolanaCurrencySelector!]
}

enum SolanaTransferMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Hash of the the block
  """
  block_hash

  """
  Number of block in the blockhains
  """
  height

  """
  The block hash of this block`s parent
  """
  previous_block_hash

  """
  Transaction Hash
  """
  signature

  """
  Transaction Fee
  """
  fee_payer

  """
  Transfer Type
  """
  transfer_type

  """
  Amount Transfer
  """
  amount

  """
  Currency Symbol
  """
  currency_symbol

  """
  Currency Name
  """
  currency_name

  """
  Token Type
  """
  token_type

  """
  Token ID
  """
  token_id
}

enum SolanaTransferType {
  """
  Transfer
  """
  transfer

  """
  Self
  """
  self

  """
  Mint
  """
  mint

  """
  Create Account
  """
  create_account

  """
  Close Account
  """
  close_account

  """
  Rent Exemption
  """
  rent_exemption

  """
  Stake
  """
  stake

  """
  Stake Withdraw
  """
  stake_withdraw

  """
  Trade Unknown
  """
  trade_unknown

  """
  Burn
  """
  burn

  """
  Vote
  """
  vote

  """
  Nonce Withdraw
  """
  nonce_withdraw
}

"""
Select by transfer type
"""
input SolanaTransferTypeSelector {
  """
  Type is
  """
  is: SolanaTransferType

  """
  Type not
  """
  not: SolanaTransferType

  """
  Type in the list
  """
  in: [SolanaTransferType!]

  """
  Type not in the list
  """
  notIn: [SolanaTransferType!]
}

enum SolanaTransferUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Number of block in the blockchains
  """
  height

  """
  Transaction Hash
  """
  signature

  """
  Fee Payer
  """
  fee_payer

  """
  Signer
  """
  signer

  """
  Transfer From
  """
  sender_address

  """
  Transfer To
  """
  receiver_address

  """
  Transfer From Mint Address
  """
  sender_mint_address

  """
  Transfer To Mint Address
  """
  receiver_mint_address

  """
  Currencies
  """
  currencies

  """
  Token Account Address
  """
  token_account
}

enum StakingTransactionsTypeEnum {
  CreateValidator
  EditValidator
  CollectRewards
  Undelegate
  Delegate
}

"""
Indicates what type of operation the transaction is supposed to do.
"""
input StakingTransactionsTypeSelector {
  """
  Type is
  """
  is: StakingTransactionsTypeEnum

  """
  Type not
  """
  not: StakingTransactionsTypeEnum

  """
  Type in the list
  """
  in: [StakingTransactionsTypeEnum!]

  """
  Type not in the list
  """
  notIn: [StakingTransactionsTypeEnum!]
}

"""
Stellar Chain
"""
type Stellar {
  """
  Basic information about address
  """
  address(address: [AddressSelectorIn!]!): [StellarAddressInfo!]!

  """
  Blockchain Address Statistics
  """
  addressStats(
    address: AddressSelector!
    options: QueryOptions
  ): [StellarAddressStats!]

  """
  Stellar Balance Effects
  """
  balanceEffects(
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    address: AddressSelector
    currencyName: CurrencySelector
    issuer: AddressSelector
    amount: FloatSelector
    any: [StellarBalanceEffectFilter!]
    options: QueryOptions
  ): [StellarBalanceEffect!]

  """
  Stellar Ledgers
  """
  blocks(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    maxTxSetSize: IntegerSelector
    protocolVersion: IntegerSelector
    totalCoins: FloatSelector
    feePool: FloatSelector
    baseFee: FloatSelector
    baseReserve: FloatSelector
    any: [StellarBlockFilter!]
    options: QueryOptions
  ): [StellarBlock!]

  """
  Stellar Claimable Balance Effects
  """
  claimableBalanceEffects(
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effect: StringSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    sponsor: AddressSelector
    claimant: AddressSelector
    currencyName: CurrencySelector
    issuer: AddressSelector
    balanceId: StringSelector
    amount: FloatSelector
    any: [StellarClaimableBalanceEffectFilter!]
    options: QueryOptions
  ): [StellarClaimableBalanceEffect!]

  """
  Money flow using Coinpath technology
  """
  coinpath(
    sender: AddressSelector
    receiver: AddressSelector
    currencyFrom: CurrencySelector
    currencyTo: CurrencySelector
    initialAddress: AddressSelector
    initialDate: DateSelector
    initialTime: DateTimeSelector
    date: DateSelector
    time: DateTimeSelector
    depth: IntegerLimitedSelector
    options: CoinpathOptions
  ): [StellarCoinpath!]

  """
  Stellar Effect Arguments
  """
  effectArguments(
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effect: StringSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    address: AddressSelector
    argname: StringSelector
    argvalue: StringSelector
    any: [StellarEffectArgumentFilter!]
    options: QueryOptions
  ): [StellarEffectArgument!]

  """
  Stellar Effects
  """
  effects(
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effect: StringSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    details: StringSelector
    address: AddressSelector
    any: [StellarEffectFilter!]
    options: QueryOptions
  ): [StellarEffect!]

  """
  Stellar Liquidity Pool Effects
  """
  liquidityPoolEffects(
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effect: StringSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    currencyName: CurrencySelector
    issuer: AddressSelector
    liquidityPoolId: StringSelector
    liquidityPoolDetails: StringSelector
    amount: FloatSelector
    shares: FloatSelector
    any: [StellarLiquidityPoolEffectFilter!]
    options: QueryOptions
  ): [StellarLiquidityPoolEffect!]

  """
  Stellar Liquidity Pool Trade Effects
  """
  liquidityPoolTradeEffects(
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    address: AddressSelector
    buyCurrencyName: CurrencySelector
    buyIssuer: AddressSelector
    sellCurrencyName: CurrencySelector
    sellIssuer: AddressSelector
    liquidityPoolId: StringSelector
    liquidityPoolDetails: StringSelector
    buyAmount: FloatSelector
    sellAmount: FloatSelector
    any: [StellarLiquidityPoolTradeEffectFilter!]
    options: QueryOptions
  ): [StellarLiquidityPoolTradeEffect!]

  """
  Stellar Operations
  """
  operations(
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    index: IntegerSelector
    sourceAccount: AddressSelector
    details: StringSelector
    success: BooleanSelector
    any: [StellarOperationFilter!]
    options: QueryOptions
  ): [StellarOperation!]

  """
  Stellar Payments
  """
  payments(
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    receiver: AddressSelector
    sender: AddressSelector
    currencyFromName: CurrencySelector
    currencyToName: CurrencySelector
    issuerFrom: AddressSelector
    issuerTo: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    path: StringSelector
    success: BooleanSelector
    amountFrom: FloatSelector
    amountTo: FloatSelector
    minValueTo: FloatSelector
    maxValueFrom: FloatSelector
    debitedFromValue: FloatSelector
    creditedToValue: FloatSelector
    any: [StellarPaymentFilter!]
    options: QueryOptions
  ): [StellarPayment!]

  """
  Stellar Trade Effects
  """
  tradeEffects(
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    address: AddressSelector
    seller: AddressSelector
    buyCurrencyName: CurrencySelector
    buyIssuer: AddressSelector
    sellCurrencyName: CurrencySelector
    sellIssuer: AddressSelector
    offerId: IntegerSelector
    buyAmount: FloatSelector
    sellAmount: FloatSelector
    any: [StellarTradeEffectFilter!]
    options: QueryOptions
  ): [StellarTradeEffect!]

  """
  Stellar Transactions
  """
  transactions(
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    index: IntegerSelector
    hash: HashSelector
    sender: AddressSelector
    memos: StringSelector
    memoType: StringSelector
    timeBounds: StringSelector
    sequence: IntegerSelector
    success: BooleanSelector
    fee: FloatSelector
    maxFee: FloatSelector
    any: [StellarTransactionFilter!]
    options: QueryOptions
  ): [StellarTransaction!]

  """
  Stellar Transfers
  """
  transfers(
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionHash: HashSelector
    transactionIndex: IntegerSelector
    transactionSender: AddressSelector
    receiver: AddressSelector
    sender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    currencyFromName: CurrencySelector
    currencyToName: CurrencySelector
    direction: StringSelector
    amountFrom: FloatSelector
    amountTo: FloatSelector
    any: [StellarTransferFilter!]
    options: QueryOptions
  ): [StellarTransfer!]
}

"""
Address detailed information for Stellar network
"""
type StellarAddressInfo {
  """
  Address
  """
  address: String

  """
  Annotations ( tags ), if exists
  """
  annotation: String

  """
  XLM balance
  """
  balance(in: BaseCurrencyEnum): Float

  """
  Token Balances
  """
  tokenBalances: [StellarTokenBalances!]
}

"""
Counts and aggregates for the address, transfer count,
                  amount, number of distinct currencies,
                  times of the first and the last transactions
"""
type StellarAddressStat {
  """
  Address
  """
  address: Address

  """
  Balance
  """
  balance: BigInt

  """
  Days with received
  """
  daysWithReceived: BigInt

  """
  Days with sent
  """
  daysWithSent: BigInt

  """
  Days with transactions
  """
  daysWithTransactions: BigInt

  """
  Days with transfers
  """
  daysWithTransfers: BigInt

  """
  First transfer at
  """
  firstTransferAt: DateTime

  """
  First tx at
  """
  firstTxAt: DateTime

  """
  Last transfer at
  """
  lastTransferAt: DateTime

  """
  Last tx at
  """
  lastTxAt: DateTime

  """
  Receive Amount
  """
  receiveAmount: BigInt

  """
  Receive from Count
  """
  receiveFromCount: BigInt

  """
  Receive from currencies
  """
  receiveFromCurrencies: BigInt

  """
  Receive tx Count
  """
  receiveTxCount: BigInt

  """
  Send Amount
  """
  sendAmount: BigInt

  """
  Send to count
  """
  sendToCount: BigInt

  """
  Send to currencies
  """
  sendToCurrencies: BigInt

  """
  Send tx count
  """
  sendTxCount: BigInt
}

"""
AddressStat
"""
type StellarAddressStats {
  """
  Address With Statistics
  """
  address: StellarAddressStat
}

"""
Balance effect in Stellar blockchain
"""
type StellarBalanceEffect {
  """
  Address
  """
  address: Address
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    address: AddressSelector
    currencyName: CurrencySelector
    issuer: AddressSelector
    amount: FloatSelector
  ): DecimalNumberAsDiv
  any(of: StellarBalanceEffectMeasurable!): String

  """
  Block
  """
  block: BigInt
  count(
    uniq: StellarBalanceEffectUniq
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    address: AddressSelector
    currencyName: CurrencySelector
    issuer: AddressSelector
    amount: FloatSelector
  ): Int
  countBigInt(
    uniq: StellarBalanceEffectUniq
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    address: AddressSelector
    currencyName: CurrencySelector
    issuer: AddressSelector
    amount: FloatSelector
  ): BigInt

  """
  Currency
  """
  currency: Currency

  """
  Calendar date
  """
  date: Date

  """
  Effect index
  """
  effectIndex: Int
  expression(get: String!): DecimalNumber

  """
  Issuer
  """
  issuer: Address
  maximum(
    of: StellarBalanceEffectMeasurable!
    get: StellarBalanceEffectMeasurable
  ): String
  minimum(
    of: StellarBalanceEffectMeasurable!
    get: StellarBalanceEffectMeasurable
  ): String

  """
  Operation
  """
  operation: OperationIndexedWithAccount

  """
  Order
  """
  order: Int

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transaction
  """
  transaction: StellarTransactionDimension
}

input StellarBalanceEffectFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  operation: StringSelector
  opIndex: IntegerSelector
  opSourceAccount: AddressSelector
  effectIndex: IntegerSelector
  order: IntegerSelector
  address: AddressSelector
  currencyName: CurrencySelector
  issuer: AddressSelector
  amount: FloatSelector
}

enum StellarBalanceEffectMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction index
  """
  transactionIndex

  """
  Transaction hash
  """
  transactionHash

  """
  Transaction sender
  """
  transactionSender

  """
  Operation
  """
  operation

  """
  Operation index
  """
  opIndex

  """
  Operation source account
  """
  opSourceAccount

  """
  Effect index
  """
  effectIndex

  """
  Order
  """
  order

  """
  Address
  """
  address

  """
  Currency name
  """
  currencyName

  """
  Currency symbol
  """
  currencySymbol

  """
  Issuer
  """
  issuer

  """
  Amount
  """
  amount
}

enum StellarBalanceEffectUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Uniq blocks count
  """
  blocks

  """
  Uniq transaction indices count
  """
  transactionIndices

  """
  Uniq transaction hashes count
  """
  transactionHashes

  """
  Uniq transaction senders count
  """
  transactionSenders

  """
  Uniq operations count
  """
  operations

  """
  Uniq operation indices count
  """
  opIndices

  """
  Uniq operation source accounts count
  """
  opSourceAccounts

  """
  Uniq effect indices count
  """
  effectIndices

  """
  Uniq orders count
  """
  orders

  """
  Uniq addresses count
  """
  addresses

  """
  Uniq currencies name count
  """
  currenciesName

  """
  Uniq currencies symbol count
  """
  currenciesSymbol

  """
  Uniq issuers count
  """
  issuers
}

"""
Block in Stellar blockchain
"""
type StellarBlock {
  any(of: StellarBlockMeasurable!): String
  baseFee(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    maxTxSetSize: IntegerSelector
    protocolVersion: IntegerSelector
    totalCoins: FloatSelector
    feePool: FloatSelector
    baseFee: FloatSelector
    baseReserve: FloatSelector
  ): DecimalNumberAsDiv
  baseReserve(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    maxTxSetSize: IntegerSelector
    protocolVersion: IntegerSelector
    totalCoins: FloatSelector
    feePool: FloatSelector
    baseFee: FloatSelector
    baseReserve: FloatSelector
  ): DecimalNumberAsDiv
  count(
    uniq: StellarBlockUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    maxTxSetSize: IntegerSelector
    protocolVersion: IntegerSelector
    totalCoins: FloatSelector
    feePool: FloatSelector
    baseFee: FloatSelector
    baseReserve: FloatSelector
  ): Int
  countBigInt(
    uniq: StellarBlockUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    maxTxSetSize: IntegerSelector
    protocolVersion: IntegerSelector
    totalCoins: FloatSelector
    feePool: FloatSelector
    baseFee: FloatSelector
    baseReserve: FloatSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber
  feePool(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    maxTxSetSize: IntegerSelector
    protocolVersion: IntegerSelector
    totalCoins: FloatSelector
    feePool: FloatSelector
    baseFee: FloatSelector
    baseReserve: FloatSelector
  ): DecimalNumberAsDiv

  """
  Block hash
  """
  hash: String!

  """
  Ledger number (block|height) in blockchain
  """
  height: Int!

  """
  Max transaction set size
  """
  maxTxSetSize: Int!
  maximum(of: StellarBlockMeasurable!, get: StellarBlockMeasurable): String
  minimum(of: StellarBlockMeasurable!, get: StellarBlockMeasurable): String

  """
  Protocol version
  """
  protocolVersion: Int!

  """
  Block timestamp
  """
  timestamp: DateTime
  totalCoins(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    maxTxSetSize: IntegerSelector
    protocolVersion: IntegerSelector
    totalCoins: FloatSelector
    feePool: FloatSelector
    baseFee: FloatSelector
    baseReserve: FloatSelector
  ): DecimalNumberAsDiv
}

input StellarBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  hash: HashSelector
  maxTxSetSize: IntegerSelector
  protocolVersion: IntegerSelector
  totalCoins: FloatSelector
  feePool: FloatSelector
  baseFee: FloatSelector
  baseReserve: FloatSelector
}

enum StellarBlockMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Block hash
  """
  hash

  """
  Total coins
  """
  totalCoins

  """
  Fee pool
  """
  feePool

  """
  Base fee
  """
  baseFee

  """
  Base reserve
  """
  baseReserve

  """
  Max tx set size
  """
  maxTxSetSize

  """
  Protocol version
  """
  protocolVersion
}

enum StellarBlockUniq {
  """
  Uniq date count
  """
  dates

  """
  Uniq blocks count
  """
  blocks

  """
  Uniq hashes count
  """
  hashes

  """
  Uniq max tx set sizes count
  """
  maxTxSetSizes

  """
  Uniq protocol versions
  """
  protocolVersions
}

"""
Claimable balance effect in Stellar blockchain
"""
type StellarClaimableBalanceEffect {
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effect: StringSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    sponsor: AddressSelector
    claimant: AddressSelector
    currencyName: CurrencySelector
    issuer: AddressSelector
    balanceId: StringSelector
    amount: FloatSelector
  ): DecimalNumberAsDiv
  any(of: StellarClaimableBalanceEffectMeasurable!): String

  """
  Balance
  """
  balanceId: String

  """
  Block
  """
  block: BigInt

  """
  Claimant
  """
  claimant: Address
  count(
    uniq: StellarClaimableBalanceEffectUniq
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effect: StringSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    sponsor: AddressSelector
    claimant: AddressSelector
    currencyName: CurrencySelector
    issuer: AddressSelector
    balanceId: StringSelector
    amount: FloatSelector
  ): Int
  countBigInt(
    uniq: StellarClaimableBalanceEffectUniq
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effect: StringSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    sponsor: AddressSelector
    claimant: AddressSelector
    currencyName: CurrencySelector
    issuer: AddressSelector
    balanceId: StringSelector
    amount: FloatSelector
  ): BigInt

  """
  Currency
  """
  currency: Currency

  """
  Calendar date
  """
  date: Date

  """
  Effect
  """
  effect: String

  """
  Effect index
  """
  effectIndex: Int
  expression(get: String!): DecimalNumber

  """
  Issuer
  """
  issuer: Address
  maximum(
    of: StellarClaimableBalanceEffectMeasurable!
    get: StellarClaimableBalanceEffectMeasurable
  ): String
  minimum(
    of: StellarClaimableBalanceEffectMeasurable!
    get: StellarClaimableBalanceEffectMeasurable
  ): String

  """
  Operation
  """
  operation: OperationIndexedWithAccount

  """
  Order
  """
  order: Int

  """
  Sponsor
  """
  sponsor: Address

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transaction
  """
  transaction: StellarTransactionDimension
}

input StellarClaimableBalanceEffectFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  operation: StringSelector
  opIndex: IntegerSelector
  opSourceAccount: AddressSelector
  effect: StringSelector
  effectIndex: IntegerSelector
  order: IntegerSelector
  sponsor: AddressSelector
  claimant: AddressSelector
  currencyName: CurrencySelector
  issuer: AddressSelector
  balanceId: StringSelector
  amount: FloatSelector
}

enum StellarClaimableBalanceEffectMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction index
  """
  transactionIndex

  """
  Transaction hash
  """
  transactionHash

  """
  Transaction sender
  """
  transactionSender

  """
  Operation
  """
  operation

  """
  Operation index
  """
  opIndex

  """
  Operation source account
  """
  opSourceAccount

  """
  Effect
  """
  effect

  """
  Effect index
  """
  effectIndex

  """
  Order
  """
  order

  """
  Sponsor
  """
  sponsor

  """
  Claimant
  """
  claimant

  """
  Currency name
  """
  currencyName

  """
  Currency symbol
  """
  currencySymbol

  """
  Issuer
  """
  issuer

  """
  Amount
  """
  amount
}

enum StellarClaimableBalanceEffectUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Uniq blocks count
  """
  blocks

  """
  Uniq transaction indices count
  """
  transactionIndices

  """
  Uniq transaction hashes count
  """
  transactionHashes

  """
  Uniq transaction senders count
  """
  transactionSenders

  """
  Uniq operations count
  """
  operations

  """
  Uniq operaion indices count
  """
  opIndices

  """
  Uniq operation source accounts count
  """
  opSourceAccounts

  """
  Uniq effects count
  """
  effects

  """
  Uniq effect indices count
  """
  effectIndices

  """
  Uniq orders count
  """
  orders

  """
  Uniq sponsors count
  """
  sponsors

  """
  Uniq claimants count
  """
  claimants

  """
  Uniq currencies name count
  """
  currenciesName

  """
  Uniq currencies symbol count
  """
  currenciesSymbol

  """
  Uniq issuers count
  """
  issuers
}

"""
Stellar Coinpath
"""
type StellarCoinpath {
  """
  Summary of transfered value from
  """
  amountFrom(in: BaseCurrencyEnum): Float

  """
  Summary of transfered value to
  """
  amountTo(in: BaseCurrencyEnum): Float
  any(of: StellarCoinpathMeasureable!): String

  """
  Block where transaction is included
  """
  block: Block

  """
  Count of transfers
  """
  count: Int

  """
  Count of transfers
  """
  countBigInt: BigInt

  """
  Currency From of transfer
  """
  currencyFrom: Currency

  """
  Currency To of transfer
  """
  currencyTo: Currency

  """
  1-based hop depth of the graph
  """
  depth: Int
  maximum(
    of: StellarCoinpathMeasureable!
    get: StellarCoinpathMeasureable
  ): String
  minimum(
    of: StellarCoinpathMeasureable!
    get: StellarCoinpathMeasureable
  ): String

  """
  Operation
  """
  operation: String

  """
  Receiver address
  """
  receiver: StellarCoinpathAddress

  """
  Sender address
  """
  sender: StellarCoinpathAddress

  """
  Transaction of transfer happened
  """
  transaction: StellarTransactionCoinpathDimension
}

"""
Address detailed information for Stellar network
"""
type StellarCoinpathAddress {
  """
  Address
  """
  address: String

  """
  Annotations ( tags ), if exists
  """
  annotation: String

  """
  First Tx At
  """
  firstTransferAt: DateTime

  """
  Last Tx At
  """
  lastTransferAt: DateTime
  receiversCount: Int
  sendersCount: Int
}

enum StellarCoinpathMeasureable {
  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Version
  """
  tx_hash

  """
  Sender
  """
  sender

  """
  Receiver
  """
  receiver

  """
  Depth
  """
  depth
}

"""
Effect in Stellar blockchain
"""
type StellarEffect {
  """
  Address
  """
  address: Address
  any(of: StellarEffectMeasurable!): String

  """
  Block
  """
  block: BigInt
  count(
    uniq: StellarEffectUniq
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effect: StringSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    details: StringSelector
    address: AddressSelector
  ): Int
  countBigInt(
    uniq: StellarEffectUniq
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effect: StringSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    details: StringSelector
    address: AddressSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date

  """
  Details
  """
  details: String

  """
  Effect
  """
  effect: String
  expression(get: String!): DecimalNumber

  """
  Effect index
  """
  index: Int
  maximum(of: StellarEffectMeasurable!, get: StellarEffectMeasurable): String
  minimum(of: StellarEffectMeasurable!, get: StellarEffectMeasurable): String

  """
  Operation
  """
  operation: OperationIndexedWithAccount

  """
  Order
  """
  order: Int

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transaction
  """
  transaction: StellarTransactionDimension
}

"""
Effect argument in Stellar blockchain
"""
type StellarEffectArgument {
  """
  Address
  """
  address: Address
  any(of: StellarEffectArgumentMeasurable!): String

  """
  Argname
  """
  argname: String

  """
  Argvalue
  """
  argvalue: String

  """
  Block
  """
  block: BigInt
  count(
    uniq: StellarEffectArgumentUniq
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effect: StringSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    address: AddressSelector
    argname: StringSelector
    argvalue: StringSelector
  ): Int
  countBigInt(
    uniq: StellarEffectArgumentUniq
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effect: StringSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    address: AddressSelector
    argname: StringSelector
    argvalue: StringSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date

  """
  Effect
  """
  effect: String

  """
  Effect index
  """
  effectIndex: Int
  expression(get: String!): DecimalNumber
  maximum(
    of: StellarEffectArgumentMeasurable!
    get: StellarEffectArgumentMeasurable
  ): String
  minimum(
    of: StellarEffectArgumentMeasurable!
    get: StellarEffectArgumentMeasurable
  ): String

  """
  Operation
  """
  operation: OperationIndexedWithAccount

  """
  Order
  """
  order: Int

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transaction
  """
  transaction: StellarTransactionDimension
}

input StellarEffectArgumentFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  operation: StringSelector
  opIndex: IntegerSelector
  opSourceAccount: AddressSelector
  effect: StringSelector
  effectIndex: IntegerSelector
  order: IntegerSelector
  address: AddressSelector
  argname: StringSelector
  argvalue: StringSelector
}

enum StellarEffectArgumentMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction index
  """
  transactionIndex

  """
  Transaction hash
  """
  transactionHash

  """
  Transaction sender
  """
  transactionSender

  """
  Operation
  """
  operation

  """
  Operation index
  """
  opIndex

  """
  Operation source account
  """
  opSourceAccount

  """
  Effect
  """
  effect

  """
  Effect index
  """
  effectIndex

  """
  Order
  """
  order

  """
  Address
  """
  address

  """
  Argname
  """
  argname

  """
  Argvalue
  """
  argvalue
}

enum StellarEffectArgumentUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Uniq blocks count
  """
  blocks

  """
  Uniq transaction indices count
  """
  transactionIndices

  """
  Uniq transaction hashes count
  """
  transactionHashes

  """
  Uniq transaction senders count
  """
  transactionSenders

  """
  Uniq operations count
  """
  operations

  """
  Uniq operation indices count
  """
  opIndices

  """
  Uniq operation source accounts count
  """
  opSourceAccounts

  """
  Uniq effects count
  """
  effects

  """
  Uniq effect indices count
  """
  effectIndices

  """
  Uniq orders count
  """
  orders

  """
  Uniq addresses count
  """
  addresses

  """
  Uniq argnames count
  """
  argnames

  """
  Uniq argvalues count
  """
  argvalues
}

input StellarEffectFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  operation: StringSelector
  opIndex: IntegerSelector
  opSourceAccount: AddressSelector
  effect: StringSelector
  effectIndex: IntegerSelector
  order: IntegerSelector
  details: StringSelector
  address: AddressSelector
}

enum StellarEffectMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction index
  """
  transactionIndex

  """
  Transaction hash
  """
  transactionHash

  """
  Transaction sender
  """
  transactionSender

  """
  Operation
  """
  operation

  """
  Operation index
  """
  opIndex

  """
  Operation source account
  """
  opSourceAccount

  """
  Effect
  """
  effect

  """
  Effect index
  """
  effectIndex

  """
  Order
  """
  order

  """
  Details
  """
  details

  """
  Address
  """
  address
}

enum StellarEffectUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Uniq blocks count
  """
  blocks

  """
  Uniq transaction indices count
  """
  transactionIndices

  """
  Uniq transaction hashes count
  """
  transactionHashes

  """
  Uniq transaction senders count
  """
  transactionSenders

  """
  Uniq operations count
  """
  operations

  """
  Uniq operation indices count
  """
  opIndices

  """
  Uniq operation source accounts count
  """
  opSourceAccounts

  """
  Uniq effects count
  """
  effects

  """
  Uniq effect indices count
  """
  effectIndices

  """
  Uniq orders count
  """
  orders

  """
  Uniq details count
  """
  details

  """
  Uniq addresses count
  """
  addresses
}

"""
Liquidity pool effect in Stellar blockchain
"""
type StellarLiquidityPoolEffect {
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effect: StringSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    currencyName: CurrencySelector
    issuer: AddressSelector
    liquidityPoolId: StringSelector
    liquidityPoolDetails: StringSelector
    amount: FloatSelector
    shares: FloatSelector
  ): DecimalNumberAsDiv
  any(of: StellarLiquidityPoolEffectMeasurable!): String

  """
  Block
  """
  block: BigInt
  count(
    uniq: StellarLiquidityPoolEffectUniq
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effect: StringSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    currencyName: CurrencySelector
    issuer: AddressSelector
    liquidityPoolId: StringSelector
    liquidityPoolDetails: StringSelector
    amount: FloatSelector
    shares: FloatSelector
  ): Int
  countBigInt(
    uniq: StellarLiquidityPoolEffectUniq
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effect: StringSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    currencyName: CurrencySelector
    issuer: AddressSelector
    liquidityPoolId: StringSelector
    liquidityPoolDetails: StringSelector
    amount: FloatSelector
    shares: FloatSelector
  ): BigInt

  """
  Currency
  """
  currency: Currency

  """
  Calendar date
  """
  date: Date

  """
  Effect
  """
  effect: String

  """
  Effect index
  """
  effectIndex: Int
  expression(get: String!): DecimalNumber

  """
  Issuer
  """
  issuer: Address

  """
  Liquidity pool details
  """
  liquidityPoolDetails: String

  """
  Liquidity pool id bin
  """
  liquidityPoolId: String
  maximum(
    of: StellarLiquidityPoolEffectMeasurable!
    get: StellarLiquidityPoolEffectMeasurable
  ): String
  minimum(
    of: StellarLiquidityPoolEffectMeasurable!
    get: StellarLiquidityPoolEffectMeasurable
  ): String

  """
  Operation
  """
  operation: OperationIndexedWithAccount

  """
  Order
  """
  order: Int
  shares(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effect: StringSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    currencyName: CurrencySelector
    issuer: AddressSelector
    liquidityPoolId: StringSelector
    liquidityPoolDetails: StringSelector
    amount: FloatSelector
    shares: FloatSelector
  ): DecimalNumber

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transaction
  """
  transaction: StellarTransactionDimension
}

input StellarLiquidityPoolEffectFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  operation: StringSelector
  opIndex: IntegerSelector
  opSourceAccount: AddressSelector
  effect: StringSelector
  effectIndex: IntegerSelector
  order: IntegerSelector
  currencyName: CurrencySelector
  issuer: AddressSelector
  liquidityPoolId: StringSelector
  liquidityPoolDetails: StringSelector
  amount: FloatSelector
  shares: FloatSelector
}

enum StellarLiquidityPoolEffectMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction index
  """
  transactionIndex

  """
  Transaction hash
  """
  transactionHash

  """
  Transaction sender
  """
  transactionSender

  """
  Operation
  """
  operation

  """
  Operation index
  """
  opIndex

  """
  Operation source account
  """
  opSourceAccount

  """
  Effect
  """
  effect

  """
  Effect index
  """
  effectIndex

  """
  Order
  """
  order

  """
  Currency name
  """
  currencyName

  """
  Currency symbol
  """
  currencySymbol

  """
  Amount
  """
  amount

  """
  Issuer
  """
  issuer

  """
  Shares
  """
  shares

  """
  Liquidity pool id
  """
  liquidityPoolId

  """
  Liquidity pool details
  """
  liquidityPoolDetails
}

enum StellarLiquidityPoolEffectUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Uniq blocks count
  """
  blocks

  """
  Uniq transaction indices count
  """
  transactionIndices

  """
  Uniq transaction hashes count
  """
  transactionHashes

  """
  Uniq transaction senders count
  """
  transactionSenders

  """
  Uniq operations count
  """
  operations

  """
  Uniq operation indices count
  """
  opIndices

  """
  Uniq operation source accounts count
  """
  opSourceAccounts

  """
  Uniq effects count
  """
  effects

  """
  Uniq effect indices count
  """
  effectIndices

  """
  Uniq orders count
  """
  orders

  """
  Uniq currencies name count
  """
  currenciesName

  """
  Uniq currencies symbol count
  """
  currenciesSymbol

  """
  Uniq issuers count
  """
  issuers

  """
  Uniq liquidity pool ids count
  """
  liquidityPoolIds

  """
  Uniq liquidity pool details count
  """
  liquidityPoolDetails
}

"""
Liquidity pool trade effect in Stellar blockchain
"""
type StellarLiquidityPoolTradeEffect {
  """
  Address
  """
  address: Address
  any(of: StellarLiquidityPoolTradeEffectMeasurable!): String

  """
  Block
  """
  block: BigInt
  buyAmount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    address: AddressSelector
    buyCurrencyName: CurrencySelector
    buyIssuer: AddressSelector
    sellCurrencyName: CurrencySelector
    sellIssuer: AddressSelector
    liquidityPoolId: StringSelector
    liquidityPoolDetails: StringSelector
    buyAmount: FloatSelector
    sellAmount: FloatSelector
  ): DecimalNumberAsDiv

  """
  Buy currency
  """
  buyCurrency: Currency

  """
  Buy issuer
  """
  buyIssuer: Address
  count(
    uniq: StellarLiquidityPoolTradeEffectUniq
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    address: AddressSelector
    buyCurrencyName: CurrencySelector
    buyIssuer: AddressSelector
    sellCurrencyName: CurrencySelector
    sellIssuer: AddressSelector
    liquidityPoolId: StringSelector
    liquidityPoolDetails: StringSelector
    buyAmount: FloatSelector
    sellAmount: FloatSelector
  ): Int
  countBigInt(
    uniq: StellarLiquidityPoolTradeEffectUniq
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    address: AddressSelector
    buyCurrencyName: CurrencySelector
    buyIssuer: AddressSelector
    sellCurrencyName: CurrencySelector
    sellIssuer: AddressSelector
    liquidityPoolId: StringSelector
    liquidityPoolDetails: StringSelector
    buyAmount: FloatSelector
    sellAmount: FloatSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date

  """
  Effect index
  """
  effectIndex: Int
  expression(get: String!): DecimalNumber

  """
  Liquidity pool details
  """
  liquidityPoolDetails: String

  """
  Liquidity pool
  """
  liquidityPoolId: String
  maximum(
    of: StellarLiquidityPoolTradeEffectMeasurable!
    get: StellarLiquidityPoolTradeEffectMeasurable
  ): String
  minimum(
    of: StellarLiquidityPoolTradeEffectMeasurable!
    get: StellarLiquidityPoolTradeEffectMeasurable
  ): String

  """
  Operation
  """
  operation: OperationIndexedWithAccount

  """
  Order
  """
  order: Int
  sellAmount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    address: AddressSelector
    buyCurrencyName: CurrencySelector
    buyIssuer: AddressSelector
    sellCurrencyName: CurrencySelector
    sellIssuer: AddressSelector
    liquidityPoolId: StringSelector
    liquidityPoolDetails: StringSelector
    buyAmount: FloatSelector
    sellAmount: FloatSelector
  ): DecimalNumberAsDiv

  """
  Sell currency
  """
  sellCurrency: Currency

  """
  Sell issuer
  """
  sellIssuer: Address

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transaction
  """
  transaction: StellarTransactionDimension
}

input StellarLiquidityPoolTradeEffectFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  operation: StringSelector
  opIndex: IntegerSelector
  opSourceAccount: AddressSelector
  effectIndex: IntegerSelector
  order: IntegerSelector
  address: AddressSelector
  buyCurrencyName: CurrencySelector
  buyIssuer: AddressSelector
  sellCurrencyName: CurrencySelector
  sellIssuer: AddressSelector
  liquidityPoolId: StringSelector
  liquidityPoolDetails: StringSelector
  buyAmount: FloatSelector
  sellAmount: FloatSelector
}

enum StellarLiquidityPoolTradeEffectMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction index
  """
  transactionIndex

  """
  Transaction hash
  """
  transactionHash

  """
  Transaction sender
  """
  transactionSender

  """
  Operation
  """
  operation

  """
  Operation index
  """
  opIndex

  """
  Opertation source account
  """
  opSourceAccount

  """
  Effect index
  """
  effectIndex

  """
  Order
  """
  order

  """
  Address
  """
  address

  """
  Buy currency name
  """
  buyCurrencyName

  """
  Buy currency symbol
  """
  buyCurrencySymbol

  """
  Buy amount
  """
  buyAmount

  """
  Buy issuer
  """
  buyIssuer

  """
  Sell currency name
  """
  sellCurrencyName

  """
  Sell currency symbol
  """
  sellCurrencySymbol

  """
  Sell amount
  """
  sellAmount

  """
  Sell issuer
  """
  sellIssuer

  """
  Liquidity pool
  """
  liquidityPoolId

  """
  Liquidity pool details
  """
  liquidityPoolDetails
}

enum StellarLiquidityPoolTradeEffectUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Uniq blocks count
  """
  blocks

  """
  Uniq transaction indices count
  """
  transactionIndices

  """
  Uniq transaction hashes count
  """
  transactionHashes

  """
  Uniq transaction senders count
  """
  transactionSenders

  """
  Uniq operations count
  """
  operations

  """
  Uniq operation indices count
  """
  opIndices

  """
  Uniq operation source accounts count
  """
  opSourceAccounts

  """
  Uniq effect indices count
  """
  effectIndices

  """
  Uniq orders count
  """
  orders

  """
  Uniq addresses count
  """
  addresses

  """
  Uniq buy currency names count
  """
  buyCurrencyNames

  """
  Uniq buy currency symbols count
  """
  buyCurrencySymbols

  """
  Uniq buy issuers count
  """
  buyIssuers

  """
  Uniq sell currency names count
  """
  sellCurrencyNames

  """
  Uniq sell currency symbols count
  """
  sellCurrencySymbols

  """
  Uniq sell issuers count
  """
  sellIssuers

  """
  Uniq liquidity pool ids count
  """
  liquidityPoolIds

  """
  Uniq liquidity pool details count
  """
  liquidityPoolDetails
}

enum StellarNetwork {
  """
  The Stellar Ledger
  """
  stellar
}

"""
Operation in Stellar blockchain
"""
type StellarOperation {
  any(of: StellarOperationMeasurable!): String

  """
  Block
  """
  block: BigInt
  count(
    uniq: StellarOperationUniq
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    index: IntegerSelector
    sourceAccount: AddressSelector
    details: StringSelector
    success: BooleanSelector
  ): Int
  countBigInt(
    uniq: StellarOperationUniq
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    index: IntegerSelector
    sourceAccount: AddressSelector
    details: StringSelector
    success: BooleanSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date

  """
  Details
  """
  details: String
  expression(get: String!): DecimalNumber

  """
  Operation index
  """
  index: Int
  maximum(
    of: StellarOperationMeasurable!
    get: StellarOperationMeasurable
  ): String
  minimum(
    of: StellarOperationMeasurable!
    get: StellarOperationMeasurable
  ): String

  """
  Operation
  """
  operation: String

  """
  Operation source account
  """
  sourceAccount: Address

  """
  Success
  """
  success: Boolean

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transaction
  """
  transaction: StellarTransactionDimension
}

input StellarOperationFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  operation: StringSelector
  index: IntegerSelector
  sourceAccount: AddressSelector
  details: StringSelector
  success: BooleanSelector
}

enum StellarOperationMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction index
  """
  transactionIndex

  """
  Transaction hash
  """
  transactionHash

  """
  Transaction sender
  """
  transactionSender

  """
  Operation
  """
  operation

  """
  Operation index
  """
  index

  """
  Operation source account
  """
  sourceAccount

  """
  Details
  """
  details

  """
  Success
  """
  success
}

enum StellarOperationUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Uniq blocks count
  """
  blocks

  """
  Uniq transaction indices count
  """
  transactionIndices

  """
  Uniq transaction hashes count
  """
  transactionHashes

  """
  Uniq transaction senders count
  """
  transactionSenders

  """
  Uniq operations count
  """
  operations

  """
  Uniq op source accounts count
  """
  sourceAccounts

  """
  Uniq details count
  """
  details
}

"""
Payment in Stellar blockchain
"""
type StellarPayment {
  amountFrom(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    receiver: AddressSelector
    sender: AddressSelector
    currencyFromName: CurrencySelector
    currencyToName: CurrencySelector
    issuerFrom: AddressSelector
    issuerTo: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    path: StringSelector
    success: BooleanSelector
    amountFrom: FloatSelector
    amountTo: FloatSelector
    minValueTo: FloatSelector
    maxValueFrom: FloatSelector
    debitedFromValue: FloatSelector
    creditedToValue: FloatSelector
  ): DecimalNumberAsDiv
  amountTo(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    receiver: AddressSelector
    sender: AddressSelector
    currencyFromName: CurrencySelector
    currencyToName: CurrencySelector
    issuerFrom: AddressSelector
    issuerTo: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    path: StringSelector
    success: BooleanSelector
    amountFrom: FloatSelector
    amountTo: FloatSelector
    minValueTo: FloatSelector
    maxValueFrom: FloatSelector
    debitedFromValue: FloatSelector
    creditedToValue: FloatSelector
  ): DecimalNumberAsDiv
  any(of: StellarPaymentMeasurable!): String

  """
  The sequence number of the ledger
  """
  block: BigInt
  count(
    uniq: StellarPaymentUniq
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    receiver: AddressSelector
    sender: AddressSelector
    currencyFromName: CurrencySelector
    currencyToName: CurrencySelector
    issuerFrom: AddressSelector
    issuerTo: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    path: StringSelector
    success: BooleanSelector
    amountFrom: FloatSelector
    amountTo: FloatSelector
    minValueTo: FloatSelector
    maxValueFrom: FloatSelector
    debitedFromValue: FloatSelector
    creditedToValue: FloatSelector
  ): Int
  countBigInt(
    uniq: StellarPaymentUniq
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    receiver: AddressSelector
    sender: AddressSelector
    currencyFromName: CurrencySelector
    currencyToName: CurrencySelector
    issuerFrom: AddressSelector
    issuerTo: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    path: StringSelector
    success: BooleanSelector
    amountFrom: FloatSelector
    amountTo: FloatSelector
    minValueTo: FloatSelector
    maxValueFrom: FloatSelector
    debitedFromValue: FloatSelector
    creditedToValue: FloatSelector
  ): BigInt
  creditedToValue(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    receiver: AddressSelector
    sender: AddressSelector
    currencyFromName: CurrencySelector
    currencyToName: CurrencySelector
    issuerFrom: AddressSelector
    issuerTo: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    path: StringSelector
    success: BooleanSelector
    amountFrom: FloatSelector
    amountTo: FloatSelector
    minValueTo: FloatSelector
    maxValueFrom: FloatSelector
    debitedFromValue: FloatSelector
    creditedToValue: FloatSelector
  ): DecimalNumberAsDiv

  """
  Sender's currency
  """
  currencyFrom: Currency

  """
  Receiver's currency
  """
  currencyTo: Currency

  """
  Calendar date
  """
  date: Date
  debitedFromValue(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    receiver: AddressSelector
    sender: AddressSelector
    currencyFromName: CurrencySelector
    currencyToName: CurrencySelector
    issuerFrom: AddressSelector
    issuerTo: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    path: StringSelector
    success: BooleanSelector
    amountFrom: FloatSelector
    amountTo: FloatSelector
    minValueTo: FloatSelector
    maxValueFrom: FloatSelector
    debitedFromValue: FloatSelector
    creditedToValue: FloatSelector
  ): DecimalNumberAsDiv
  expression(get: String!): DecimalNumber

  """
  Source issuer
  """
  issuerFrom: Address

  """
  Issuer
  """
  issuerTo: Address
  maxValueFrom(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    receiver: AddressSelector
    sender: AddressSelector
    currencyFromName: CurrencySelector
    currencyToName: CurrencySelector
    issuerFrom: AddressSelector
    issuerTo: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    path: StringSelector
    success: BooleanSelector
    amountFrom: FloatSelector
    amountTo: FloatSelector
    minValueTo: FloatSelector
    maxValueFrom: FloatSelector
    debitedFromValue: FloatSelector
    creditedToValue: FloatSelector
  ): DecimalNumberAsDiv
  maximum(of: StellarPaymentMeasurable!, get: StellarPaymentMeasurable): String
  minValueTo(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    receiver: AddressSelector
    sender: AddressSelector
    currencyFromName: CurrencySelector
    currencyToName: CurrencySelector
    issuerFrom: AddressSelector
    issuerTo: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    path: StringSelector
    success: BooleanSelector
    amountFrom: FloatSelector
    amountTo: FloatSelector
    minValueTo: FloatSelector
    maxValueFrom: FloatSelector
    debitedFromValue: FloatSelector
    creditedToValue: FloatSelector
  ): DecimalNumberAsDiv
  minimum(of: StellarPaymentMeasurable!, get: StellarPaymentMeasurable): String

  """
  Operation
  """
  operation: OperationIndexedWithAccount

  """
  Path
  """
  path: String

  """
  Payment receiver
  """
  receiver: Address

  """
  Payment sender
  """
  sender: Address

  """
  Success
  """
  success: Boolean

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transaction
  """
  transaction: StellarTransactionDimension
}

input StellarPaymentFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  receiver: AddressSelector
  sender: AddressSelector
  currencyFromName: CurrencySelector
  currencyToName: CurrencySelector
  issuerFrom: AddressSelector
  issuerTo: AddressSelector
  operation: StringSelector
  opIndex: IntegerSelector
  opSourceAccount: AddressSelector
  path: StringSelector
  success: BooleanSelector
  amountFrom: FloatSelector
  amountTo: FloatSelector
  minValueTo: FloatSelector
  maxValueFrom: FloatSelector
  debitedFromValue: FloatSelector
  creditedToValue: FloatSelector
}

enum StellarPaymentMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction index
  """
  transactionIndex

  """
  Transaction hash
  """
  transactionHash

  """
  Transaction sender
  """
  transactionSender

  """
  Sender
  """
  sender

  """
  Receiver
  """
  receiver

  """
  Currency from name
  """
  currencyFromName

  """
  Currency to name
  """
  currencyToName

  """
  Currency from symbol
  """
  currencyFromSymbol

  """
  Currency to symbol
  """
  currencyToSymbol

  """
  Issuer from
  """
  issuerFrom

  """
  Issuer to
  """
  issuerTo

  """
  Operation
  """
  operation

  """
  Op index
  """
  opIndex

  """
  Operation source account
  """
  opSourceAccount

  """
  Path
  """
  path

  """
  Success
  """
  success

  """
  Amount from
  """
  amountFrom

  """
  Amount to
  """
  amountTo

  """
  Max value from
  """
  maxValueFrom

  """
  Min value to
  """
  minValueTo

  """
  Debited from value
  """
  debitedFromValue

  """
  Credited to value
  """
  creditedToValue
}

enum StellarPaymentUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Uniq blocks count
  """
  blocks

  """
  Uniq transaction indices count
  """
  transactionIndices

  """
  Uniq transaction hashes count
  """
  transactionHashes

  """
  Uniq transaction senders count
  """
  transactionSenders

  """
  Uniq senders count
  """
  senders

  """
  Uniq receivers count
  """
  receivers

  """
  Uniq currencies from name count
  """
  currenciesFromName

  """
  Uniq currencies to name count
  """
  currenciesToName

  """
  Uniq currencies from symbol count
  """
  currenciesFromSymbol

  """
  Uniq currencies to symbol count
  """
  currenciesToSymbol

  """
  Uniq issuers from count
  """
  issuersFrom

  """
  Uniq issuers to count
  """
  issuersTo

  """
  Uniq operations count
  """
  operations

  """
  Uniq operation source accounts count
  """
  opSourceAccounts

  """
  Uniq paths count
  """
  paths
}

"""
Token Balance
"""
type StellarTokenBalances {
  """
  Asset code
  """
  assetCode: String

  """
  Asset issuer
  """
  assetIssuer: String

  """
  Asset type
  """
  assetType: String

  """
  Balance
  """
  balance: Float
}

"""
Trade effect in Stellar blockchain
"""
type StellarTradeEffect {
  """
  Address
  """
  address: Address
  any(of: StellarTradeEffectMeasurable!): String

  """
  Block
  """
  block: BigInt
  buyAmount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    address: AddressSelector
    seller: AddressSelector
    buyCurrencyName: CurrencySelector
    buyIssuer: AddressSelector
    sellCurrencyName: CurrencySelector
    sellIssuer: AddressSelector
    offerId: IntegerSelector
    buyAmount: FloatSelector
    sellAmount: FloatSelector
  ): DecimalNumberAsDiv

  """
  Buy currency
  """
  buyCurrency: Currency

  """
  Buy issuer
  """
  buyIssuer: Address
  count(
    uniq: StellarTradeEffectUniq
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    address: AddressSelector
    seller: AddressSelector
    buyCurrencyName: CurrencySelector
    buyIssuer: AddressSelector
    sellCurrencyName: CurrencySelector
    sellIssuer: AddressSelector
    offerId: IntegerSelector
    buyAmount: FloatSelector
    sellAmount: FloatSelector
  ): Int
  countBigInt(
    uniq: StellarTradeEffectUniq
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    address: AddressSelector
    seller: AddressSelector
    buyCurrencyName: CurrencySelector
    buyIssuer: AddressSelector
    sellCurrencyName: CurrencySelector
    sellIssuer: AddressSelector
    offerId: IntegerSelector
    buyAmount: FloatSelector
    sellAmount: FloatSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date

  """
  Effect index
  """
  effectIndex: Int
  expression(get: String!): DecimalNumber
  maximum(
    of: StellarTradeEffectMeasurable!
    get: StellarTradeEffectMeasurable
  ): String
  minimum(
    of: StellarTradeEffectMeasurable!
    get: StellarTradeEffectMeasurable
  ): String

  """
  Offer
  """
  offerId: BigInt

  """
  Operation
  """
  operation: OperationIndexedWithAccount

  """
  Order
  """
  order: Int
  sellAmount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionIndex: IntegerSelector
    transactionHash: HashSelector
    transactionSender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    opSourceAccount: AddressSelector
    effectIndex: IntegerSelector
    order: IntegerSelector
    address: AddressSelector
    seller: AddressSelector
    buyCurrencyName: CurrencySelector
    buyIssuer: AddressSelector
    sellCurrencyName: CurrencySelector
    sellIssuer: AddressSelector
    offerId: IntegerSelector
    buyAmount: FloatSelector
    sellAmount: FloatSelector
  ): DecimalNumberAsDiv

  """
  Sell currency
  """
  sellCurrency: Currency

  """
  Sell issuer
  """
  sellIssuer: Address

  """
  Seller
  """
  seller: Address

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transaction
  """
  transaction: StellarTransactionDimension
}

input StellarTradeEffectFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  operation: StringSelector
  opIndex: IntegerSelector
  opSourceAccount: AddressSelector
  effectIndex: IntegerSelector
  order: IntegerSelector
  address: AddressSelector
  seller: AddressSelector
  buyCurrencyName: CurrencySelector
  buyIssuer: AddressSelector
  sellCurrencyName: CurrencySelector
  sellIssuer: AddressSelector
  offerId: IntegerSelector
  buyAmount: FloatSelector
  sellAmount: FloatSelector
}

enum StellarTradeEffectMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction index
  """
  transactionIndex

  """
  Transaction hash
  """
  transactionHash

  """
  Transaction sender
  """
  transactionSender

  """
  Operation
  """
  operation

  """
  Operation index
  """
  opIndex

  """
  Operation source account
  """
  opSourceAccount

  """
  Effect index
  """
  effectIndex

  """
  Order
  """
  order

  """
  Address
  """
  address

  """
  Seller
  """
  seller

  """
  Buy currency name
  """
  buyCurrencyName

  """
  Buy currency symbol
  """
  buyCurrencySymbol

  """
  Buy amount
  """
  buyAmount

  """
  Buy issuer
  """
  buyIssuer

  """
  Sell currency name
  """
  sellCurrencyName

  """
  Sell currency symbol
  """
  sellCurrencySymbol

  """
  Sell amount
  """
  sellAmount

  """
  Sell issuer
  """
  sellIssuer

  """
  Offer
  """
  offerId
}

enum StellarTradeEffectUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Uniq blocks count
  """
  blocks

  """
  Uniq transaction indices count
  """
  transactionIndices

  """
  Uniq transaction hashes count
  """
  transactionHashes

  """
  Uniq transaction senders count
  """
  transactionSenders

  """
  Uniq operations count
  """
  operations

  """
  Uniq operation indices count
  """
  opIndices

  """
  Uniq operation source accounts count
  """
  opSourceAccounts

  """
  Uniq effect indices count
  """
  effectIndices

  """
  Uniq orders count
  """
  orders

  """
  Uniq addresses count
  """
  addresses

  """
  Uniq sellers count
  """
  sellers

  """
  Uniq buy currency names count
  """
  buyCurrencyNames

  """
  Uniq buy currency symbols count
  """
  buyCurrencySymbols

  """
  Uniq buy issuers count
  """
  buyIssuers

  """
  Uniq sell currency names count
  """
  sellCurrencyNames

  """
  Uniq sell currency symbols count
  """
  sellCurrencySymbols

  """
  Uniq sell issuers count
  """
  sellIssuers

  """
  Uniq offer ids count
  """
  offerIds
}

"""
Transaction in Stellar blockchain
"""
type StellarTransaction {
  any(of: StellarTransactionMeasurable!): String

  """
  The sequence number of the ledger that this transaction was included in
  """
  block: BigInt
  count(
    uniq: StellarTransactionUniq
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    index: IntegerSelector
    hash: HashSelector
    sender: AddressSelector
    memos: StringSelector
    memoType: StringSelector
    timeBounds: StringSelector
    sequence: IntegerSelector
    success: BooleanSelector
    fee: FloatSelector
    maxFee: FloatSelector
  ): Int
  countBigInt(
    uniq: StellarTransactionUniq
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    index: IntegerSelector
    hash: HashSelector
    sender: AddressSelector
    memos: StringSelector
    memoType: StringSelector
    timeBounds: StringSelector
    sequence: IntegerSelector
    success: BooleanSelector
    fee: FloatSelector
    maxFee: FloatSelector
  ): BigInt

  """
  The date this transaction was created
  """
  date: Date
  expression(get: String!): DecimalNumber
  fee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    index: IntegerSelector
    hash: HashSelector
    sender: AddressSelector
    memos: StringSelector
    memoType: StringSelector
    timeBounds: StringSelector
    sequence: IntegerSelector
    success: BooleanSelector
    fee: FloatSelector
    maxFee: FloatSelector
  ): DecimalNumberAsDiv

  """
  Hash of this transaction
  """
  hash: String

  """
  Index of this transaction
  """
  index: Int
  maxFee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    index: IntegerSelector
    hash: HashSelector
    sender: AddressSelector
    memos: StringSelector
    memoType: StringSelector
    timeBounds: StringSelector
    sequence: IntegerSelector
    success: BooleanSelector
    fee: FloatSelector
    maxFee: FloatSelector
  ): DecimalNumberAsDiv
  maximum(
    of: StellarTransactionMeasurable!
    get: StellarTransactionMeasurable
  ): String

  """
  Memo type
  """
  memoType: String

  """
  Memos
  """
  memos: String
  minimum(
    of: StellarTransactionMeasurable!
    get: StellarTransactionMeasurable
  ): String

  """
  Sender of this transaction
  """
  sender: Address

  """
  Sequence
  """
  sequence: BigInt

  """
  Success
  """
  success: Boolean

  """
  Time bounds
  """
  timeBounds: String

  """
  The time this transaction was created
  """
  timestamp: DateTime
}

"""
Blockchain transaction Info
"""
type StellarTransactionCoinpathDimension {
  """
  Hash hex representation
  """
  hash: String!

  """
  Transaction Index
  """
  index: Int!

  """
  Time
  """
  time: DateTime

  """
  Transaction Value From
  """
  valueFrom: Float

  """
  Transaction Value To
  """
  valueTo: Float
}

"""
Blockchain transaction
"""
type StellarTransactionDimension {
  """
  Hash hex representation
  """
  hash: String!

  """
  Transaction index in block
  """
  index: Int!

  """
  Transaction sender
  """
  sender: String
}

input StellarTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  index: IntegerSelector
  hash: HashSelector
  sender: AddressSelector
  memos: StringSelector
  memoType: StringSelector
  timeBounds: StringSelector
  sequence: IntegerSelector
  success: BooleanSelector
  fee: FloatSelector
  maxFee: FloatSelector
}

enum StellarTransactionMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Ledger
  """
  block

  """
  Transaction Index
  """
  index

  """
  Transaction Hash
  """
  hash

  """
  Transaction sender
  """
  sender

  """
  fee
  """
  fee

  """
  Max fee
  """
  maxFee

  """
  Memos
  """
  memos

  """
  Memo type
  """
  memoType

  """
  Time bounds
  """
  timeBounds

  """
  Sequence
  """
  sequence

  """
  Success
  """
  success
}

enum StellarTransactionUniq {
  """
  Uniq date count
  """
  dates

  """
  Uniq blocks count
  """
  blocks

  """
  Uniq transaction hashes count
  """
  hashes

  """
  Uniq transaction senders
  """
  senders

  """
  Uniq memo types count
  """
  memoTypes

  """
  Uniq sequences count
  """
  sequences
}

"""
Transfer in Stellar blockchain
"""
type StellarTransfer {
  amountFrom(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionHash: HashSelector
    transactionIndex: IntegerSelector
    transactionSender: AddressSelector
    receiver: AddressSelector
    sender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    currencyFromName: CurrencySelector
    currencyToName: CurrencySelector
    direction: StringSelector
    amountFrom: FloatSelector
    amountTo: FloatSelector
  ): Float
  amountTo(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionHash: HashSelector
    transactionIndex: IntegerSelector
    transactionSender: AddressSelector
    receiver: AddressSelector
    sender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    currencyFromName: CurrencySelector
    currencyToName: CurrencySelector
    direction: StringSelector
    amountFrom: FloatSelector
    amountTo: FloatSelector
  ): Float
  any(of: StellarTransferMeasurable!): String

  """
  The sequence number of the ledger that this transaction was included in
  """
  block: BigInt
  count(
    uniq: StellarTransferUniq
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionHash: HashSelector
    transactionIndex: IntegerSelector
    transactionSender: AddressSelector
    receiver: AddressSelector
    sender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    currencyFromName: CurrencySelector
    currencyToName: CurrencySelector
    direction: StringSelector
    amountFrom: FloatSelector
    amountTo: FloatSelector
  ): Int
  countBigInt(
    uniq: StellarTransferUniq
    date: DateSelector
    time: DateTimeSelector
    block: BlockSelector
    transactionHash: HashSelector
    transactionIndex: IntegerSelector
    transactionSender: AddressSelector
    receiver: AddressSelector
    sender: AddressSelector
    operation: StringSelector
    opIndex: IntegerSelector
    currencyFromName: CurrencySelector
    currencyToName: CurrencySelector
    direction: StringSelector
    amountFrom: FloatSelector
    amountTo: FloatSelector
  ): BigInt

  """
  Currency from of transfer
  """
  currencyFrom: Currency

  """
  Currency to of transfer
  """
  currencyTo: Currency

  """
  The date this transaction was created
  """
  date: Date

  """
  Direction
  """
  direction: String
  expression(get: String!): DecimalNumber
  maximum(
    of: StellarTransferMeasurable!
    get: StellarTransferMeasurable
  ): String
  minimum(
    of: StellarTransferMeasurable!
    get: StellarTransferMeasurable
  ): String

  """
  Operation
  """
  operation: OperationIndexed

  """
  The account this transaction is been sent to
  """
  receiver: Address

  """
  Sender
  """
  sender: Address

  """
  The time this transaction was created
  """
  timestamp: DateTime

  """
  Transaction
  """
  transaction: StellarTransactionDimension
}

input StellarTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  transactionHash: HashSelector
  transactionIndex: IntegerSelector
  transactionSender: AddressSelector
  receiver: AddressSelector
  sender: AddressSelector
  operation: StringSelector
  opIndex: IntegerSelector
  currencyFromName: CurrencySelector
  currencyToName: CurrencySelector
  direction: StringSelector
  amountFrom: FloatSelector
  amountTo: FloatSelector
}

enum StellarTransferMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Ledger
  """
  block

  """
  Transaction Hash
  """
  transactionHash

  """
  Transaction Index
  """
  transactionIndex

  """
  Transaction sender
  """
  transactionSender

  """
  Operation
  """
  operation

  """
  Operation index
  """
  opIndex

  """
  Transfer Receiver
  """
  receiver

  """
  Transfer Sender
  """
  sender

  """
  Currency from name
  """
  currencyFromName

  """
  Currency to name
  """
  currencyToName

  """
  Currency from symbol
  """
  currencyFromSymbol

  """
  Currency to symbol
  """
  currencyToSymbol

  """
  Amount from
  """
  amountFrom

  """
  Amount to
  """
  amountTo

  """
  Direction
  """
  direction
}

enum StellarTransferUniq {
  """
  Uniq times count
  """
  times

  """
  Uniq dates count
  """
  dates

  """
  Uniq transaction hashes
  """
  transactionHashes

  """
  Uniq transaction indices
  """
  transactionIndices

  """
  Uniq transaction senders
  """
  transactionSenders

  """
  Uniq operations
  """
  operations

  """
  Uniq operation indices
  """
  opIndices

  """
  Uniq transfer receivers
  """
  receivers

  """
  Uniq transfer senders
  """
  senders

  """
  Uniq currency from names
  """
  currenciesFromName

  """
  Uniq currency to names
  """
  currenciesToName

  """
  Uniq currency from symbols
  """
  currenciesFromSymbol

  """
  Uniq currency to symbols
  """
  currenciesToSymbol

  """
  Uniq directions
  """
  directions
}

"""
Select by ID
"""
input StringIdSelector {
  """
  ID is
  """
  is: String

  """
  ID not
  """
  not: String

  """
  ID in the list
  """
  in: [String!]

  """
  ID not in the list
  """
  notIn: [String!]
}

"""
Select by string
"""
input StringSelector {
  """
  String is
  """
  is: String

  """
  String not
  """
  not: String

  """
  String in the list
  """
  in: [String!]

  """
  String not in the list
  """
  notIn: [String!]
}

"""
Search result subject
"""
union Subject =
    Address
  | Currency
  | MessageHash
  | SmartContract
  | TransactionHash

"""
Blockchain Unified GraphQL Subscription API
"""
type Subscription {
  """
  Ethereum Mainnet / Classic Chain Datasets
  """
  ethereum(network: EthereumNetwork): Ethereum
}

"""
Tezos Chain
"""
type Tezos {
  """
  Basic information about address
  """
  address(address: [AddressSelectorIn!]!): [TezosAddressInfoWithBalance!]!

  """
  Tezos Arguments
  """
  arguments(
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    blockHash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    transactionHash: HashSelector
    transactionSource: StringSelector
    opPath: StringSelector
    internal: BooleanSelector
    sender: AddressSelector
    receiver: AddressSelector
    status: StringSelector
    success: BooleanSelector
    argname: StringSelector
    argvalue: StringSelector
    amount: FloatSelector
    any: [TezosArgumentFilter!]
    options: QueryOptions
  ): [TezosArgument!]

  """
  Tezos Balance Updates
  """
  balanceUpdates(
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    blockHash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    kind: StringSelector
    transactionHash: HashSelector
    transactionSource: StringSelector
    opPath: StringSelector
    internal: BooleanSelector
    source: AddressSelector
    freezer: BooleanSelector
    category: StringSelector
    address: AddressSelector
    cycle: BigIntIdSelector
    attribute: StringSelector
    change: FloatSelector
    any: [TezosBalanceUpdateFilter!]
    options: QueryOptions
  ): [TezosBalanceUpdate!]

  """
  Tezos Blocks
  """
  blocks(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    baker: StringSelector
    any: [TezosBlockFilter!]
    options: QueryOptions
  ): [TezosBlock!]

  """
  Money flow using Coinpath technology
  """
  coinpath(
    sender: AddressSelector
    receiver: AddressSelector
    initialAddress: AddressSelector
    initialDate: DateSelector
    initialTime: DateTimeSelector
    date: DateSelector
    time: DateTimeSelector
    depth: IntegerLimitedSelector
    options: CoinpathOptions
  ): [TezosCoinpath!]

  """
  Tezos Operations
  """
  operations(
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    blockHash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    kind: StringSelector
    transactionHash: HashSelector
    transactionSource: StringSelector
    opPath: StringSelector
    internal: BooleanSelector
    source: StringSelector
    success: BooleanSelector
    contents: StringSelector
    any: [TezosOperationFilter!]
    options: QueryOptions
  ): [TezosOperation!]

  """
  Tezos Transactions
  """
  transactions(
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    blockHash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    hash: HashSelector
    source: StringSelector
    opPath: StringSelector
    internal: BooleanSelector
    sender: AddressSelector
    receiver: AddressSelector
    status: StringSelector
    allocatedDestinationContract: BooleanSelector
    destinationContract: BooleanSelector
    success: BooleanSelector
    amount: FloatSelector
    fee: FloatSelector
    paidStorageSizeDiff: BigIntIdSelector
    burnAmount: FloatSelector
    paidStorageAmount: FloatSelector
    gasLimit: BigIntIdSelector
    consumedGas: BigIntIdSelector
    storageSize: BigIntIdSelector
    any: [TezosTransactionFilter!]
    options: QueryOptions
  ): [TezosTransaction!]

  """
  Tezos Transfers
  """
  transfers(
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    blockHash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    kind: StringSelector
    transactionHash: HashSelector
    transactionSource: StringSelector
    opPath: StringSelector
    internal: BooleanSelector
    sender: AddressSelector
    receiver: AddressSelector
    destinationContract: BooleanSelector
    direction: StringSelector
    amount: FloatSelector
    any: [TezosTransferFilter!]
    options: QueryOptions
  ): [TezosTransfer!]
}

"""
Address detailed information for Tezos network
"""
type TezosAddressInfoWithBalance {
  """
  Address
  """
  address: String

  """
  Annotations ( tags ), if exists
  """
  annotation: String

  """
  Wallet balance
  """
  balance: [TezosBalance!]
}

"""
Argument in Tezos blockchain
"""
type TezosArgument {
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    blockHash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    transactionHash: HashSelector
    transactionSource: StringSelector
    opPath: StringSelector
    internal: BooleanSelector
    sender: AddressSelector
    receiver: AddressSelector
    status: StringSelector
    success: BooleanSelector
    argname: StringSelector
    argvalue: StringSelector
    amount: FloatSelector
  ): DecimalNumberAsDiv
  any(of: TezosArgumentMeasurable!): String

  """
  Argname
  """
  argname: String

  """
  Argvalue
  """
  argvalue: String

  """
  Block
  """
  block: TezosBlockWithHashDimension
  count(
    uniq: TezosArgumentUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    blockHash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    transactionHash: HashSelector
    transactionSource: StringSelector
    opPath: StringSelector
    internal: BooleanSelector
    sender: AddressSelector
    receiver: AddressSelector
    status: StringSelector
    success: BooleanSelector
    argname: StringSelector
    argvalue: StringSelector
    amount: FloatSelector
  ): Int
  countBigInt(
    uniq: TezosArgumentUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    blockHash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    transactionHash: HashSelector
    transactionSource: StringSelector
    opPath: StringSelector
    internal: BooleanSelector
    sender: AddressSelector
    receiver: AddressSelector
    status: StringSelector
    success: BooleanSelector
    argname: StringSelector
    argvalue: StringSelector
    amount: FloatSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Internal
  """
  internal: Boolean
  maximum(of: TezosArgumentMeasurable!, get: TezosArgumentMeasurable): String
  minimum(of: TezosArgumentMeasurable!, get: TezosArgumentMeasurable): String

  """
  Op path
  """
  opPath: String

  """
  Proto
  """
  proto: BigInt

  """
  Protocol
  """
  protocol: String

  """
  Receiver
  """
  receiver: Address

  """
  Sender
  """
  sender: Address

  """
  Status
  """
  status: String

  """
  Success
  """
  success: Boolean

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transaction
  """
  transaction: TezosTransactionWithSourceDimension
}

input TezosArgumentFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  blockHash: HashSelector
  proto: BigIntIdSelector
  protocol: StringSelector
  transactionHash: HashSelector
  transactionSource: StringSelector
  opPath: StringSelector
  internal: BooleanSelector
  sender: AddressSelector
  receiver: AddressSelector
  status: StringSelector
  success: BooleanSelector
  argname: StringSelector
  argvalue: StringSelector
  amount: FloatSelector
}

enum TezosArgumentMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Block hash
  """
  blockHash

  """
  Proto
  """
  proto

  """
  Protocol
  """
  protocol

  """
  Transaction hash
  """
  transactionHash

  """
  Transaction source
  """
  transactionSource

  """
  Op path
  """
  opPath

  """
  Internal
  """
  internal

  """
  Sender
  """
  sender

  """
  Receiver
  """
  receiver

  """
  Status
  """
  status

  """
  Success
  """
  success

  """
  Argname
  """
  argname

  """
  Argvalue
  """
  argvalue

  """
  Amount
  """
  amount
}

enum TezosArgumentUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Uniq blocks count
  """
  blocks

  """
  Uniq block hashes count
  """
  blockHashes

  """
  Uniq protos count
  """
  protos

  """
  Uniq protocols count
  """
  protocols

  """
  Uniq transaction hashes count
  """
  transactionHashes

  """
  Uniq transaction sources count
  """
  transactionSources

  """
  Uniq op paths count
  """
  opPaths

  """
  Uniq senders count
  """
  senders

  """
  Uniq receivers count
  """
  receivers

  """
  Uniq statuses count
  """
  statuses

  """
  Uniq argnames count
  """
  argnames

  """
  Uniq argvalues count
  """
  argvalues
}

"""
XTZ Balance
"""
type TezosBalance {
  """
  Spendable Balance
  """
  available(in: BaseCurrencyEnum): Float

  """
  Delegated Balance
  """
  delegated(in: BaseCurrencyEnum): Float

  """
  Frozen Deposit
  """
  frozenDeposit(in: BaseCurrencyEnum): Float

  """
  Staking Balance
  """
  staking(in: BaseCurrencyEnum): Float

  """
  Total Balance
  """
  total(in: BaseCurrencyEnum): Float
}

"""
Balance update in Tezos blockchain
"""
type TezosBalanceUpdate {
  """
  Address
  """
  address: Address
  any(of: TezosBalanceUpdateMeasurable!): String

  """
  Attribute
  """
  attribute: String

  """
  Block
  """
  block: TezosBlockWithHashDimension

  """
  Category
  """
  category: String
  change(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    blockHash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    kind: StringSelector
    transactionHash: HashSelector
    transactionSource: StringSelector
    opPath: StringSelector
    internal: BooleanSelector
    source: AddressSelector
    freezer: BooleanSelector
    category: StringSelector
    address: AddressSelector
    cycle: BigIntIdSelector
    attribute: StringSelector
    change: FloatSelector
  ): DecimalNumberAsDiv
  count(
    uniq: TezosBalanceUpdateUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    blockHash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    kind: StringSelector
    transactionHash: HashSelector
    transactionSource: StringSelector
    opPath: StringSelector
    internal: BooleanSelector
    source: AddressSelector
    freezer: BooleanSelector
    category: StringSelector
    address: AddressSelector
    cycle: BigIntIdSelector
    attribute: StringSelector
    change: FloatSelector
  ): Int
  countBigInt(
    uniq: TezosBalanceUpdateUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    blockHash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    kind: StringSelector
    transactionHash: HashSelector
    transactionSource: StringSelector
    opPath: StringSelector
    internal: BooleanSelector
    source: AddressSelector
    freezer: BooleanSelector
    category: StringSelector
    address: AddressSelector
    cycle: BigIntIdSelector
    attribute: StringSelector
    change: FloatSelector
  ): BigInt

  """
  Cycle
  """
  cycle: BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Freezer
  """
  freezer: Boolean

  """
  Internal
  """
  internal: Boolean

  """
  Kind
  """
  kind: String
  maximum(
    of: TezosBalanceUpdateMeasurable!
    get: TezosBalanceUpdateMeasurable
  ): String
  minimum(
    of: TezosBalanceUpdateMeasurable!
    get: TezosBalanceUpdateMeasurable
  ): String

  """
  Op path
  """
  opPath: String

  """
  Proto
  """
  proto: BigInt

  """
  Protocol
  """
  protocol: String

  """
  Source
  """
  source: Address

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transaction
  """
  transaction: TezosTransactionWithSourceDimension
}

input TezosBalanceUpdateFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  blockHash: HashSelector
  proto: BigIntIdSelector
  protocol: StringSelector
  kind: StringSelector
  transactionHash: HashSelector
  transactionSource: StringSelector
  opPath: StringSelector
  internal: BooleanSelector
  source: AddressSelector
  freezer: BooleanSelector
  category: StringSelector
  address: AddressSelector
  cycle: BigIntIdSelector
  attribute: StringSelector
  change: FloatSelector
}

enum TezosBalanceUpdateMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Block hash
  """
  blockHash

  """
  Proto
  """
  proto

  """
  Protocol
  """
  protocol

  """
  Kind
  """
  kind

  """
  Transaction hash
  """
  transactionHash

  """
  Transaction source
  """
  transactionSource

  """
  Op path
  """
  opPath

  """
  Internal
  """
  internal

  """
  Source
  """
  source

  """
  Freezer
  """
  freezer

  """
  Category
  """
  category

  """
  Address
  """
  address

  """
  Cycle
  """
  cycle

  """
  Attribute
  """
  attribute

  """
  Change
  """
  change
}

enum TezosBalanceUpdateUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Uniq blocks count
  """
  blocks

  """
  Uniq block hashes count
  """
  blockHashes

  """
  Uniq protos count
  """
  protos

  """
  Uniq protocols count
  """
  protocols

  """
  Uniq kinds count
  """
  kinds

  """
  Uniq transaction hashes count
  """
  transactionHashes

  """
  Uniq transaction sources count
  """
  transactionSources

  """
  Uniq op paths count
  """
  opPaths

  """
  Uniq sources count
  """
  sources

  """
  Uniq categories count
  """
  categories

  """
  Uniq addresses count
  """
  addresses

  """
  Uniq cycles count
  """
  cycles

  """
  Uniq attributes count
  """
  attributes
}

"""
Block in Tezos blockchain
"""
type TezosBlock {
  any(of: TezosBlockMeasurable!): String

  """
  Baker
  """
  baker: Address
  count(
    uniq: TezosBlockUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    baker: StringSelector
  ): Int
  countBigInt(
    uniq: TezosBlockUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    hash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    baker: StringSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Hash
  """
  hash: String

  """
  Header
  """
  header: String

  """
  Block number (height) in blockchain
  """
  height: BigInt
  maximum(of: TezosBlockMeasurable!, get: TezosBlockMeasurable): String

  """
  Metadata
  """
  metadata: String
  minimum(of: TezosBlockMeasurable!, get: TezosBlockMeasurable): String

  """
  Proto
  """
  proto: BigInt

  """
  Protocol
  """
  protocol: String

  """
  Timestamp
  """
  timestamp: DateTime
}

input TezosBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  hash: HashSelector
  proto: BigIntIdSelector
  protocol: StringSelector
  baker: StringSelector
}

enum TezosBlockMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Height
  """
  height

  """
  Hash
  """
  hash

  """
  Proto
  """
  proto

  """
  Protocol
  """
  protocol

  """
  Baker
  """
  baker

  """
  Metadata
  """
  metadata

  """
  Header
  """
  header
}

enum TezosBlockUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Uniq heights count
  """
  heights

  """
  Uniq hashes count
  """
  hashes

  """
  Uniq protos count
  """
  protos

  """
  Uniq protocols count
  """
  protocols

  """
  Uniq bakers count
  """
  bakers

  """
  Uniq metadatas count
  """
  metadatas

  """
  Uniq headers count
  """
  headers
}

"""
Tezos block with hash
"""
type TezosBlockWithHashDimension {
  """
  Block hash
  """
  hash: String!

  """
  Block
  """
  height: BigInt!
}

"""
Coinpath
"""
type TezosCoinpath {
  """
  Summary of transfered value
  """
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """
  Block where transaction is included
  """
  block: Block

  """
  Count of transfers
  """
  count: Int

  """
  Count of transfers
  """
  countBigInt: BigInt

  """
  Currency of transfer
  """
  currency: Currency

  """
  1-based hop depth of the graph
  """
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """
  Receiver address
  """
  receiver: Address

  """
  Sender address
  """
  sender: Address

  """
  Transaction of transfer happened
  """
  transaction: TransactionHashValue
}

enum TezosNetwork {
  """
  Tezos
  """
  tezos
}

"""
Operation in Tezos blockchain
"""
type TezosOperation {
  any(of: TezosOperationMeasurable!): String

  """
  Block
  """
  block: TezosBlockWithHashDimension

  """
  Contents
  """
  contents: String
  count(
    uniq: TezosOperationUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    blockHash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    kind: StringSelector
    transactionHash: HashSelector
    transactionSource: StringSelector
    opPath: StringSelector
    internal: BooleanSelector
    source: StringSelector
    success: BooleanSelector
    contents: StringSelector
  ): Int
  countBigInt(
    uniq: TezosOperationUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    blockHash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    kind: StringSelector
    transactionHash: HashSelector
    transactionSource: StringSelector
    opPath: StringSelector
    internal: BooleanSelector
    source: StringSelector
    success: BooleanSelector
    contents: StringSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Internal
  """
  internal: Boolean

  """
  Kind
  """
  kind: String
  maximum(of: TezosOperationMeasurable!, get: TezosOperationMeasurable): String
  minimum(of: TezosOperationMeasurable!, get: TezosOperationMeasurable): String

  """
  Op path
  """
  opPath: String

  """
  Proto
  """
  proto: BigInt

  """
  Protocol
  """
  protocol: String

  """
  Source
  """
  source: String

  """
  Success
  """
  success: Boolean

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transaction
  """
  transaction: TezosTransactionWithSourceDimension
}

input TezosOperationFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  blockHash: HashSelector
  proto: BigIntIdSelector
  protocol: StringSelector
  kind: StringSelector
  transactionHash: HashSelector
  transactionSource: StringSelector
  opPath: StringSelector
  internal: BooleanSelector
  source: StringSelector
  success: BooleanSelector
  contents: StringSelector
}

enum TezosOperationMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Block hash
  """
  blockHash

  """
  Proto
  """
  proto

  """
  Protocol
  """
  protocol

  """
  Kind
  """
  kind

  """
  Transaction hash
  """
  transactionHash

  """
  Transaction source
  """
  transactionSource

  """
  Op path
  """
  opPath

  """
  Internal
  """
  internal

  """
  Source
  """
  source

  """
  Success
  """
  success

  """
  Contents
  """
  contents
}

enum TezosOperationUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Uniq blocks count
  """
  blocks

  """
  Uniq block hashes count
  """
  blockHashes

  """
  Uniq protos count
  """
  protos

  """
  Uniq protocols count
  """
  protocols

  """
  Uniq kinds count
  """
  kinds

  """
  Uniq transaction hashes count
  """
  transactionHashes

  """
  Uniq transaction sources count
  """
  transactionSources

  """
  Uniq op paths count
  """
  opPaths

  """
  Uniq sources count
  """
  sources

  """
  Uniq contents count
  """
  contents
}

"""
Transaction in Tezos blockchain
"""
type TezosTransaction {
  """
  Allocated destination contract
  """
  allocatedDestinationContract: Boolean
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    blockHash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    hash: HashSelector
    source: StringSelector
    opPath: StringSelector
    internal: BooleanSelector
    sender: AddressSelector
    receiver: AddressSelector
    status: StringSelector
    allocatedDestinationContract: BooleanSelector
    destinationContract: BooleanSelector
    success: BooleanSelector
    amount: FloatSelector
    fee: FloatSelector
    paidStorageSizeDiff: BigIntIdSelector
    burnAmount: FloatSelector
    paidStorageAmount: FloatSelector
    gasLimit: BigIntIdSelector
    consumedGas: BigIntIdSelector
    storageSize: BigIntIdSelector
  ): DecimalNumberAsDiv
  any(of: TezosTransactionMeasurable!): String

  """
  Block
  """
  block: TezosBlockWithHashDimension
  burnAmount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    blockHash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    hash: HashSelector
    source: StringSelector
    opPath: StringSelector
    internal: BooleanSelector
    sender: AddressSelector
    receiver: AddressSelector
    status: StringSelector
    allocatedDestinationContract: BooleanSelector
    destinationContract: BooleanSelector
    success: BooleanSelector
    amount: FloatSelector
    fee: FloatSelector
    paidStorageSizeDiff: BigIntIdSelector
    burnAmount: FloatSelector
    paidStorageAmount: FloatSelector
    gasLimit: BigIntIdSelector
    consumedGas: BigIntIdSelector
    storageSize: BigIntIdSelector
  ): DecimalNumberAsDiv
  consumedGas(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    blockHash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    hash: HashSelector
    source: StringSelector
    opPath: StringSelector
    internal: BooleanSelector
    sender: AddressSelector
    receiver: AddressSelector
    status: StringSelector
    allocatedDestinationContract: BooleanSelector
    destinationContract: BooleanSelector
    success: BooleanSelector
    amount: FloatSelector
    fee: FloatSelector
    paidStorageSizeDiff: BigIntIdSelector
    burnAmount: FloatSelector
    paidStorageAmount: FloatSelector
    gasLimit: BigIntIdSelector
    consumedGas: BigIntIdSelector
    storageSize: BigIntIdSelector
  ): BigInt
  count(
    uniq: TezosTransactionUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    blockHash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    hash: HashSelector
    source: StringSelector
    opPath: StringSelector
    internal: BooleanSelector
    sender: AddressSelector
    receiver: AddressSelector
    status: StringSelector
    allocatedDestinationContract: BooleanSelector
    destinationContract: BooleanSelector
    success: BooleanSelector
    amount: FloatSelector
    fee: FloatSelector
    paidStorageSizeDiff: BigIntIdSelector
    burnAmount: FloatSelector
    paidStorageAmount: FloatSelector
    gasLimit: BigIntIdSelector
    consumedGas: BigIntIdSelector
    storageSize: BigIntIdSelector
  ): Int
  countBigInt(
    uniq: TezosTransactionUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    blockHash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    hash: HashSelector
    source: StringSelector
    opPath: StringSelector
    internal: BooleanSelector
    sender: AddressSelector
    receiver: AddressSelector
    status: StringSelector
    allocatedDestinationContract: BooleanSelector
    destinationContract: BooleanSelector
    success: BooleanSelector
    amount: FloatSelector
    fee: FloatSelector
    paidStorageSizeDiff: BigIntIdSelector
    burnAmount: FloatSelector
    paidStorageAmount: FloatSelector
    gasLimit: BigIntIdSelector
    consumedGas: BigIntIdSelector
    storageSize: BigIntIdSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date

  """
  Destination contract
  """
  destinationContract: Boolean
  expression(get: String!): DecimalNumber
  fee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    blockHash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    hash: HashSelector
    source: StringSelector
    opPath: StringSelector
    internal: BooleanSelector
    sender: AddressSelector
    receiver: AddressSelector
    status: StringSelector
    allocatedDestinationContract: BooleanSelector
    destinationContract: BooleanSelector
    success: BooleanSelector
    amount: FloatSelector
    fee: FloatSelector
    paidStorageSizeDiff: BigIntIdSelector
    burnAmount: FloatSelector
    paidStorageAmount: FloatSelector
    gasLimit: BigIntIdSelector
    consumedGas: BigIntIdSelector
    storageSize: BigIntIdSelector
  ): DecimalNumberAsDiv
  gasLimit(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    blockHash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    hash: HashSelector
    source: StringSelector
    opPath: StringSelector
    internal: BooleanSelector
    sender: AddressSelector
    receiver: AddressSelector
    status: StringSelector
    allocatedDestinationContract: BooleanSelector
    destinationContract: BooleanSelector
    success: BooleanSelector
    amount: FloatSelector
    fee: FloatSelector
    paidStorageSizeDiff: BigIntIdSelector
    burnAmount: FloatSelector
    paidStorageAmount: FloatSelector
    gasLimit: BigIntIdSelector
    consumedGas: BigIntIdSelector
    storageSize: BigIntIdSelector
  ): BigInt

  """
  Transaction hash
  """
  hash: String

  """
  Internal
  """
  internal: Boolean
  maximum(
    of: TezosTransactionMeasurable!
    get: TezosTransactionMeasurable
  ): String
  minimum(
    of: TezosTransactionMeasurable!
    get: TezosTransactionMeasurable
  ): String

  """
  Op path
  """
  opPath: String
  paidStorageAmount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    blockHash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    hash: HashSelector
    source: StringSelector
    opPath: StringSelector
    internal: BooleanSelector
    sender: AddressSelector
    receiver: AddressSelector
    status: StringSelector
    allocatedDestinationContract: BooleanSelector
    destinationContract: BooleanSelector
    success: BooleanSelector
    amount: FloatSelector
    fee: FloatSelector
    paidStorageSizeDiff: BigIntIdSelector
    burnAmount: FloatSelector
    paidStorageAmount: FloatSelector
    gasLimit: BigIntIdSelector
    consumedGas: BigIntIdSelector
    storageSize: BigIntIdSelector
  ): DecimalNumberAsDiv
  paidStorageSizeDiff(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    blockHash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    hash: HashSelector
    source: StringSelector
    opPath: StringSelector
    internal: BooleanSelector
    sender: AddressSelector
    receiver: AddressSelector
    status: StringSelector
    allocatedDestinationContract: BooleanSelector
    destinationContract: BooleanSelector
    success: BooleanSelector
    amount: FloatSelector
    fee: FloatSelector
    paidStorageSizeDiff: BigIntIdSelector
    burnAmount: FloatSelector
    paidStorageAmount: FloatSelector
    gasLimit: BigIntIdSelector
    consumedGas: BigIntIdSelector
    storageSize: BigIntIdSelector
  ): BigInt

  """
  Proto
  """
  proto: BigInt

  """
  Protocol
  """
  protocol: String

  """
  Receiver
  """
  receiver: Address

  """
  Sender
  """
  sender: Address

  """
  Transaction source
  """
  source: Address

  """
  Status
  """
  status: String
  storageSize(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    blockHash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    hash: HashSelector
    source: StringSelector
    opPath: StringSelector
    internal: BooleanSelector
    sender: AddressSelector
    receiver: AddressSelector
    status: StringSelector
    allocatedDestinationContract: BooleanSelector
    destinationContract: BooleanSelector
    success: BooleanSelector
    amount: FloatSelector
    fee: FloatSelector
    paidStorageSizeDiff: BigIntIdSelector
    burnAmount: FloatSelector
    paidStorageAmount: FloatSelector
    gasLimit: BigIntIdSelector
    consumedGas: BigIntIdSelector
    storageSize: BigIntIdSelector
  ): BigInt

  """
  Success
  """
  success: Boolean

  """
  Timestamp
  """
  timestamp: DateTime
}

input TezosTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  blockHash: HashSelector
  proto: BigIntIdSelector
  protocol: StringSelector
  hash: HashSelector
  source: StringSelector
  opPath: StringSelector
  internal: BooleanSelector
  sender: AddressSelector
  receiver: AddressSelector
  status: StringSelector
  allocatedDestinationContract: BooleanSelector
  destinationContract: BooleanSelector
  success: BooleanSelector
  amount: FloatSelector
  fee: FloatSelector
  paidStorageSizeDiff: BigIntIdSelector
  burnAmount: FloatSelector
  paidStorageAmount: FloatSelector
  gasLimit: BigIntIdSelector
  consumedGas: BigIntIdSelector
  storageSize: BigIntIdSelector
}

enum TezosTransactionMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Block hash
  """
  blockHash

  """
  Proto
  """
  proto

  """
  Protocol
  """
  protocol

  """
  Transaction hash
  """
  hash

  """
  Transaction source
  """
  source

  """
  Op path
  """
  opPath

  """
  Internal
  """
  internal

  """
  Sender
  """
  sender

  """
  Receiver
  """
  receiver

  """
  Status
  """
  status

  """
  Allocated destination contract
  """
  allocatedDestinationContract

  """
  Destination contract
  """
  destinationContract

  """
  Success
  """
  success

  """
  Amount
  """
  amount

  """
  Fee
  """
  fee

  """
  Paid storage size diff
  """
  paid_storage_size_diff

  """
  Burn amount
  """
  burnAmount

  """
  Paid storage amount
  """
  paidStorageAmount

  """
  Gas limit
  """
  gasLimit

  """
  Consumed gas
  """
  consumedGas

  """
  Storage size
  """
  storageSize
}

enum TezosTransactionUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Uniq blocks count
  """
  blocks

  """
  Uniq block hashes count
  """
  blockHashes

  """
  Uniq protos count
  """
  protos

  """
  Uniq protocols count
  """
  protocols

  """
  Uniq transaction hashes count
  """
  hashes

  """
  Uniq transaction sources count
  """
  sources

  """
  Uniq op paths count
  """
  opPaths

  """
  Uniq senders count
  """
  senders

  """
  Uniq receivers count
  """
  receivers

  """
  Uniq statuses count
  """
  statuses
}

"""
Tezos transaction with source
"""
type TezosTransactionWithSourceDimension {
  """
  Hash hex representation
  """
  hash: String!

  """
  Transaction source
  """
  source: String
}

"""
Transfer in Tezos blockchain
"""
type TezosTransfer {
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    blockHash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    kind: StringSelector
    transactionHash: HashSelector
    transactionSource: StringSelector
    opPath: StringSelector
    internal: BooleanSelector
    sender: AddressSelector
    receiver: AddressSelector
    destinationContract: BooleanSelector
    direction: StringSelector
    amount: FloatSelector
  ): DecimalNumberAsDiv
  any(of: TezosTransferMeasurable!): String

  """
  Block
  """
  block: TezosBlockWithHashDimension
  count(
    uniq: TezosTransferUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    blockHash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    kind: StringSelector
    transactionHash: HashSelector
    transactionSource: StringSelector
    opPath: StringSelector
    internal: BooleanSelector
    sender: AddressSelector
    receiver: AddressSelector
    destinationContract: BooleanSelector
    direction: StringSelector
    amount: FloatSelector
  ): Int
  countBigInt(
    uniq: TezosTransferUniq
    date: DateSelector
    time: DateTimeSelector
    block: BigIntIdSelector
    blockHash: HashSelector
    proto: BigIntIdSelector
    protocol: StringSelector
    kind: StringSelector
    transactionHash: HashSelector
    transactionSource: StringSelector
    opPath: StringSelector
    internal: BooleanSelector
    sender: AddressSelector
    receiver: AddressSelector
    destinationContract: BooleanSelector
    direction: StringSelector
    amount: FloatSelector
  ): BigInt

  """
  Currency
  """
  currency: Currency

  """
  Calendar date
  """
  date: Date

  """
  Destination contract
  """
  destinationContract: Boolean

  """
  Direction
  """
  direction: String
  expression(get: String!): DecimalNumber

  """
  Internal
  """
  internal: Boolean

  """
  Kind
  """
  kind: String
  maximum(of: TezosTransferMeasurable!, get: TezosTransferMeasurable): String
  minimum(of: TezosTransferMeasurable!, get: TezosTransferMeasurable): String

  """
  Op path
  """
  opPath: String

  """
  Proto
  """
  proto: BigInt

  """
  Protocol
  """
  protocol: String

  """
  Receiver
  """
  receiver: Address

  """
  Sender
  """
  sender: Address

  """
  Timestamp
  """
  timestamp: DateTime

  """
  Transaction
  """
  transaction: TezosTransactionWithSourceDimension
}

input TezosTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  blockHash: HashSelector
  proto: BigIntIdSelector
  protocol: StringSelector
  kind: StringSelector
  transactionHash: HashSelector
  transactionSource: StringSelector
  opPath: StringSelector
  internal: BooleanSelector
  sender: AddressSelector
  receiver: AddressSelector
  destinationContract: BooleanSelector
  direction: StringSelector
  amount: FloatSelector
}

enum TezosTransferMeasurable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Block hash
  """
  blockHash

  """
  Proto
  """
  proto

  """
  Protocol
  """
  protocol

  """
  Kind
  """
  kind

  """
  Transaction hash
  """
  transactionHash

  """
  Transaction source
  """
  transactionSource

  """
  Op path
  """
  opPath

  """
  Internal
  """
  internal

  """
  Sender
  """
  sender

  """
  Receiver
  """
  receiver

  """
  Amount
  """
  amount

  """
  Currency name
  """
  currencyName

  """
  Currency symbol
  """
  currencySymbol

  """
  Destination contract
  """
  destinationContract

  """
  Direction
  """
  direction
}

enum TezosTransferUniq {
  """
  Uniq dates count
  """
  dates

  """
  Uniq times count
  """
  times

  """
  Uniq blocks count
  """
  blocks

  """
  Uniq block hashes count
  """
  blockHashes

  """
  Uniq protos count
  """
  protos

  """
  Uniq protocols count
  """
  protocols

  """
  Uniq kinds count
  """
  kinds

  """
  Uniq transaction hashes count
  """
  transactionHashes

  """
  Uniq transaction sources count
  """
  transactionSources

  """
  Uniq op paths count
  """
  opPaths

  """
  Uniq senders count
  """
  senders

  """
  Uniq receivers count
  """
  receivers

  """
  Uniq currency names count
  """
  currencyNames

  """
  Uniq currency symbols count
  """
  currencySymbols

  """
  Uniq destination contracts count
  """
  destinationContracts

  """
  Uniq directions count
  """
  directions
}

"""
Time Interval
"""
type TimeInterval {
  day(count: Int, format: String): String!
  hour(count: Int, format: String): String!
  minute(count: Int, format: String): String!
  month(count: Int, format: String): String!
  second(count: Int, format: String): String!
  year(count: Int, format: String): String!
}

"""
Timestamp
"""
type Timestamp {
  """
  Nanoseconds
  """
  nanoseconds: BigInt!
  time: ISO8601Date!
}

"""
Select trade by ID
"""
input TradeIdSelector {
  """
  Trade ID is
  """
  is: String

  """
  Trade ID not
  """
  not: String

  """
  Trade ID in the list
  """
  in: [String!]

  """
  Trade ID not in the list
  """
  notIn: [String!]
}

enum TradeSide {
  """
  Buy side
  """
  BUY

  """
  Sell side
  """
  SELL
}

"""
Information about transaction
"""
type TransactionElrond {
  """
  Shard number of sender
  """
  data: String

  """
  Shard number of sender
  """
  dataOperation: String
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  """
  Shard number of sender
  """
  function: String

  """
  Transaction hash
  """
  hash: String

  """
  Transaction index
  """
  index: Int

  """
  Transaction nonce
  """
  nonce: Int

  """
  Hash of the receiver
  """
  receiver: Address

  """
  Shard number of receiver
  """
  receiverShard: BigInt

  """
  Hash of the sender
  """
  sender: Address

  """
  Shard number of sender
  """
  senderShard: BigInt

  """
  Shard number of sender
  """
  signature: String

  """
  Shard number of sender
  """
  status: String
}

"""
Blockchain transaction
"""
type TransactionHash {
  """
  Hash hex representation
  """
  hash: String!
}

"""
Blockchain transaction
"""
type TransactionHashIndex {
  """
  Block of the Output Transaction for this input
  """
  block: Int

  """
  Hash hex representation
  """
  hash: String!

  """
  Transaction index in block, 0-based
  """
  index: String!
}

"""
Blockchain transaction with value
"""
type TransactionHashValue {
  """
  Hash hex representation
  """
  hash: String!

  """
  Transaction value
  """
  value: Float!
}

"""
Blockchain transaction with value and time
"""
type TransactionHashValueTime {
  """
  Hash hex representation
  """
  hash: String!

  """
  Transaction time
  """
  time: DateTime!

  """
  Transaction value
  """
  value: Float!
}

"""
Transaction result
"""
type TransactionResult {
  """
  Result ID
  """
  id: Int!

  """
  Result name
  """
  name: String!
}

"""
Identification of transaction source as client application
"""
type TransactionSource {
  """
  ID numeric
  """
  code: Int!

  """
  Name
  """
  name: String!
}

enum TransfersUniq {
  """
  Transfers
  """
  transfers

  """
  Unique transactions count
  """
  txs

  """
  Unique senders count
  """
  senders

  """
  Unique receivers count
  """
  receivers

  """
  Unique blocks
  """
  blocks

  """
  Unique date count
  """
  dates

  """
  Unique currencies
  """
  currencies
}

"""
Select by type of transfer
"""
input TransferTypeSelector {
  """
  Transfer Type is
  """
  is: FilecoinTransferType

  """
  Transfer Type not
  """
  not: FilecoinTransferType

  """
  Transfer Type in the list
  """
  in: [FilecoinTransferType!]

  """
  Transfer Type not in the list
  """
  notIn: [FilecoinTransferType!]
}

"""
Tron Chain
"""
type Tron {
  """
  Basic information about address ( or smart contract )
  """
  address(address: [AddressSelectorIn!]!): [TronAddressInfoWithBalance!]!

  """
  Blockchain Arguments
  """
  arguments(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txIndex: IntegerSelector
    txHash: HashSelector
    owner: AddressSelector
    receiver: AddressSelector
    reference: AddressSelector
    value: [ArgumentValueSelector!]
    argument: [ArgumentSelector!]
    argumentType: ArgumentTypeSelector
    signatureType: SignatureTypeSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    smartContractEvent: EventSelector
    external: Boolean
    callDepth: StringSelector
    any: [TronArgumentFilter!]
    options: QueryOptions
  ): [TronArguments!]

  """
  Blockchain Blocks
  """
  blocks(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    witness: AddressSelector
    version: IntegerSelector
    parentBlockHash: [HashSelector!]
    any: [TronBlockFilter!]
    options: QueryOptions
  ): [TronBlocks!]

  """
  Money flow using Coinpath technology
  """
  coinpath(
    sender: AddressSelector
    receiver: AddressSelector
    currency: TronCurrencySelector
    initialAddress: AddressSelector
    initialDate: DateSelector
    initialTime: DateTimeSelector
    date: DateSelector
    time: DateTimeSelector
    depth: IntegerLimitedSelector
    options: CoinpathOptions
  ): [TronCoinpath!]

  """
  Blockchain Embedded Contracts
  """
  contracts(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txOwner: AddressSelector
    contractType: TronContractTypeSelector
    currency: TronCurrencySelector
    success: Boolean
    any: [TronContractFilter!]
    options: QueryOptions
  ): [TronSmartContracts!]

  """
  Trades on Ethereum DEX Smart Contracts
  """
  dexTrades(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    protocol: [StringSelector!]
    smartContractAddress: [AddressSelector!]
    exchangeAddress: [AddressSelector!]
    exchangeName: [StringSelector!]
    sellCurrency: [TronCurrencySelector!]
    buyCurrency: [TronCurrencySelector!]
    baseCurrency: [TronCurrencySelector!]
    quoteCurrency: [TronCurrencySelector!]
    maker: [AddressSelector!]
    taker: [AddressSelector!]
    makerOrTaker: [AddressSelector!]
    tradeIndex: [StringSelector!]
    buyAmount: [AmountSelector!]
    sellAmount: [AmountSelector!]
    price: [AmountSelector!]
    priceAsymmetry: [FloatSelector!]
    tradeAmountUsd: [FloatSelector!]
    any: [TronDexTradeFilter!]
    options: QueryOptions
  ): [TronDexTrades!]

  """
  Smart Contract Calls
  """
  smartContractCalls(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    external: Boolean
    success: Boolean
    any: [TronSmartContractCallFilter!]
    options: QueryOptions
  ): [TronSmartContractCalls!]

  """
  Smart Contract Events
  """
  smartContractEvents(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    smartContractAddress: AddressSelector
    smartContractEvent: EventSelector
    any: [TronSmartContractEventFilter!]
    options: QueryOptions
  ): [TronSmartContractEvents!]

  """
  Blockchain Embedded Contracts
  """
  trades(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    buyer: AddressSelector
    seller: AddressSelector
    buyCurrency: TronCurrencySelector
    sellCurrency: TronCurrencySelector
    contractType: TronContractTypeSelector
    amountSell: [AmountSelector!]
    amountBuy: [AmountSelector!]
    exchangeId: IntIdSelector
    success: Boolean
    any: [TronTradeFilter!]
    options: QueryOptions
  ): [TronTrades!]

  """
  Blockchain Transactions
  """
  transactions(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
    success: Boolean
    refBlockHash: [HashSelector!]
    contractAddress: AddressSelector
    any: [TronTransactionFilter!]
    options: QueryOptions
  ): [TronTransactions!]

  """
  Currency Transfers
  """
  transfers(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    sender: AddressSelector
    receiver: AddressSelector
    currency: TronCurrencySelector
    contractType: TronContractTypeSelector
    entityId: EntitySelector
    external: Boolean
    success: Boolean
    amount: [AmountSelector!]
    any: [TronTransferFilter!]
    options: QueryOptions
  ): [TronTransfers!]
}

"""
Address detailed information for Tron network
"""
type TronAddressInfo {
  """
  Address
  """
  address: String

  """
  Annotations ( tags ), if exists
  """
  annotation: String

  """
  Smart Contract if exists on the address
  """
  smartContract: TronSmartContractInfo
}

"""
Blockchain address
"""
type TronAddressInfoWithBalance {
  """
  Address
  """
  address: String

  """
  Annotations ( tags ), if exists
  """
  annotation: String

  """
  Current address balance
  """
  balance(in: BaseCurrencyEnum): Float

  """
  Balances by currencies for the address
  """
  balances(
    date: DateSelector
    time: DateTimeSelector
    currency: TronCurrencySelector
    height: BlockSelectorRange
  ): [TronBalance!]

  """
  Rewards that a witness or a user has not yet withdrawn
  """
  claimableRewards(in: BaseCurrencyEnum): Float

  """
  Smart Contract if exists on the address
  """
  smartContract: TronSmartContractInfo
}

input TronArgumentFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txIndex: IntegerSelector
  txHash: HashSelector
  owner: AddressSelector
  receiver: AddressSelector
  reference: AddressSelector
  value: [ArgumentValueSelector!]
  argument: [ArgumentSelector!]
  argumentType: ArgumentTypeSelector
  signatureType: SignatureTypeSelector
  smartContractAddress: AddressSelector
  smartContractMethod: MethodSelector
  smartContractEvent: EventSelector
  external: Boolean
  callDepth: StringSelector
}

"""
Arguments of Smart Contract Calls and Events
"""
type TronArguments {
  any(
    of: TronArgumentsMeasureable!
    as: TronArgumentsConvertable
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txIndex: IntegerSelector
    txHash: HashSelector
    owner: AddressSelector
    receiver: AddressSelector
    reference: AddressSelector
    value: [ArgumentValueSelector!]
    argument: [ArgumentSelector!]
    argumentType: ArgumentTypeSelector
    signatureType: SignatureTypeSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    smartContractEvent: EventSelector
    external: Boolean
    callDepth: StringSelector
  ): String

  """
  Method or event argument
  """
  argument(argument: [ArgumentSelector!], argumentType: String): ArgumentName

  """
  Block in the blockchain
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Depth of the call. Empty string for external call, then counted as 0...N, and
  the next layer is added through '-'. For example 0-3-9.
  """
  callDepth: String

  """
  Counts and other metrics
  """
  count(
    uniq: TronArgumentUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txIndex: IntegerSelector
    txHash: HashSelector
    owner: AddressSelector
    receiver: AddressSelector
    reference: AddressSelector
    value: [ArgumentValueSelector!]
    argument: [ArgumentSelector!]
    argumentType: ArgumentTypeSelector
    signatureType: SignatureTypeSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    smartContractEvent: EventSelector
    external: Boolean
    callDepth: StringSelector
  ): Int

  """
  Counts and other metrics
  """
  countBigInt(
    uniq: TronArgumentUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txIndex: IntegerSelector
    txHash: HashSelector
    owner: AddressSelector
    receiver: AddressSelector
    reference: AddressSelector
    value: [ArgumentValueSelector!]
    argument: [ArgumentSelector!]
    argumentType: ArgumentTypeSelector
    signatureType: SignatureTypeSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    smartContractEvent: EventSelector
    external: Boolean
    callDepth: StringSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  External call executed explicitly by tx sender. Internal calls executed by smart contracts.
  """
  external: Boolean

  """
  Sequential index of value in array ( multi-dimensional)
  """
  index: String!
  maximum(
    of: TronArgumentsMeasureable!
    get: TronArgumentsMeasureable
    as: TronArgumentsConvertable
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txIndex: IntegerSelector
    txHash: HashSelector
    owner: AddressSelector
    receiver: AddressSelector
    reference: AddressSelector
    value: [ArgumentValueSelector!]
    argument: [ArgumentSelector!]
    argumentType: ArgumentTypeSelector
    signatureType: SignatureTypeSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    smartContractEvent: EventSelector
    external: Boolean
    callDepth: StringSelector
  ): String
  minimum(
    of: TronArgumentsMeasureable!
    get: TronArgumentsMeasureable
    as: TronArgumentsConvertable
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txIndex: IntegerSelector
    txHash: HashSelector
    owner: AddressSelector
    receiver: AddressSelector
    reference: AddressSelector
    value: [ArgumentValueSelector!]
    argument: [ArgumentSelector!]
    argumentType: ArgumentTypeSelector
    signatureType: SignatureTypeSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    smartContractEvent: EventSelector
    external: Boolean
    callDepth: StringSelector
  ): String
  number(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txIndex: IntegerSelector
    txHash: HashSelector
    owner: AddressSelector
    receiver: AddressSelector
    reference: AddressSelector
    value: [ArgumentValueSelector!]
    argument: [ArgumentSelector!]
    argumentType: ArgumentTypeSelector
    signatureType: SignatureTypeSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    smartContractEvent: EventSelector
    external: Boolean
    callDepth: StringSelector
  ): Float

  """
  Owner address
  """
  owner: TronAddressInfo

  """
  Transaction receiver
  """
  receiver: TronAddressInfo

  """
  Address value of method or event argument
  """
  reference: TronAddressInfo

  """
  Smart contract being called
  """
  smartContract: TronSmartContract

  """
  Contract method or event
  """
  smartContractSignature(
    smartContractMethod: MethodSelector
    smartContractEvent: EventSelector
    signatureType: SignatureTypeSelector
  ): Signature

  """
  Transaction Hash
  """
  txHash: String

  """
  Transaction Index
  """
  txIndex: Int

  """
  The Value of method or event argument
  """
  value(value: [ArgumentValueSelector!]): ArgumentValue
}

enum TronArgumentsConvertable {
  """
  Token symbol
  """
  token_symbol

  """
  Token name
  """
  token_name
}

enum TronArgumentsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Transaction Index
  """
  tx_index

  """
  Owner
  """
  owner

  """
  Receiver
  """
  receiver

  """
  Smart Contract
  """
  smart_contract

  """
  Smart Contract Method Name
  """
  signature_name

  """
  Smart Contract Method Signature
  """
  signature

  """
  Smart Contract Method Signature
  """
  signature_type

  """
  Smart Contract Method Signature Hash
  """
  signature_hash

  """
  Call depth
  """
  call_depth

  """
  Argument
  """
  argument

  """
  Argument type
  """
  argument_type

  """
  Argument value
  """
  argument_value

  """
  Argument index
  """
  argument_index
}

enum TronArgumentUniq {
  """
  Unique time
  """
  times

  """
  Unique date count
  """
  dates

  """
  Unique Number of block in the blockchains
  """
  block_height

  """
  Calls
  """
  calls

  """
  Unique Transaction Hash
  """
  signature

  """
  Unique Values
  """
  values

  """
  Unique Transactions
  """
  txs

  """
  Unique Owners
  """
  owners

  """
  Unique Receivers
  """
  receivers

  """
  Unique number of arguments
  """
  smart_contracts
}

"""
Balance in a currency
"""
type TronBalance {
  """
  Currency of transfer
  """
  currency: Currency

  """
  History of balance changes by currencies for the address
  """
  history: [TronBalanceChange!]
  value(in: BaseCurrencyEnum): Float
}

"""
Change of balance in a currency
"""
type TronBalanceChange {
  """
  Block number (height) in blockchain
  """
  block: Int!

  """
  Block timestamp
  """
  timestamp: ISO8601DateTime

  """
  Transfer amount ( positive inbound, negative outbound)
  """
  transferAmount: Float
  value: Float
}

input TronBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  witness: AddressSelector
  version: IntegerSelector
  parentBlockHash: [HashSelector!]
}

"""
Blocks in Tron blockchain
"""
type TronBlocks {
  any(of: TronBlocksMeasureable!): String
  count(
    uniq: TronBlocksUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    witness: AddressSelector
    version: IntegerSelector
    parentBlockHash: [HashSelector!]
  ): Int
  countBigInt(
    uniq: TronBlocksUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    blockHash: HashSelector
    witness: AddressSelector
    version: IntegerSelector
    parentBlockHash: [HashSelector!]
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber

  """
  Block hash
  """
  hash(blockHash: [HashSelector!]): String!

  """
  Block number (height) in blockchain
  """
  height(height: BlockSelector): Int!
  maximum(of: TronBlocksMeasureable!, get: TronBlocksMeasureable): String
  minimum(of: TronBlocksMeasureable!, get: TronBlocksMeasureable): String

  """
  Parent block hash
  """
  parentBlockHash(parentBlockHash: [HashSelector!]): String!

  """
  Block timestamp
  """
  timestamp(time: DateTimeSelector): DateTime

  """
  TX Trie Root Hash
  """
  txTrieRoot: String!

  """
  Block version
  """
  version(version: IntegerSelector): Int

  """
  Block witness
  """
  witness(witness: AddressSelector): Address

  """
  Witness signature
  """
  witnessSignature: String!
}

enum TronBlocksMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Block hash
  """
  block_hash

  """
  Block Witness address
  """
  witness

  """
  Block Version
  """
  version
}

enum TronBlocksUniq {
  """
  Unique witness count
  """
  witnesses

  """
  Unique date count
  """
  dates
}

enum TronCallsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Action From
  """
  tx_from

  """
  Action To
  """
  tx_to

  """
  Smart Contract
  """
  smart_contract

  """
  Smart Contract Method Name
  """
  signature_name

  """
  Smart Contract Method Signature
  """
  signature

  """
  Smart Contract Method Signature Hash
  """
  signature_hash

  """
  Call depth
  """
  call_depth
}

"""
Coinpath
"""
type TronCoinpath {
  """
  Summary of transfered value
  """
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """
  Block where transaction is included
  """
  block: Block

  """
  Count of transfers
  """
  count: Int

  """
  Count of transfers
  """
  countBigInt: BigInt

  """
  Currency of transfer
  """
  currency: Currency

  """
  1-based hop depth of the graph
  """
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """
  Receiver address
  """
  receiver: TronCoinpathAddress

  """
  Sender address
  """
  sender: TronCoinpathAddress

  """
  Transaction of transfer happened
  """
  transaction: TransactionHashValueTime
}

"""
Address detailed information for Ethereum network
"""
type TronCoinpathAddress {
  """
  Address
  """
  address: String
  amountIn: DecimalNumber
  amountOut: DecimalNumber

  """
  Annotations ( tags ), if exists
  """
  annotation: String
  balance: DecimalNumber

  """
  Smart Contract if exists on the address
  """
  firstTxAt: DateTime

  """
  Smart Contract if exists on the address
  """
  lastTxAt: DateTime
  receiversCount: Int
  sendersCount: Int

  """
  Smart Contract if exists on the address
  """
  smartContract: TronSmartContractInfo

  """
  Address type
  """
  type: String
}

input TronContractFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txOwner: AddressSelector
  contractType: TronContractTypeSelector
  currency: TronCurrencySelector
  success: Boolean
}

enum TronContractsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Transaction owner
  """
  tx_owner

  """
  Contract
  """
  contract_type
}

"""
Select contract type(s)
"""
input TronContractTypeSelector {
  """
  Contract type is
  """
  is: String

  """
  Contract type not
  """
  not: String

  """
  Contract type in the list
  """
  in: [String!]

  """
  Contract type not in the list
  """
  notIn: [String!]
}

"""
Currency selector in Tron blockchain.
Token identified by address of contract for TRC20 tokens and token name (or numeric token ID )  for TRC10
"""
input TronCurrencySelector {
  """
  Currency is
  """
  is: String

  """
  Currency not
  """
  not: String

  """
  Currency in the list
  """
  in: [String!]

  """
  Currency not in the list
  """
  notIn: [String!]
}

"""
Tron DEX attributes
"""
type TronDex {
  """
  Address for DEX exchange identification
  """
  address: Address!

  """
  Full name ( name for known, Protocol for unknown )
  """
  fullName: String!

  """
  Full name ( name for known, Protocol / address for unknown )
  """
  fullNameWithId: String!

  """
  Name for known exchanges
  """
  name: String
}

input TronDexTradeFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  protocol: [StringSelector!]
  smartContractAddress: [AddressSelector!]
  exchangeAddress: [AddressSelector!]
  exchangeName: [StringSelector!]
  sellCurrency: [TronCurrencySelector!]
  buyCurrency: [TronCurrencySelector!]
  baseCurrency: [TronCurrencySelector!]
  quoteCurrency: [TronCurrencySelector!]
  maker: [AddressSelector!]
  taker: [AddressSelector!]
  makerOrTaker: [AddressSelector!]
  tradeIndex: [StringSelector!]
  buyAmount: [AmountSelector!]
  sellAmount: [AmountSelector!]
  price: [AmountSelector!]
  priceAsymmetry: [FloatSelector!]
  tradeAmountUsd: [FloatSelector!]
}

"""
Trades on DEX smart contracts
"""
type TronDexTrades {
  """
  Trader (maker or taker)
  """
  address(makerOrTaker: [AddressSelector!]): TronAddressInfo
  any(of: TronDexTradesMeasureable!): String
  baseAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  """
  Base currency
  """
  baseCurrency(baseCurrency: [TronCurrencySelector!]): Currency

  """
  Block in the blockchain
  """
  block(height: BlockSelector, time: DateTimeSelector): BlockExtended
  buyAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  """
  Maker buys this currency
  """
  buyCurrency(buyCurrency: [TronCurrencySelector!]): Currency
  count(
    uniq: TronDexTradesUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    protocol: [StringSelector!]
    smartContractAddress: [AddressSelector!]
    exchangeAddress: [AddressSelector!]
    exchangeName: [StringSelector!]
    sellCurrency: [TronCurrencySelector!]
    buyCurrency: [TronCurrencySelector!]
    baseCurrency: [TronCurrencySelector!]
    quoteCurrency: [TronCurrencySelector!]
    maker: [AddressSelector!]
    taker: [AddressSelector!]
    makerOrTaker: [AddressSelector!]
    tradeIndex: [StringSelector!]
    buyAmount: [AmountSelector!]
    sellAmount: [AmountSelector!]
    price: [AmountSelector!]
    priceAsymmetry: [FloatSelector!]
    tradeAmountUsd: [FloatSelector!]
  ): Int
  countBigInt(
    uniq: TronDexTradesUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    protocol: [StringSelector!]
    smartContractAddress: [AddressSelector!]
    exchangeAddress: [AddressSelector!]
    exchangeName: [StringSelector!]
    sellCurrency: [TronCurrencySelector!]
    buyCurrency: [TronCurrencySelector!]
    baseCurrency: [TronCurrencySelector!]
    quoteCurrency: [TronCurrencySelector!]
    maker: [AddressSelector!]
    taker: [AddressSelector!]
    makerOrTaker: [AddressSelector!]
    tradeIndex: [StringSelector!]
    buyAmount: [AmountSelector!]
    sellAmount: [AmountSelector!]
    price: [AmountSelector!]
    priceAsymmetry: [FloatSelector!]
    tradeAmountUsd: [FloatSelector!]
  ): BigInt

  """
  Calendar date
  """
  date: Date
  energyFee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    protocol: [StringSelector!]
    smartContractAddress: [AddressSelector!]
    exchangeAddress: [AddressSelector!]
    exchangeName: [StringSelector!]
    sellCurrency: [TronCurrencySelector!]
    buyCurrency: [TronCurrencySelector!]
    baseCurrency: [TronCurrencySelector!]
    quoteCurrency: [TronCurrencySelector!]
    maker: [AddressSelector!]
    taker: [AddressSelector!]
    makerOrTaker: [AddressSelector!]
    tradeIndex: [StringSelector!]
    buyAmount: [AmountSelector!]
    sellAmount: [AmountSelector!]
    price: [AmountSelector!]
    priceAsymmetry: [FloatSelector!]
    tradeAmountUsd: [FloatSelector!]
  ): Float
  energyUsageTotal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    protocol: [StringSelector!]
    smartContractAddress: [AddressSelector!]
    exchangeAddress: [AddressSelector!]
    exchangeName: [StringSelector!]
    sellCurrency: [TronCurrencySelector!]
    buyCurrency: [TronCurrencySelector!]
    baseCurrency: [TronCurrencySelector!]
    quoteCurrency: [TronCurrencySelector!]
    maker: [AddressSelector!]
    taker: [AddressSelector!]
    makerOrTaker: [AddressSelector!]
    tradeIndex: [StringSelector!]
    buyAmount: [AmountSelector!]
    sellAmount: [AmountSelector!]
    price: [AmountSelector!]
    priceAsymmetry: [FloatSelector!]
    tradeAmountUsd: [FloatSelector!]
  ): Float

  """
  Identification of admin / manager / factory of smart contract, executing trades
  """
  exchange(
    exchangeAddress: [AddressSelector!]
    exchangeName: [StringSelector!]
  ): TronDex
  expression(get: String!): DecimalNumber
  fee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    protocol: [StringSelector!]
    smartContractAddress: [AddressSelector!]
    exchangeAddress: [AddressSelector!]
    exchangeName: [StringSelector!]
    sellCurrency: [TronCurrencySelector!]
    buyCurrency: [TronCurrencySelector!]
    baseCurrency: [TronCurrencySelector!]
    quoteCurrency: [TronCurrencySelector!]
    maker: [AddressSelector!]
    taker: [AddressSelector!]
    makerOrTaker: [AddressSelector!]
    tradeIndex: [StringSelector!]
    buyAmount: [AmountSelector!]
    sellAmount: [AmountSelector!]
    price: [AmountSelector!]
    priceAsymmetry: [FloatSelector!]
    tradeAmountUsd: [FloatSelector!]
  ): Float
  internalTransactionsCount(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    protocol: [StringSelector!]
    smartContractAddress: [AddressSelector!]
    exchangeAddress: [AddressSelector!]
    exchangeName: [StringSelector!]
    sellCurrency: [TronCurrencySelector!]
    buyCurrency: [TronCurrencySelector!]
    baseCurrency: [TronCurrencySelector!]
    quoteCurrency: [TronCurrencySelector!]
    maker: [AddressSelector!]
    taker: [AddressSelector!]
    makerOrTaker: [AddressSelector!]
    tradeIndex: [StringSelector!]
    buyAmount: [AmountSelector!]
    sellAmount: [AmountSelector!]
    price: [AmountSelector!]
    priceAsymmetry: [FloatSelector!]
    tradeAmountUsd: [FloatSelector!]
  ): Int
  internalTransactionsCountBigInt(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    protocol: [StringSelector!]
    smartContractAddress: [AddressSelector!]
    exchangeAddress: [AddressSelector!]
    exchangeName: [StringSelector!]
    sellCurrency: [TronCurrencySelector!]
    buyCurrency: [TronCurrencySelector!]
    baseCurrency: [TronCurrencySelector!]
    quoteCurrency: [TronCurrencySelector!]
    maker: [AddressSelector!]
    taker: [AddressSelector!]
    makerOrTaker: [AddressSelector!]
    tradeIndex: [StringSelector!]
    buyAmount: [AmountSelector!]
    sellAmount: [AmountSelector!]
    price: [AmountSelector!]
    priceAsymmetry: [FloatSelector!]
    tradeAmountUsd: [FloatSelector!]
  ): BigInt
  logsCount(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    protocol: [StringSelector!]
    smartContractAddress: [AddressSelector!]
    exchangeAddress: [AddressSelector!]
    exchangeName: [StringSelector!]
    sellCurrency: [TronCurrencySelector!]
    buyCurrency: [TronCurrencySelector!]
    baseCurrency: [TronCurrencySelector!]
    quoteCurrency: [TronCurrencySelector!]
    maker: [AddressSelector!]
    taker: [AddressSelector!]
    makerOrTaker: [AddressSelector!]
    tradeIndex: [StringSelector!]
    buyAmount: [AmountSelector!]
    sellAmount: [AmountSelector!]
    price: [AmountSelector!]
    priceAsymmetry: [FloatSelector!]
    tradeAmountUsd: [FloatSelector!]
  ): Int
  logsCountBigInt(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    protocol: [StringSelector!]
    smartContractAddress: [AddressSelector!]
    exchangeAddress: [AddressSelector!]
    exchangeName: [StringSelector!]
    sellCurrency: [TronCurrencySelector!]
    buyCurrency: [TronCurrencySelector!]
    baseCurrency: [TronCurrencySelector!]
    quoteCurrency: [TronCurrencySelector!]
    maker: [AddressSelector!]
    taker: [AddressSelector!]
    makerOrTaker: [AddressSelector!]
    tradeIndex: [StringSelector!]
    buyAmount: [AmountSelector!]
    sellAmount: [AmountSelector!]
    price: [AmountSelector!]
    priceAsymmetry: [FloatSelector!]
    tradeAmountUsd: [FloatSelector!]
  ): BigInt

  """
  Trade 'maker' side
  """
  maker(maker: [AddressSelector!]): TronAddressInfo
  maximum(of: TronDexTradesMeasureable!, get: TronDexTradesMeasureable): String
  minimum(of: TronDexTradesMeasureable!, get: TronDexTradesMeasureable): String
  netFee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    protocol: [StringSelector!]
    smartContractAddress: [AddressSelector!]
    exchangeAddress: [AddressSelector!]
    exchangeName: [StringSelector!]
    sellCurrency: [TronCurrencySelector!]
    buyCurrency: [TronCurrencySelector!]
    baseCurrency: [TronCurrencySelector!]
    quoteCurrency: [TronCurrencySelector!]
    maker: [AddressSelector!]
    taker: [AddressSelector!]
    makerOrTaker: [AddressSelector!]
    tradeIndex: [StringSelector!]
    buyAmount: [AmountSelector!]
    sellAmount: [AmountSelector!]
    price: [AmountSelector!]
    priceAsymmetry: [FloatSelector!]
    tradeAmountUsd: [FloatSelector!]
  ): Float
  netUsage(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    protocol: [StringSelector!]
    smartContractAddress: [AddressSelector!]
    exchangeAddress: [AddressSelector!]
    exchangeName: [StringSelector!]
    sellCurrency: [TronCurrencySelector!]
    buyCurrency: [TronCurrencySelector!]
    baseCurrency: [TronCurrencySelector!]
    quoteCurrency: [TronCurrencySelector!]
    maker: [AddressSelector!]
    taker: [AddressSelector!]
    makerOrTaker: [AddressSelector!]
    tradeIndex: [StringSelector!]
    buyAmount: [AmountSelector!]
    sellAmount: [AmountSelector!]
    price: [AmountSelector!]
    priceAsymmetry: [FloatSelector!]
    tradeAmountUsd: [FloatSelector!]
  ): Float
  price(
    calculate: PriceAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    protocol: [StringSelector!]
    smartContractAddress: [AddressSelector!]
    exchangeAddress: [AddressSelector!]
    exchangeName: [StringSelector!]
    sellCurrency: [TronCurrencySelector!]
    buyCurrency: [TronCurrencySelector!]
    baseCurrency: [TronCurrencySelector!]
    quoteCurrency: [TronCurrencySelector!]
    maker: [AddressSelector!]
    taker: [AddressSelector!]
    makerOrTaker: [AddressSelector!]
    tradeIndex: [StringSelector!]
    buyAmount: [AmountSelector!]
    sellAmount: [AmountSelector!]
    price: [AmountSelector!]
    priceAsymmetry: [FloatSelector!]
    tradeAmountUsd: [FloatSelector!]
  ): Float

  """
  Protocol name of the smart contract
  """
  protocol(protocol: [StringSelector!]): String
  quoteAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  """
  Quote currency
  """
  quoteCurrency(quoteCurrency: [TronCurrencySelector!]): Currency
  quotePrice(
    calculate: PriceAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    protocol: [StringSelector!]
    smartContractAddress: [AddressSelector!]
    exchangeAddress: [AddressSelector!]
    exchangeName: [StringSelector!]
    sellCurrency: [TronCurrencySelector!]
    buyCurrency: [TronCurrencySelector!]
    baseCurrency: [TronCurrencySelector!]
    quoteCurrency: [TronCurrencySelector!]
    maker: [AddressSelector!]
    taker: [AddressSelector!]
    makerOrTaker: [AddressSelector!]
    tradeIndex: [StringSelector!]
    buyAmount: [AmountSelector!]
    sellAmount: [AmountSelector!]
    price: [AmountSelector!]
    priceAsymmetry: [FloatSelector!]
    tradeAmountUsd: [FloatSelector!]
  ): Float
  sellAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  """
  Maker sells this currency
  """
  sellCurrency(sellCurrency: [TronCurrencySelector!]): Currency

  """
  Side of trade ( SELL / BUY )
  """
  side: TradeSide

  """
  Smart contract being called
  """
  smartContract(smartContractAddress: [AddressSelector!]): TronSmartContract

  """
  Trade 'taker' side
  """
  taker(taker: [AddressSelector!]): TronAddressInfo

  """
  Time interval
  """
  timeInterval: TimeInterval
  tradeAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum!): Float

  """
  Index of trade in transaction, used to separate trades in transaction
  """
  tradeIndex(tradeIndex: [StringSelector!]): String

  """
  Transaction of DexTrade
  """
  transaction(txHash: [HashSelector!]): TronTransactionInfoExtended
}

enum TronDexTradesMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Buy Amount
  """
  buy_amount

  """
  Sell Amount
  """
  sell_amount

  """
  Price
  """
  price

  """
  Quote Price
  """
  quote_price

  """
  Maker
  """
  maker

  """
  Taker
  """
  taker

  """
  Buy Currency symbol
  """
  buy_currency_symbol

  """
  Buy Token address
  """
  buy_currency_address

  """
  Sell Currency symbol
  """
  sell_currency_symbol

  """
  Sell Token address
  """
  sell_currency_address
}

enum TronDexTradesUniq {
  """
  Unique makers count
  """
  makers

  """
  Unique makers count
  """
  takers

  """
  Unique makers & takers count
  """
  address

  """
  Buy currencies count
  """
  buy_currency

  """
  Sell currencies count
  """
  sell_currency

  """
  Base currencies count
  """
  base_currency

  """
  Quote currencies count
  """
  quote_currency

  """
  Unique blocks
  """
  blocks

  """
  Unique transactions count
  """
  txs

  """
  Unique date count
  """
  dates

  """
  Unique smart contract count
  """
  smart_contracts

  """
  Unique protocols count
  """
  protocols
}

enum TronEventsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Action From
  """
  tx_from

  """
  Action To
  """
  tx_to

  """
  Smart Contract
  """
  smart_contract

  """
  Smart Contract Method Name
  """
  signature_name

  """
  Smart Contract Method Signature
  """
  signature

  """
  Smart Contract Method Signature Hash
  """
  signature_hash
}

enum TronNetwork {
  """
  TRON mainnet
  """
  tron
}

"""
Tron smart contract
"""
type TronSmartContract {
  """
  Smart Contract Address
  """
  address: Address!

  """
  Smart Contract Type
  """
  contractType: SmartContractType

  """
  Token implemented in this smart contract
  """
  currency: ScCurrency

  """
  Smart Contract Protocol Type
  """
  protocolType: String
}

input TronSmartContractCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  smartContractAddress: AddressSelector
  smartContractMethod: MethodSelector
  external: Boolean
  success: Boolean
}

"""
Smart Contract Calls
"""
type TronSmartContractCalls {
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    external: Boolean
    success: Boolean
  ): Float
  any(of: TronCallsMeasureable!): String

  """
  Call arguments
  """
  arguments: [ArgumentNameValue!]

  """
  Block in the blockchain
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Depth of the call. Empty string for external call, then counted as 0...N, and
  the next layer is added through '-'. For example 0-3-9.
  """
  callDepth: String

  """
  Counts and other metrics
  """
  count(
    uniq: SmartContractCallsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    external: Boolean
    success: Boolean
  ): Int

  """
  Counts and other metrics
  """
  countBigInt(
    uniq: SmartContractCallsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    external: Boolean
    success: Boolean
  ): BigInt

  """
  Calendar date
  """
  date: Date
  energyUsageTotal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    external: Boolean
    success: Boolean
  ): Float
  expression(get: String!): DecimalNumber

  """
  External call executed explicitly by caller. Internal calls executed by smart contracts.
  """
  external(external: Boolean): Boolean
  fee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    external: Boolean
    success: Boolean
  ): Float
  maximum(of: TronCallsMeasureable!, get: TronCallsMeasureable): String
  minimum(of: TronCallsMeasureable!, get: TronCallsMeasureable): String
  netUsage(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    external: Boolean
    success: Boolean
  ): Float

  """
  Smart contract being called
  """
  smartContract(smartContractAddress: AddressSelector): TronSmartContract

  """
  Contract method invoked
  """
  smartContractMethod(smartContractMethod: MethodSelector): Method

  """
  True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
  """
  success(success: [Boolean!]): Boolean

  """
  Action from address
  """
  txFrom(txFrom: AddressSelector): Address

  """
  Transaction hash where transfer happened
  """
  txHash(txHash: HashSelector): String

  """
  Action to address
  """
  txTo(txTo: AddressSelector): Address
}

input TronSmartContractEventFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  smartContractAddress: AddressSelector
  smartContractEvent: EventSelector
}

"""
Smart Contract Events
"""
type TronSmartContractEvents {
  any(of: TronEventsMeasureable!): String

  """
  Call arguments
  """
  arguments: [ArgumentNameValue!]

  """
  Block in the blockchain
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Counts and other metrics
  """
  count(
    uniq: SmartContractCallsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    smartContractAddress: AddressSelector
    smartContractEvent: EventSelector
  ): Int

  """
  Counts and other metrics
  """
  countBigInt(
    uniq: SmartContractCallsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    smartContractAddress: AddressSelector
    smartContractEvent: EventSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  expression(get: String!): DecimalNumber
  maximum(of: TronEventsMeasureable!, get: TronEventsMeasureable): String
  minimum(of: TronEventsMeasureable!, get: TronEventsMeasureable): String

  """
  Smart contract being Evented
  """
  smartContract(smartContractAddress: AddressSelector): TronSmartContract

  """
  Contract method invoked
  """
  smartContractEvent(smartContractEvent: EventSelector): Event

  """
  Action from address
  """
  txFrom(txFrom: AddressSelector): Address

  """
  Transaction hash where transfer happened
  """
  txHash(txHash: HashSelector): String

  """
  Action to address
  """
  txTo(txTo: AddressSelector): Address
}

"""
Blockchain smart contract
"""
type TronSmartContractInfo {
  """
  Smart Contract Type
  """
  contractType: SmartContractType

  """
  Token implemented in this smart contract
  """
  currency: ScCurrency

  """
  Smart Contract Protocol Type
  """
  protocolType: String
}

"""
Contracts
"""
type TronSmartContracts {
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txOwner: AddressSelector
    contractType: TronContractTypeSelector
    currency: TronCurrencySelector
    success: Boolean
  ): Float
  any(of: TronContractsMeasureable!): String

  """
  Block in the blockchain
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Contract type
  """
  contractType(contractType: TronContractTypeSelector): String

  """
  Counts and other metrics
  """
  count(
    uniq: SmartContractCallsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txOwner: AddressSelector
    contractType: TronContractTypeSelector
    currency: TronCurrencySelector
    success: Boolean
  ): Int

  """
  Counts and other metrics
  """
  countBigInt(
    uniq: SmartContractCallsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txOwner: AddressSelector
    contractType: TronContractTypeSelector
    currency: TronCurrencySelector
    success: Boolean
  ): BigInt

  """
  Currency of transfer
  """
  currency(currency: TronCurrencySelector): Currency

  """
  Calendar date
  """
  date: Date
  energyUsageTotal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txOwner: AddressSelector
    contractType: TronContractTypeSelector
    currency: TronCurrencySelector
    success: Boolean
  ): Float
  expression(get: String!): DecimalNumber
  fee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txOwner: AddressSelector
    contractType: TronContractTypeSelector
    currency: TronCurrencySelector
    success: Boolean
  ): Float
  maximum(of: TronContractsMeasureable!, get: TronContractsMeasureable): String
  minimum(of: TronContractsMeasureable!, get: TronContractsMeasureable): String
  netUsage(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txOwner: AddressSelector
    contractType: TronContractTypeSelector
    currency: TronCurrencySelector
    success: Boolean
  ): Float

  """
  True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
  """
  success(success: [Boolean!]): Boolean

  """
  Transaction hash where transfer happened
  """
  txHash(txHash: HashSelector): String

  """
  Transactio owner from address
  """
  txOwner(txOwner: AddressSelector): Address
}

input TronTradeFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  buyer: AddressSelector
  seller: AddressSelector
  buyCurrency: TronCurrencySelector
  sellCurrency: TronCurrencySelector
  contractType: TronContractTypeSelector
  amountSell: [AmountSelector!]
  amountBuy: [AmountSelector!]
  exchangeId: IntIdSelector
  success: Boolean
}

"""
Currency Trades from/to addresses in crypto currencies
"""
type TronTrades {
  amountBuy(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    buyer: AddressSelector
    seller: AddressSelector
    buyCurrency: TronCurrencySelector
    sellCurrency: TronCurrencySelector
    contractType: TronContractTypeSelector
    amountSell: [AmountSelector!]
    amountBuy: [AmountSelector!]
    exchangeId: IntIdSelector
    success: Boolean
  ): Float
  amountSell(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    buyer: AddressSelector
    seller: AddressSelector
    buyCurrency: TronCurrencySelector
    sellCurrency: TronCurrencySelector
    contractType: TronContractTypeSelector
    amountSell: [AmountSelector!]
    amountBuy: [AmountSelector!]
    exchangeId: IntIdSelector
    success: Boolean
  ): Float
  any(of: TronTradesMeasureable!): String

  """
  Block where Trade transaction is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Buy Currency of Trade
  """
  buyCurrency(buyCurrency: TronCurrencySelector): Currency

  """
  Trade buyer
  """
  buyer(buyer: AddressSelector): Address

  """
  Contract type
  """
  contractType(contractType: TronContractTypeSelector): String
  count(
    uniq: TronTradesUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    buyer: AddressSelector
    seller: AddressSelector
    buyCurrency: TronCurrencySelector
    sellCurrency: TronCurrencySelector
    contractType: TronContractTypeSelector
    amountSell: [AmountSelector!]
    amountBuy: [AmountSelector!]
    exchangeId: IntIdSelector
    success: Boolean
  ): Int
  countBigInt(
    uniq: TronTradesUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    buyer: AddressSelector
    seller: AddressSelector
    buyCurrency: TronCurrencySelector
    sellCurrency: TronCurrencySelector
    contractType: TronContractTypeSelector
    amountSell: [AmountSelector!]
    amountBuy: [AmountSelector!]
    exchangeId: IntIdSelector
    success: Boolean
  ): BigInt

  """
  Calendar date
  """
  date: Date
  energyUsageTotal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    buyer: AddressSelector
    seller: AddressSelector
    buyCurrency: TronCurrencySelector
    sellCurrency: TronCurrencySelector
    contractType: TronContractTypeSelector
    amountSell: [AmountSelector!]
    amountBuy: [AmountSelector!]
    exchangeId: IntIdSelector
    success: Boolean
  ): Float

  """
  exchange_id
  """
  exchangeId(exchangeId: IntIdSelector): Int
  expression(get: String!): DecimalNumber
  fee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    buyer: AddressSelector
    seller: AddressSelector
    buyCurrency: TronCurrencySelector
    sellCurrency: TronCurrencySelector
    contractType: TronContractTypeSelector
    amountSell: [AmountSelector!]
    amountBuy: [AmountSelector!]
    exchangeId: IntIdSelector
    success: Boolean
  ): Float
  maximum(of: TronTradesMeasureable!, get: TronTradesMeasureable): String
  minimum(of: TronTradesMeasureable!, get: TronTradesMeasureable): String
  netUsage(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    buyer: AddressSelector
    seller: AddressSelector
    buyCurrency: TronCurrencySelector
    sellCurrency: TronCurrencySelector
    contractType: TronContractTypeSelector
    amountSell: [AmountSelector!]
    amountBuy: [AmountSelector!]
    exchangeId: IntIdSelector
    success: Boolean
  ): Float

  """
  Sell Currency of Trade
  """
  sellCurrency(sellCurrency: TronCurrencySelector): Currency

  """
  Trade seller
  """
  seller(seller: AddressSelector): Address

  """
  Transfer succeeded
  """
  success(success: Boolean): Boolean

  """
  Transaction hash where Trade happened
  """
  txHash(txHash: HashSelector): String
}

enum TronTradesMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Amount Sell
  """
  amount_sell

  """
  Amount Sell
  """
  amount_buy

  """
  Buyer
  """
  buyer

  """
  Seller
  """
  seller

  """
  Buy Currency symbol
  """
  buy_currency_symbol

  """
  Buy Currency name
  """
  buy_currency_name

  """
  Buy Token address
  """
  buy_currency_address

  """
  Buy Token address
  """
  buy_token_id

  """
  Buy Token type
  """
  buy_token_type

  """
  Buy Currency symbol
  """
  sell_currency_symbol

  """
  Buy Currency name
  """
  sell_currency_name

  """
  Buy Token address
  """
  sell_currency_address

  """
  Buy Token address
  """
  sell_token_id

  """
  Buy Token type
  """
  sell_token_type

  """
  Exchange ID
  """
  exchange_id

  """
  Contract Type
  """
  contract_type
}

enum TronTradesUniq {
  """
  Unique blocks
  """
  blocks

  """
  Unique date count
  """
  dates

  """
  Sellers count
  """
  sellers

  """
  Buyers count
  """
  buyers

  """
  Buy currencies
  """
  buy_currencies

  """
  Sell currencies
  """
  sell_currencies

  """
  Exchange IDs
  """
  exchanges
}

input TronTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: TxIndexSelector
  success: Boolean
  refBlockHash: [HashSelector!]
  contractAddress: AddressSelector
}

"""
Blockchain Transaction Extended info
"""
type TronTransactionInfoExtended {
  """
  Contract Address
  """
  contractAddress: Address

  """
  Expiration
  """
  expiration: Int!

  """
  Fee Limit
  """
  feeLimit: Int!

  """
  Hash hex representation
  """
  hash: String!

  """
  Transaction index in block, 0 based
  """
  index: Int

  """
  Ref block Hash hex representation
  """
  refBlockHash: String!

  """
  Result message
  """
  result: String

  """
  Signatures
  """
  signatures: String!

  """
  Success
  """
  success: Boolean
}

"""
Transactions in Tron blockchain
"""
type TronTransactions {
  any(of: TronTransactionsMeasureable!): String

  """
  Block where transfer transaction is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Contract Address
  """
  contractAddress(contractAddress: AddressSelector): Address
  count(
    uniq: TronTransactionsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
    success: Boolean
    refBlockHash: [HashSelector!]
    contractAddress: AddressSelector
  ): Int
  countBigInt(
    uniq: TronTransactionsUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
    success: Boolean
    refBlockHash: [HashSelector!]
    contractAddress: AddressSelector
  ): BigInt

  """
  Calendar date
  """
  date: Date
  energyFee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
    success: Boolean
    refBlockHash: [HashSelector!]
    contractAddress: AddressSelector
  ): Float
  energyUsageTotal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
    success: Boolean
    refBlockHash: [HashSelector!]
    contractAddress: AddressSelector
  ): Float

  """
  Expiration
  """
  expiration: Int!
  expression(get: String!): DecimalNumber
  fee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
    success: Boolean
    refBlockHash: [HashSelector!]
    contractAddress: AddressSelector
  ): Float

  """
  Fee Limit
  """
  feeLimit: Int!

  """
  Hash hex representation
  """
  hash(txHash: [HashSelector!]): String!

  """
  Transaction index in block, 0 based
  """
  index(txIndex: [TxIndexSelector!]): Int
  internalTransactionsCount(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
    success: Boolean
    refBlockHash: [HashSelector!]
    contractAddress: AddressSelector
  ): Int
  internalTransactionsCountBigInt(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
    success: Boolean
    refBlockHash: [HashSelector!]
    contractAddress: AddressSelector
  ): BigInt
  logsCount(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
    success: Boolean
    refBlockHash: [HashSelector!]
    contractAddress: AddressSelector
  ): Int
  logsCountBigInt(
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
    success: Boolean
    refBlockHash: [HashSelector!]
    contractAddress: AddressSelector
  ): BigInt
  maximum(
    of: TronTransactionsMeasureable!
    get: TronTransactionsMeasureable
  ): String
  minimum(
    of: TronTransactionsMeasureable!
    get: TronTransactionsMeasureable
  ): String
  netFee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
    success: Boolean
    refBlockHash: [HashSelector!]
    contractAddress: AddressSelector
  ): Float
  netUsage(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
    success: Boolean
    refBlockHash: [HashSelector!]
    contractAddress: AddressSelector
  ): Float

  """
  Ref block Hash hex representation
  """
  refBlockHash(refBlockHash: [HashSelector!]): String!

  """
  Result message
  """
  result: String

  """
  Signatures
  """
  signatures: String!

  """
  Success
  """
  success(success: Boolean): Boolean
}

enum TronTransactionsMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Fee
  """
  fee

  """
  Fee Limit
  """
  fee_limit

  """
  Energy Fee
  """
  energy_fee

  """
  Net usage
  """
  net_usage

  """
  Internal transactions count
  """
  internal_transactions_count
}

enum TronTransactionsUniq {
  """
  Unique blocks
  """
  blocks

  """
  Unique date count
  """
  dates
}

input TronTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  sender: AddressSelector
  receiver: AddressSelector
  currency: TronCurrencySelector
  contractType: TronContractTypeSelector
  entityId: EntitySelector
  external: Boolean
  success: Boolean
  amount: [AmountSelector!]
}

"""
Currency transfers from/to addresses in crypto currencies
"""
type TronTransfers {
  amount(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    sender: AddressSelector
    receiver: AddressSelector
    currency: TronCurrencySelector
    contractType: TronContractTypeSelector
    entityId: EntitySelector
    external: Boolean
    success: Boolean
    amount: [AmountSelector!]
  ): Float
  any(of: TronTransfersMeasureable!): String

  """
  Block where transfer transaction is included
  """
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Contract type
  """
  contractType(contractType: TronContractTypeSelector): String
  count(
    uniq: TransfersUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    sender: AddressSelector
    receiver: AddressSelector
    currency: TronCurrencySelector
    contractType: TronContractTypeSelector
    entityId: EntitySelector
    external: Boolean
    success: Boolean
    amount: [AmountSelector!]
  ): Int
  countBigInt(
    uniq: TransfersUniq
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    sender: AddressSelector
    receiver: AddressSelector
    currency: TronCurrencySelector
    contractType: TronContractTypeSelector
    entityId: EntitySelector
    external: Boolean
    success: Boolean
    amount: [AmountSelector!]
  ): BigInt

  """
  Currency of transfer
  """
  currency(currency: TronCurrencySelector): Currency

  """
  Calendar date
  """
  date: Date
  energyUsageTotal(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    sender: AddressSelector
    receiver: AddressSelector
    currency: TronCurrencySelector
    contractType: TronContractTypeSelector
    entityId: EntitySelector
    external: Boolean
    success: Boolean
    amount: [AmountSelector!]
  ): Float

  """
  Entity identifier ( for ERC-721 NFT tokens )
  """
  entityId(entityId: EntitySelector): String
  expression(get: String!): DecimalNumber

  """
  External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts.
  """
  external(external: Boolean): Boolean
  fee(
    calculate: AmountAggregateFunction
    in: BaseCurrencyEnum
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    sender: AddressSelector
    receiver: AddressSelector
    currency: TronCurrencySelector
    contractType: TronContractTypeSelector
    entityId: EntitySelector
    external: Boolean
    success: Boolean
    amount: [AmountSelector!]
  ): Float
  maximum(of: TronTransfersMeasureable!, get: TronTransfersMeasureable): String
  minimum(of: TronTransfersMeasureable!, get: TronTransfersMeasureable): String
  netUsage(
    calculate: AmountAggregateFunction
    date: DateSelector
    time: DateTimeSelector
    height: BlockSelector
    txHash: HashSelector
    txFrom: AddressSelector
    txTo: AddressSelector
    sender: AddressSelector
    receiver: AddressSelector
    currency: TronCurrencySelector
    contractType: TronContractTypeSelector
    entityId: EntitySelector
    external: Boolean
    success: Boolean
    amount: [AmountSelector!]
  ): Float

  """
  Transfer receiver
  """
  receiver(receiver: AddressSelector): Address

  """
  Transfer sender
  """
  sender(sender: AddressSelector): Address

  """
  Transfer succeeded
  """
  success(success: Boolean): Boolean

  """
  Action from address
  """
  txFrom(txFrom: AddressSelector): Address

  """
  Transaction hash where transfer happened
  """
  txHash(txHash: HashSelector): String

  """
  Action to address
  """
  txTo(txTo: AddressSelector): Address
}

enum TronTransfersMeasureable {
  """
  Date
  """
  date

  """
  Time
  """
  time

  """
  Block
  """
  block

  """
  Transaction hash
  """
  tx_hash

  """
  Amount
  """
  amount

  """
  Sender
  """
  sender

  """
  Receiver
  """
  receiver

  """
  Currency symbol
  """
  currency_symbol

  """
  Token address
  """
  currency_address

  """
  Token ID
  """
  token_id

  """
  Token type
  """
  token_type
}

"""
Selector of index of transaction in block
"""
input TxIndexSelector {
  """
  Tx index is
  """
  is: Int

  """
  Tx index not
  """
  not: Int

  """
  Tx index in the list
  """
  in: [Int!]

  """
  Tx index not in the list
  """
  notIn: [Int!]
}

"""
Select transactions by subtype
"""
input TxSubtypeSelector {
  """
  Transaction SubType is
  """
  is: AlgorandTxSubType

  """
  Transaction SubType not
  """
  not: AlgorandTxSubType

  """
  Transaction SubType in the list
  """
  in: [AlgorandTxSubType!]

  """
  Transaction SubType not in the list
  """
  notIn: [AlgorandTxSubType!]
}

"""
Select transactions by type
"""
input TxTypeSelector {
  """
  Transaction Type is
  """
  is: AlgorandTxType

  """
  Transaction Type not
  """
  not: AlgorandTxType

  """
  Transaction Type in the list
  """
  in: [AlgorandTxType!]

  """
  Transaction Type not in the list
  """
  notIn: [AlgorandTxType!]
}

"""
Utilities
"""
type Utilities {
  """
  Active period
  """
  activePeriod(apiKey: String!, options: SeedOptions): ActivePeriod

  """
  Query metrics
  """
  metrics(queryId: String!, options: SeedOptions): Metrics
}

"""
UtilitiesDate
"""
type UtilitiesDate {
  """
  String date representation with default format as YYYY-MM-DD
  """
  date: String!

  """
  Day of month (1-31)
  """
  dayOfMonth: Int!

  """
  Day of week  (Monday is 1, and Sunday is 7)
  """
  dayOfWeek: Int!

  """
  Month number (1-12)
  """
  month: Int!

  """
  Year number
  """
  year: Int!
}
